<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EQTG</name>
    </assembly>
    <members>
        <member name="T:EQTG.Daemons.Daemon.EQTGDaemonProcess">
            <summary>
            Core daemon process class. Inherit from this for your daemon.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ICommandParameterReader">
            <summary>
            Interface to read the CommandParameterList. Used when you want to do a re-read of parameters
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.#ctor">
            <summary>
            Daemon constructor. Reads command line and installs diagnostics views.
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.RegisterAndInstantiateDiagnostics">
            <summary>
            Diagnostics registration and instantiation.
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.InstallDiagnostics(EQTG.General.Diagnostic.DiagnosticsInstaller,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Register Rendezvous diagnostics view in time for instantiation from command line
            </summary>
            <param name="diagnosticsInstaller">Externally supplied Diagnostics installer</param>
            <param name="viewList">List to keep references to instantiated Diagnostics Views</param>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.InitialiseDaemon(System.String,System.String)">
            <summary>
            Daemon initialisation.If you override this method then you should still
            invoke the base implementation BEFORE doing any further work, to ensure you
            have the diagnostics, session info and DB session info set up correctly
            </summary>
            <param name="daemonLogicalName">Type of daemon</param>
            <param name="daemonNamespace">Namespace of this particular install</param>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.PostBasicInitialisation">
            <summary>
            Opportunity for further set up after diagnostics have been installed
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.RegisterAppSessionStartInDatabase">
            <summary>
            Method to register app startup in ETSsession database table
            You can override this to do nothing if you really don't want database connections in your app
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.LoadTimezoneInformation">
            <summary>
            Load Timezone information from the database. Call if you need it.
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.DaemonNamespace">
            <summary>
            Daemon namespace e.g. PROD or sd83910_dev
            </summary>
            <returns>Namespace string</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.LogicalNameAndNamespace">
            <summary>
            Return logicalName And Namespace concatenated e.g. SpotPricePublisher_PROD
            </summary>
            <returns>Concatenated logicalName And namespace</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.DaemonLogicalName">
            <summary>
            Logical name for this daemon. Override this.
            </summary>
            <returns>Daemon logical name</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.ReadCommandParameters">
            <summary>
            Implementation from ICommandParameterReader
            </summary>
            <returns>Command parameter list</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.ReadCommandParametersFromRegistry">
            <summary>
            Read command parameters from registry using the Daemon logical name to locate the parameters
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.ReadArgsFromRegistry">
            <summary>
            Reads the command arguments from the registry, providing the registry branch to read.
              A more consistent name for this function (w.r.t. the class) would be the one above.
              However it is already used so all references need to be removed prior to refactoring.
            </summary>
            <returns>Command parameter list</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.GetShutdownRoutine">
            <summary>
            Get shutdown routine to call when the service is stopped
            </summary>
            <returns>Shutdown Routine function</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.WriteStartupBanner">
            <summary>
            Write simple startup information out to Diagnostics
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.EQTGDaemonProcess.StopProcessing">
            <summary>
            Stop any further processing. Picked up in worker thread
            </summary>
        </member>
        <member name="F:EQTG.Daemons.Daemon.EQTGDaemonProcess.myDbAppSession">
            <summary>
            Storage for DB App Session, that controls entries into ETSsession to indcate application start and stop
            </summary>
        </member>
        <member name="F:EQTG.Daemons.Daemon.EQTGDaemonProcess.myDbDetails">
            <summary>
            Storage of database connection details parsed from standard parameters from registry
            </summary>
        </member>
        <member name="F:EQTG.Daemons.Daemon.EQTGDaemonProcess.OurDiagnostics">
            <summary>
             Class diagnostics
            </summary>
        </member>
        <member name="F:EQTG.Daemons.Daemon.EQTGDaemonProcess.StopProcessingDiagnostics">
            <summary>
            Extra behaviour diagnostics
            </summary>
        </member>
        <member name="P:EQTG.Daemons.Daemon.EQTGDaemonProcess.DBConnectionDetails">
            <summary>
            Connection details property
            </summary>
        </member>
        <member name="P:EQTG.Daemons.Daemon.EQTGDaemonProcess.DBAppSession">
            <summary>
            Access to database app session
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.LaunchApplication(System.String,System.String,System.Object,EQTG.Daemons.Daemon.ServiceOrConsoleApp.ApplicationLaunchRoutine)">
            <summary>
            Call this routine from main(). Will run as a service or as a console specified by -asWin32Console
            </summary>
            <param name="friendlyName">Display name for this daemon</param>
            <param name="logicalName">Logical (SCM registered) name of this daemon</param>
            <param name="daemonInstance">Instance of the daemon to ensure it doesn't get garbage collected</param>
            <param name="launchRoutine">Function to create you new Daemon instance and kick off a processing thread</param>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.GetEventLog">
            <summary>
            EQTG - return event log for usage in event log diagnostics
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.OnConsoleEvent(EQTG.General.Application.ConsoleEvent)">
            <summary>
            Shutdown (Ctrl C, Ctrl Brk) handler
            </summary>
            <param name="ev">Console Event</param>
            <returns>Whether the event was handled</returns>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.OnStart(System.String[])">
            <summary>
            SCM Invoked method : Set things in motion so your service can do its work.
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.OnStop">
            <summary>
            SCM Invoked shutdown method : Stop this service.
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.GracefulShutdown">
            <summary>
            Graceful shutdown - either the service has been externally stopped or there is a ctrl-c/ctrl-brk
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.ShutdownServiceOrConsoleImmediately">
            <summary>
            Forced shutdown as a result of a thread crashing or some other event
            </summary>
        </member>
        <member name="M:EQTG.Daemons.Daemon.ServiceOrConsoleApp.WriteLaunchCrashLog(System.Exception)">
            <summary>
            Method to record the failure of the launch
            </summary>
            <param name="e">Exception that was thrown</param>
        </member>
        <member name="F:EQTG.Daemons.Daemon.ServiceOrConsoleApp.OurDiagnostics">
            <summary>
            Standard class diagnostics
            </summary>
        </member>
        <member name="F:EQTG.Daemons.Daemon.ServiceOrConsoleApp.ourRunningAsConsole">
            <summary>
            Indicator for whether we are running as a console or service
            </summary>
        </member>
        <member name="F:EQTG.Daemons.Daemon.ServiceOrConsoleApp.ourConsoleShutdown">
            <summary>
            Control over lifetime of console
            </summary>
        </member>
        <member name="T:EQTG.Database.BackgroundQueries.BackgroundExecutor">
            <summary>
            Execute database queries in the background.
            </summary>
            <remarks>
            <para>Doesn't use the WorkerThreadQueue since we want to allow throttling support.</para>
            <para>Derives from EventThrottleProcessor to allow EventThrottle processing.</para>
            <para>Functionality supported:</para>
            <list type="bullet">
            	<item>
            		<description>Execution of database queries in a background thread</description>
            	</item>
            	<item>
            		<description>Maximum number of queries executed per second</description>
            	</item>
            	<item>
            		<description>Flushing (or not) of queries backed up when asked to shutdown</description>
            	</item>
            	<item>
            		<description>Max number of retries when trying to execute database queries (default 3)</description>
            	</item>
            	<item>
            		<description>Reconnection when a database connection is dropped</description>
            	</item>
            	<item>
            		<description>Dropping the database connection if it is unused for a specified period</description>
            	</item>
            	<item>
            		<description>Notifies anyone interested when a query has absolutely failed</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:EQTG.General.Process.EventThrottleProcessor">
            <summary>
            Interface to hook into the EventThrottle
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottleProcessor.ProcessEventThrottleEvents(System.Int32)">
            <summary>
            Process up to the maximum number of events allowed
            </summary>
            <param name="maxEvents">Maximum events that can be processed</param>
            <returns>Number of events actually processed</returns>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.#ctor(EQTG.Database.DBConnectionDetails,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.BackgroundQueries.BackgroundExecutor"/> class.
            </summary>
            <param name="connectionDetails">Connection details</param>
            <param name="eventsPerSecondLimit">Maximum number of queries to save back to the database per second</param>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.Start">
            <summary>
            Start processing queries
            </summary>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.Stop(System.Boolean)">
            <summary>
            Stop processing events
            </summary>
            <param name="flush">True if the backed up queries should be flushed first</param>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.Enqueue(EQTG.Database.BackgroundQueries.SQLRequest)">
            <summary>
            Queue SQL you wish to execute using this function
            </summary>
            <returns>True if the SQL was successfully enqueued</returns>
            <param name="sqlRequest">SQL to process at a later time</param>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.ProcessEventThrottleEvents(System.Int32)">
            <summary>
            Event throttle callback function interface implementation
            Only public to satisfy callback restrictions on access
            </summary>
            <param name="maxEvents">Maximum noumber </param>
            <returns>Number of queries actually processed</returns>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.ProcessQueuedQueries(System.Int32,System.Boolean)">
            <summary>
            Process all queries currently on the queue
            </summary>
            <returns>Number of queries processed</returns>
            <param name="maxQueriesToProcess">Max queries to process or -1 to do everything</param>
            <param name="flushQueue">Flags if we want to flush the queue</param>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.ExtractQueriesToProcess(System.Int32)">
            <summary>
            Extract queries we want to process, removing them from the queue
            </summary>
            <param name="maxQueriesToProcess">Max queries to process or -1 to do everything</param>
            <returns>List of queries to process</returns>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.ProcessDequeuedItems(System.Collections.ArrayList)">
            <summary>
            Execute all the queries we have been asked to
            </summary>
            <param name="dequeuedItems">List of dequeued items</param>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.BackgroundExecutor.ExecuteIndividualQuery(EQTG.Database.BackgroundQueries.SQLRequest)">
            <summary>
            Perform best attempt to execute the supplied query up to MaxRetries times
            </summary>
            <param name="sql">SQL to execute</param>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myNotProcessingDequeuedItemsEvent">
            <summary>
            Manual Reset Event to signal from our standard processing code to the Stop method
            that we have finished processing queries
            Set to Signalled initially, since the timer processing sets it to Unsignalled during processing
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myBlockNewRequestsAfterStop">
            <summary>
            Flag to prevent clients queueing requests in the queue after we have been
            asked to stop
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myActiveConnection">
            <summary>
            DB connection storage
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myConnectionDetails">
            <summary>
            DB Connection details so we can reconnect if required.
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myLastQueryTime">
            <summary>
            Last time a query was executed so we can determine if we should drop the connection
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myQueryQueue">
            <summary>
            Queue of queries to execute
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myMaxRetries">
            <summary>
            Number of times to try executing a query
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myEventThrottle">
            <summary>
            Throttle for processing queued queries.
            Created once in constructor and always stays there.
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.myDropUnusedConnectionTimeout">
            <summary>
            Period before an unused connection should be dropped in seconds
            </summary>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.BackgroundExecutor.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="E:EQTG.Database.BackgroundQueries.BackgroundExecutor.OnFailedQuery">
            <summary>
            Event to trigger when some SQL has failed.
            </summary>
        </member>
        <member name="P:EQTG.Database.BackgroundQueries.BackgroundExecutor.MaxRetries">
            <summary>
            Gets or sets the maximum number of times to attempt a query.
            </summary>
            <remarks>
            Cases will be a Timeout, or a connection being axed by deadlock monitor 
            or Server bounce, or some bad SQL!
            Default is 3.
            </remarks>
        </member>
        <member name="P:EQTG.Database.BackgroundQueries.BackgroundExecutor.DropUnusedConnectionTimeout">
            <summary>
            Gets or sets the period in seconds before unused connections will be dropped.
            </summary>
        </member>
        <member name="P:EQTG.Database.BackgroundQueries.BackgroundExecutor.QueryProcessingEventThrottle">
            <summary>
            Gets the throttle for processing queued queries.
            </summary>
            <remarks>
            Exposed to allow modification of long/short intervals (not thread safe at time of writing).
            Only takes effect before starting the processing.
            </remarks>
        </member>
        <member name="P:EQTG.Database.BackgroundQueries.BackgroundExecutor.Connection">
            <summary>
            Connection property - actually gets connection of required
            </summary>
        </member>
        <member name="T:EQTG.Database.BackgroundQueries.BackgroundExecutor.FailedQueryHandler">
            <summary>
            Callback handler for when some SQL has failed.
            </summary>
        </member>
        <member name="T:EQTG.Database.BackgroundQueries.SQLRequest">
            <summary>
            Lightweight holder for SQL that can be executed by e.g.
            a BackgroundExecutor
            </summary>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.SQLRequest.#ctor">
            <summary>
            Blank c'tor
            </summary>
        </member>
        <member name="M:EQTG.Database.BackgroundQueries.SQLRequest.#ctor(System.String)">
            <summary>
            C'tor including SQL to process
            </summary>
            <param name="sql"></param>
        </member>
        <member name="F:EQTG.Database.BackgroundQueries.SQLRequest.mySql">
            <summary>
            SQL storage
            </summary>
        </member>
        <member name="P:EQTG.Database.BackgroundQueries.SQLRequest.SQL">
            <summary>
            SQL to process
            </summary>
        </member>
        <member name="T:EQTG.Database.BcpFileResultSet">
            <summary>
            Summary description for BcpFileResultSet.
            </summary>
        </member>
        <member name="T:EQTG.Database.ConnectionPool">
            <summary>
            The connection pool lets routines reuse connections to the same datasource. A client takes the conenction
            out of the pool and gives it back afterwards (make sure this is done or you'll lose the connection)
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ApplicationServer.IApplicationComponent">
            <summary>
            ApplicationComponents live in a container application (that implements the IApplicationServiceProvider
            interface). By implementing IApplicationComponent objects get access to the services provided
            by the application container.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.ApplicationServer.IApplicationComponent.Status">
            <summary>
            Components must provide a status string when requested
            </summary>
        </member>
        <member name="P:EQTG.General.Application.ApplicationServer.IApplicationComponent.Name">
            <summary>
            Application components must return a unique name across the application
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Application.ApplicationServer.IApplicationComponent.ServiceProvider">
            <summary>
            Components must take delivery of their service provider
            </summary>
        </member>
        <member name="F:EQTG.Database.ConnectionPool.ConnectionPoolName">
            <summary>
            GLoabl name of this component
            </summary>
        </member>
        <member name="F:EQTG.Database.ConnectionPool.myDatabaseConnections">
            <summary>
            Hash of database connection string to database connection objects
            </summary>
        </member>
        <member name="F:EQTG.Database.ConnectionPool.myNamedConnectionStrings">
            <summary>
            Hash of friendly names that map to connection strings
            </summary>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.#ctor">
            <summary>
            Ctor
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.AcquireConnection(System.String)">
            <summary>
            Lookup a connection for the given connectionString (create a new one if not found)
            The pool works best if you don't pass in passwords in the connection string
            and connection strings should always be used in the same format by an application
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.ReleaseConnection(EQTG.Database.DBConnection)">
            <summary>
            Call this to return a connection to the connection pool
            </summary>
            <param name="connection"></param>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.CloseCachedDBConnections">
            <summary>
            Close all currently cached DBConnections that are not acquired
            </summary>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.LookupNamedConnectionString(System.String)">
            <summary>
            Lookup a connection string by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.AddNamedConnectionString(System.String,System.String)">
            <summary>
            Add a named connection string to the hash
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.DatabaseConnectionStringCommand(EQTG.General.Application.AppCommandLineProcessor,System.Object[])">
            <summary>
            App command to associate a user name with a connection string
            </summary>
            <param name="context"></param>
            <param name="args"></param>
        </member>
        <member name="M:EQTG.Database.ConnectionPool.ShowConnectionStringsCommand(EQTG.General.Application.AppCommandLineProcessor,System.Object[])">
            <summary>
            App command to associate a user name with a connection string
            </summary>
            <param name="context"></param>
            <param name="args"></param>
        </member>
        <member name="P:EQTG.Database.ConnectionPool.Status">
            <summary>
            Implement IApplicationComponent
            </summary>
        </member>
        <member name="P:EQTG.Database.ConnectionPool.Name">
            <summary>
            Application components must return a unique name across the application
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.Database.ConnectionPool.ServiceProvider">
            <summary>
            Components must take delivery of their service provider
            </summary>
        </member>
        <member name="T:EQTG.Database.DBConnection">
            <summary>
            Helper class to store connections and their connection strings
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnection.Connection">
            <summary>
            Connection object
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnection.ConnectionString">
            <summary>
            Connection String for connectionObject
            </summary>
        </member>
        <member name="T:EQTG.Database.DateList">
            <summary>
            Manages the temporary table #dateList which is used by a number of stored procedures
            </summary>
        </member>
        <member name="T:EQTG.Database.TemporaryTable">
            <summary>
            Base class for classes that manage temporary tables
            
            As a minimum you will need to have a derived class constructor
            and an override of the ColumnDefinitions property
            </summary>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.#ctor(System.Data.IDbConnection,System.String)">
            <summary>
            Protected constructor - derived class will need to supply the table name
            </summary>
            <param name="db">Database connection</param>
            <param name="tableName">Name of the table</param>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.Create">
            <summary>
            Creates and indexes the temporary table
            </summary>
            <returns>true if the table was just created, or false if it already existed</returns>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.CreateTempTable">
            <summary>
            Create the Temporary table from the ColumnDefinitions
            </summary>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.DropTempTable">
            <summary>
            Drop the table if it exists
            </summary>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.AddRow(System.String)">
            <summary>
            Helper to add rows into the table
            </summary>
            <param name="values">Values to add to the table</param>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.Dispose">
            <summary>
            This implements the disposable pattern, and therefore allows you to determine the time
            the connection is dropped.
            </summary>
        </member>
        <member name="M:EQTG.Database.TemporaryTable.DropTemporaryTable(System.Data.IDbConnection,System.String)">
            <summary>
            Drop a temporary table
            </summary>
            <param name="dbConnection">Connection to use</param>
            <param name="tableName">Name of the temporary table to drop</param>
            <remarks>
            This is not the preferred method for removing Temporary Tables. This object should be used instead.
            However, if a Temporary Table is created outside of the scope of this state-based object, this method
            provides some checks to ensure that the table being dropped is a Temporary Table.
            </remarks>
        </member>
        <member name="F:EQTG.Database.TemporaryTable.myConnection">
            <summary>
            Database connection storage
            </summary>
        </member>
        <member name="F:EQTG.Database.TemporaryTable.myTableCreated">
            <summary>
            Marker for whether the table has been created
            </summary>
        </member>
        <member name="F:EQTG.Database.TemporaryTable.myTableName">
            <summary>
            Name of the table
            </summary>
        </member>
        <member name="P:EQTG.Database.TemporaryTable.TableName">
            <summary>
            Table Name property
            </summary>
        </member>
        <member name="P:EQTG.Database.TemporaryTable.ColumnDefinitions">
            <summary>
            Abstract functiom to define the columns in the new table. Must include the round brackets
            </summary>
        </member>
        <member name="P:EQTG.Database.TemporaryTable.Connection">
            <summary>
            Access to database connection for loading code
            </summary>
        </member>
        <member name="P:EQTG.Database.TemporaryTable.Created">
            <summary>
            Gets or sets a flag indicating whether the temporary database table has been created
            </summary>
        </member>
        <member name="T:EQTG.Database.DBBatchCommand">
            <summary>
            Bundles together several SQL statements and executes them in one go
            </summary>
            <example><code>
            using (IDBBatchCommand batch = new DBBatchCommand (conn))
            {
            	for (int i = 0; i &lt; 100; ++i)
            	{
            		// Actual submission may occur occasionally on this statement
            		batch.ExecuteNonQuery ("update someTable set someColumn = 'new value' where someOtherColumn = " + i);	
            	}//for
            // Final submission occurs on dispose
            }//using
            </code></example>
        </member>
        <member name="F:EQTG.Database.DBBatchCommand.DefaultBatchSize">
            <summary>
            Maximum number of commands to include in each batch by default.
            </summary>
        </member>
        <member name="M:EQTG.Database.DBBatchCommand.#ctor(System.Data.IDbConnection)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.DBBatchCommand"/> class.
            </summary>
            <remarks>
            Defaults to <see cref="F:EQTG.Database.DBBatchCommand.DefaultBatchSize"/> commands per batch.
            </remarks>
            <param name="conn">The database connection you want to use</param>
        </member>
        <member name="M:EQTG.Database.DBBatchCommand.#ctor(System.Data.IDbConnection,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.DBBatchCommand"/> class.
            </summary>
            <param name="conn">The database connection you want to use</param>
            <param name="bufferLimit">The maximum size of the buffer to use to hold the commands</param>
        </member>
        <member name="M:EQTG.Database.DBBatchCommand.#ctor(System.Data.IDbTransaction)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.DBBatchCommand"/> class.
            </summary>
            <remarks>
            Defaults to <see cref="F:EQTG.Database.DBBatchCommand.DefaultBatchSize"/> commands per batch.
            </remarks>
            <param name="conn">The database transcation you want to use</param>
        </member>
        <member name="M:EQTG.Database.DBBatchCommand.#ctor(System.Data.IDbTransaction,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.DBBatchCommand"/> class.
            </summary>
            <param name="conn">The database transaction you want to use</param>
            <param name="bufferLimit">The maximum size of the buffer to use to hold the commands</param>
        </member>
        <member name="M:EQTG.Database.DBBatchCommand.ExecuteNonQuery(System.String)">
            <summary>
            Submits a query, which may not be executed immediately
            </summary>
            <param name="sql">The query</param>
        </member>
        <member name="M:EQTG.Database.DBBatchCommand.SubmitNow">
            <summary>
            Submit any queries that are pending
            </summary>
        </member>
        <member name="T:EQTG.Database.DBConnectionDetails">
            <summary>
            Holds details necessary to create a database connection.
            Includes static utilities to create from a CommandParameterList and to create a ConnectionString
            </summary>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.#ctor">
            <summary>
            Blank constructor
            </summary>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.#ctor(System.String,System.String,System.String,System.String,System.String,EQTG.Database.DBProvider)">
            <summary>
            Complete constructor
            </summary>
            <param name="server">Database server</param>
            <param name="login">Database login id</param>
            <param name="password">Database password</param>
            <param name="database">Database on server to use (can be blank)</param>
            <param name="applicationName">Name of this application to register</param>
            <param name="provider">Provider that will create connections</param>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.#ctor(System.String,System.Int32,System.String,System.String,System.String,System.String,EQTG.Database.DBProvider)">
            <summary>
            Complete constructor
            </summary>
            <param name="server">Database server host name or ip address.</param>
            <param name="port">The port the database server is listening on</param>
            <param name="login">Database login id</param>
            <param name="password">Database password</param>
            <param name="database">Database on server to use (can be blank)</param>
            <param name="applicationName">Name of this application to register</param>
            <param name="provider">Provider that will create connections</param>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Server">
            <summary>
            Server name access
            </summary>
            <returns>Server name</returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Login">
            <summary>
            Login access
            </summary>
            <returns>Login id</returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Password">
            <summary>
            User password
            </summary>
            <returns>User password</returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Database">
            <summary>
            Database on server to use
            </summary>
            <returns>Database to use</returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Provider">
            <summary>
            returns an enum for whether connection is via ODBC or SqlServer factory
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.LogDetails">
            <summary>
            Log details of this ConnectionDetails to diagnostics
            </summary>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.ConnectionString">
            <summary>
            Create a connection string from this details
            </summary>
            <returns>Connection string</returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.ConnectionString(EQTG.Database.DBConnectionDetails)">
            <summary>
            Create a connection string from the details
            </summary>
            <param name="dbDetails">Database details</param>
            <returns>Connection string</returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Create(EQTG.General.Application.CommandParameterList)">
            <summary>
            Creates a <see cref="T:EQTG.Database.DBConnectionDetails"/> object, obtaining missing parameters (e.g. login and password)
            automatically where available
            </summary>
            <param name="commandParameters">Command parameter list for database parameters</param>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Create(EQTG.General.Application.CommandParameterList,System.String,System.String,System.String,System.String,System.String,EQTG.Database.DBProvider)">
            <summary>
            Creates a <see cref="T:EQTG.Database.DBConnectionDetails"/> object, obtaining missing parameters (e.g. login and password)
            automatically where available
            </summary>
            <param name="commandParameters">Command parameter list for auto-logon, or null to use the default</param>
            <param name="server">Database server name</param>
            <param name="login">User login ID, or null/empty string for auto-logon through SECuserPasswords</param>
            <param name="password">Password, or null/empty string for auto-logon through encrypt.txt</param>
            <param name="database">Initial database, or null/empty string for default</param>
            <param name="applicationName">Application name, or null/empty string for default</param>
            <param name="provider">Database provider type</param>
            <returns><see cref="T:EQTG.Database.DBConnectionDetails"/></returns>
            <exception cref="T:System.ArgumentException">If server is null or empty</exception>
            <exception cref="T:System.ApplicationException">If auto-logon fails</exception>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.Create(EQTG.General.Application.CommandParameterList,System.String,System.Int32,System.String,System.String,System.String,System.String,EQTG.Database.DBProvider)">
            <summary>
            Creates a DBConnectionDetails object, obtaining missing parameters (e.g. login and password)
            automatically where available
            </summary>
            <param name="commandParameters">Command parameter list for auto-logon, or null to use the default</param>
            <param name="server">Database server name or ip address</param>
            <param name="port">Port number</param>
            <param name="login">User login ID, or null/empty string for auto-logon through SECuserPasswords</param>
            <param name="password">Password, or null/empty string for auto-logon through encrypt.txt</param>
            <param name="database">Initial database, or null/empty string for default</param>
            <param name="applicationName">Application name, or null/empty string for default</param>
            <param name="provider">Database provider type</param>
            <returns>DBConnectionDetails object</returns>
            <exception cref="T:System.ArgumentException">If server is null or empty</exception>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.CreateFromCommandParametersAndNTUser(EQTG.General.Application.CommandParameterList)">
            <summary>
            Creates a DB connection using a list of configuration parameters
            </summary>
            <param name="commandParamaters">The parameters for the program (from commandline, registry etc)</param>
            <returns><see cref="T:EQTG.Database.DBConnectionDetails"/></returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.CreateFromCommandParametersAndNTUser(EQTG.General.Application.CommandParameterList,System.String@)">
            <summary>
            Creates a DB connection given configuration parameters, attempts to authenticate the connection (unless overrideValue dictates that a manual authentication
            is necessary)
            </summary>
            <param name="commandParamaters">The parameters for the program (from commandline, registry etc)</param>
            <param name="overrideValue">Changes the options available for obtaining login information; ie whether a login dialog should be displayed</param>
            <returns><see cref="T:EQTG.Database.DBConnectionDetails"/></returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.CreateFromConnectionAndNTUser(EQTG.Database.DBConnectionDetails,System.String@)">
            <summary>
            Accepts a DB connection object, if it's not already authenticated this allows an interactive program to prompt the user for authentication details
            </summary>
            <param name="DBConnectionDetails">connected (or authentication outstanding) DB session</param>
            <param name="overrideValue">Changes the options available for obtaining login information; ie whether the username can be changed</param>
            <returns><see cref="T:EQTG.Database.DBConnectionDetails"/></returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.CreateFromCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Create new connection details from command parameters.
            </summary>
            <param name="commandLine">Command line (source from e.g. command line/registry)</param>
            <returns><see cref="T:EQTG.Database.DBConnectionDetails"/></returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.RegisterDatabaseParametersInUsage(EQTG.General.Application.UsageParameters)">
            <summary>
            Register the 3 default database parameters in a usage instance as mandatory arguments
            </summary>
            <param name="usageParameters">Usage parameters instance to add to</param>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.GetProvider(System.String)">
            <summary>
            Converts a provider name into a <see cref="T:EQTG.Database.DBProvider"/> value.
            </summary>
            <param name="providerstr">Name of a database provider.</param>
            <returns><see cref="T:EQTG.Database.DBProvider"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="providerstr"/> is not
            SYBASE, ODBC, SQLSERVER, CTLib or blank.</exception>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.CreateFromCommandParameters(EQTG.General.Application.CommandParameterList,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection details from command parameters.
            </summary>
            <param name="commandParamaters">Command line (source from e.g. command line/registry)</param>
            <param name="serverArgName">Name of the server argument, e.g. S</param>
            <param name="userArgName">Name of the user argument, e.g. U</param>
            <param name="passwordArgName">Name of the password argument, e.g. P</param>
            <param name="databaseArgName">Name of the database argument, e.g. D</param>
            <param name="providerArgName">Name of the provider argument, e.g. provider</param>
            <returns><see cref="T:EQTG.Database.DBConnectionDetails"/></returns>
        </member>
        <member name="M:EQTG.Database.DBConnectionDetails.CreateConnection">
            <summary>
            Creates a DB connection using the prescribed DB Factory.
            </summary>
            <returns>A connection to the DB.</returns>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myPacketSize">
            <summary>
            Packet Size
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.mySelectMethod">
            <summary>
            ODBC Select Method. (0 - Cursor, 1 - Direct)
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myServer">
            <summary>
            Server string storage
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myPort">
            <summary>
            Port number of the server
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myLogin">
            <summary>
            Login storage
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myPassword">
            <summary>
            Password storage
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myDatabase">
            <summary>
            Database on server to use
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myApplicationName">
            <summary>
            Application name storage
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.myProvider">
            <summary>
            enum for picking a sybaseodbc/mssql
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.ourDefaultApplicationName">
            <summary>
            Default application name.
            Set the first time a valid application name is supplied
            </summary>
        </member>
        <member name="F:EQTG.Database.DBConnectionDetails.ourDiagnostics">
            <summary>
            Member class diagnostics
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.ApplicationName">
            <summary>
            Gets or sets the applciation name to register on database server
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.DatabaseName">
            <summary>
            Gets or sets the name of the initial database
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.IsDev">
            <summary>
            Gets a value indicating whether this is a development database
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.IsProduction">
            <summary>
            Gets a value indicating whether this is a production database (i.e. not UA and not DEV)
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.IsUA">
            <summary>
            Gets a value indicating whether this is a UA database
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.LoginName">
            <summary>
            Gets or sets the login ID
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.PacketSize">
            <summary>
            Gets or sets the packet size for ODBC connections
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.PasswordValue">
            <summary>
            Gets or sets the login password
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.ProviderType">
            <summary>
            Gets or sets the provider that will create connections
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.ServerName">
            <summary>
            Gets or sets the name of the server
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.PortNumber">
            <summary>
            Gets or sets the port number
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.SelectMethod">
            <summary>
            Gets or sets Select Method. 0 - Cursor, 1 - Direct (default 1)
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.Factory">
            <summary>
            Gets the <see cref="T:EQTG.Database.IDbFactory"/> appropriate to the <see cref="P:EQTG.Database.DBConnectionDetails.ProviderType"/>
            </summary>
        </member>
        <member name="P:EQTG.Database.DBConnectionDetails.DefaultApplicationName">
            <summary>
            Gets or sets the default application name.
            </summary>
            <remarks>
            <para>This property controls how the application's name appears in the database, in, for example,
            sp_who. Set the first time a valid application name is supplied.</para>
            <para>You can set the application name used on a particular connection by setting
            <see cref="P:EQTG.Database.DBConnectionDetails.ApplicationName"/>.</para>
            <note>In an ASP.NET application, set the value of this property before creating 
            a database connection, or the string "UnknownApplication" will be used instead.</note>
            </remarks>
        </member>
        <member name="T:EQTG.Database.DBProvider">
            <summary>
            Defines database connection providers used by <see cref="P:EQTG.Database.DBConnectionDetails.ProviderType"/>.
            </summary>
        </member>
        <member name="F:EQTG.Database.DBProvider.Odbc">
            <summary>
            Use <see cref="T:System.Data.Odbc.OdbcConnection"/>.
            </summary>
        </member>
        <member name="F:EQTG.Database.DBProvider.SqlServer">
            <summary>
            Use <see cref="T:System.Data.SqlClient.SqlConnection"/>.
            </summary>
        </member>
        <member name="F:EQTG.Database.DBProvider.Sybase">
            <summary>
            Use the Sybase ADO.NET driver.
            This was downgraded to Odbc in CL 92612.
            </summary>
        </member>
        <member name="F:EQTG.Database.DBProvider.SybaseADO">
            <summary>
            Use the Sybase ADO.NET driver.
            </summary>
        </member>
        <member name="T:EQTG.Database.DBReflectedCollection">
            <summary>
            Uses reflection to read object properties and implicity map to a database table.
            </summary>
        </member>
        <member name="F:EQTG.Database.DBReflectedCollection.myPrototype">
            <summary>
            This is the type of object that we are reflecting from the database
            </summary>
        </member>
        <member name="F:EQTG.Database.DBReflectedCollection.myTableName">
            <summary>
            This is the name of the database table that we are going to read and write to
            </summary>
        </member>
        <member name="F:EQTG.Database.DBReflectedCollection.myWhereClause">
            <summary>
            If a where clause was specified at creation this is kept here
            </summary>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.CopyFromReader(System.Object,System.Data.IDataReader)">
            <summary>
            Copies the properties from a reader to a object that already exists
            </summary>
            <param name="result"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.BuildFromReader(System.Type,System.Data.IDataReader)">
             <summary>
             Creates a new object of type prototype and reads the next row from reader. The fields in
             reader are assumed to be in one to one correspondance with the Properties in prototype - the
             fields are also assumed to be in the same order (use SelectAll to obtain such a field list).
            
             NULL values may be passed into property set methods that have type object. If a column can
             contain a NULL value then make the C# property an object type and check for System.DBNull -
             otherwise cast to the correct real type.
             </summary>
             <param name="prototype"></param>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.BuildManyFromReader(System.Type,System.Data.IDataReader)">
             <summary>
             Creates an ArrayList of new object of type prototype by reading all the rows in the datareader.
            
             NULL values may be passed into property set methods that have type object. If a column can
             contain a NULL value then make the C# property an object type and check for System.DBNull -
             otherwise cast to the correct real type.
             </summary>
             <param name="prototype"></param>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.SelectAll(System.Type,System.String)">
            <summary>
            Returns a string of SQL that will select all objects from tableName in such a way that the
            columns returned are in the same order as the Properties in prototype when the Properties
            colelction is enumerated.
            </summary>
            <param name="prototype"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.ColumnList(System.Type)">
            <summary>
            Returns a SQL style column list based on the properties in the prototype we are given
            </summary>
            <param name="prototype"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.ColumnValuesWhereClause(System.Object)">
            <summary>
            Returns a string based on the given object that looks like
            	"prop1 = prop1 AND prop2 = prop2 AND ..."
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.ColumnValuesWhereClause(System.Object,System.String)">
            <summary>
            Returns a string based on the given object that looks like
            	"prop1 = prop1 AND prop2 = prop2 AND ..."
            but only for the values specified in the keys list
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.ColumnValuesCommaSeparated(System.Object)">
            <summary>
            Returns a string of comma separated values for use in an insert clause
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.ColumnValuesUpdateClause(System.Object)">
            <summary>
            Returns a string based on the given object that looks like
            	"prop1 = prop1, prop2 = prop2, ..."
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.PropertyValueAsSQLString(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Takes an object and formats it so that we can put it in an SQL statement.
            
            e.g. a string "The strings' values" becomes "'The strings'' value'"
            
            </summary>
            <param name="property"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.#ctor(System.Type,System.Data.IDbConnection,System.String)">
            <summary>
            Connects to the database and populates a collection with all the objects of type prototype
            found in the table tableName.
            </summary>
            <param name="prototype"></param>
            <param name="connection"></param>
            <param name="tableName"></param>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.#ctor(System.Type,System.Data.IDbConnection,System.String,System.String)">
            <summary>
            Connects to the database and populates a collection with all the objects of type prototype
            found in the table tableName. The whereClause allows you to restrict the objects that are read in
            </summary>
            <param name="prototype"></param>
            <param name="connection"></param>
            <param name="tableName"></param>
            <param name="whereClause"></param>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.WriteToDB(System.Data.IDbConnection)">
            <summary>
            Simple method for writing our objects to the database. This can fail if there is an index on the table and a row
            has been updated without the change being copied into memory
            </summary>
            <param name="connection">We assume this is open to start with</param>
            <returns>Number of rows affected</returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollection.WriteToDBIndexed(System.Data.IDbConnection,System.String)">
            <summary>
            Simple method for writing our objects to the database. It takes a comma separated list of key fields used
            to identify each object.
            </summary>
            <param name="connection">We assume this is open to start with</param>
            <returns>Number of rows affected</returns>
        </member>
        <member name="T:EQTG.Database.DBReflectedCollectionWithLookup">
            <summary>
            A DBCollection that allows object lookup by any column name/property.
            </summary>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.Add(System.Object)">
            <summary>
            Make sure we add to our lookup hashes when we add elements
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.Remove(System.Object)">
            <summary>
            Make sure that we maintain our hash lookup when an object is removed
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.#ctor(System.Type,System.Data.IDbConnection,System.String)">
            <summary>
            Construct a DBReflectedCollection and create hash lookups for all properties found in
            prototype.
            </summary>
            <param name="prototype"></param>
            <param name="connection">We assume this is already open</param>
            <param name="tableName"></param>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.#ctor(System.Type,System.Data.IDbConnection,System.String,System.String)">
            <summary>
            Construct a DBReflectedCollection and create hash lookups for all properties found in
            prototype. The whereClause lets the user restrict the objects that are read in
            </summary>
            <param name="prototype"></param>
            <param name="connection">We assume this is already open</param>
            <param name="tableName"></param>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.Lookup(System.String,System.String)">
            <summary>
            Looks up an object read from the database by any of the column names/properties in the 
            </summary>
            <param name="lookupKey"></param>
            <param name="lookupValue"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.LookupByMultipleKeys(System.Collections.Hashtable)">
            <summary>
            Looks up a value in the collection by multiple keys
            
            TODO This is inefficient sort it out if it becomes an issue
            </summary>
            <param name="keyToValue"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBReflectedCollectionWithLookup.Init">
            <summary>
            Setup the lookup Hash from the prototype so that when the container is empty we don't throw unknown lookupKey exceptions
            </summary>
        </member>
        <member name="T:EQTG.Database.DBSelector">
            <summary>
            Access point to DB factory. Currently set up for ODBC, but may change later
            </summary>
        </member>
        <member name="F:EQTG.Database.DBSelector.ourFactory">
            <summary>
            Static factory instance
            </summary>
        </member>
        <member name="P:EQTG.Database.DBSelector.Factory">
            <summary>
            Factory property
            </summary>
        </member>
        <member name="T:EQTG.Database.DBShortCodeAttribute">
            <summary>
            Specifies a short code for an enum member that will be used when writing to a database table.
            Mappings are provided to and from the short code.
            </summary>
            <example>
            <code>
            </code>
            </example>
            <remarks>
            Short codes are often used in the database, but mapped in code to enum values. This Attribute
            allows this process to be simplified by allowing the developer to use Metadata to define these
            codes. A common set of routines can then be used to map to and from the short codes.
            </remarks>
        </member>
        <member name="M:EQTG.Database.DBShortCodeAttribute.#ctor(System.String)">
            <summary>
            Initialises a new instance of the DBShortCodeAttribute class with the specified Short Code
            </summary>
            <param name="shortCode">Short code to associate with the enum member.</param>
        </member>
        <member name="M:EQTG.Database.DBShortCodeAttribute.GetShortCode(System.Object)">
            <summary>
            Retrieves the Database Short Code for the specified enum member.
            </summary>
            <param name="enumValue">Enum member to return the Database Short Code for.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when the enum value specified does not have a DBShortCode attribute defined.
            </exception>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DBShortCodeAttribute.GetEnumFromShortCode(System.Type,System.String,System.Boolean)">
            <summary>
            Function that takes an enum and a ShortCode, and returns the enum value associated with that ShortCode.
            </summary>
            <param name="shortCodeEnum">Enum containing the ShortCode to search for</param>
            <param name="shortCode">ShortCode to return Enum value for</param>
            <param name="ignoreCase">comparison is not case sensitive</param>/// 
            <exception cref="T:System.ArgumentException">
            Thrown if the ShortCode being searched for is not present in the Enum.
            </exception>
            <returns>
            The Enum value matching the ShortCode.
            </returns>
        </member>
        <member name="M:EQTG.Database.DBShortCodeAttribute.GetEnumFromShortCode(System.Type,System.String)">
            <summary>
            Function that takes an enum and a ShortCode, and returns the enum value associated with that ShortCode.
            </summary>
            <param name="shortCodeEnum">Enum containing the ShortCode to search for</param>
            <param name="shortCode">ShortCode to return Enum value for</param>
            <exception cref="T:System.ArgumentException">
            Thrown if the ShortCode being searched for is not present in the Enum.
            </exception>
            <returns>
            The Enum value matching the ShortCode.
            </returns>
        </member>
        <member name="F:EQTG.Database.DBShortCodeAttribute.myShortCode">
            <summary>
            Member variable storing the ShortCode associated with this Enum value.
            </summary>
        </member>
        <member name="P:EQTG.Database.DBShortCodeAttribute.ShortCode">
            <summary>
            The ShortCode associated with this Enum value.
            </summary>
        </member>
        <member name="T:EQTG.Database.DBSource">
            <summary>
            Class with details and factory
            </summary>
        </member>
        <member name="M:EQTG.Database.DBSource.#ctor">
            <summary>
            Blank C'tor
            </summary>
        </member>
        <member name="M:EQTG.Database.DBSource.#ctor(EQTG.Database.IDbFactory,EQTG.Database.DBConnectionDetails)">
            <summary>
            C'tor allowing setting of members directly
            </summary>
            <param name="factory">IDbFactory to create connections etc.</param>
            <param name="details">Connection details</param>
        </member>
        <member name="M:EQTG.Database.DBSource.Connection">
            <summary>
            Connection construction
            </summary>
            <returns>IDbConnection</returns>
        </member>
        <member name="F:EQTG.Database.DBSource.myConnectionDetails">
            <summary>
            Connection details storage
            </summary>
        </member>
        <member name="F:EQTG.Database.DBSource.myFactory">
            <summary>
            Factory interface storage
            </summary>
        </member>
        <member name="P:EQTG.Database.DBSource.ConnectionDetails">
            <summary>
            Connection details property
            </summary>
        </member>
        <member name="P:EQTG.Database.DBSource.Factory">
            <summary>
            Factory property
            </summary>
        </member>
        <member name="T:EQTG.Network.TelnetShellBase">
            <summary>
            Base class for telnet shells
            </summary>
        </member>
        <member name="T:EQTG.General.Application.AppCommandLineProcessor">
            <summary>
            Defines an interface and default implementations of operations required to process
            a stream of AppCommands.
            </summary>
            <remarks>
            Also implements basic processing features including:
            <list type="bullet">
            	<item>
            		<description>History cache (with command line substitution like !! and !3)</description>
            	</item>
            	<item>
            		<description>Comment stripper (# single line comments)</description>
            	</item>
            	<item>
            		<description>Generic prompt</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/> class.
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.#ctor(EQTG.General.Application.AppCommandLineProcessor)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/> class.
            </summary>
            <param name="parent">Allows us to inherit information from a parent context</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.InitEnvironment">
            <summary>
            Initialises the <see cref="P:EQTG.General.Application.AppCommandLineProcessor.Variables"/> property and sets up default environment variables.
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.Export(System.String)">
            <summary>
            Exports an environment variable.
            </summary>
            <remarks>See <see cref="P:EQTG.General.Application.AppCommandLineProcessor.Variables"/>.<see cref="M:EQTG.General.Application.EnvironmentVariables.Export(System.String)"/>.</remarks>
            <param name="envKey">Variable name</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.Authenticate(System.String@)">
            <summary>
            Work in Progress.
            </summary>
            <param name="userName"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.ReadLine">
            <summary>
            Abstract operation to read a complete line of input containing 0 or 1 complete appCommands
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.Write(System.String)">
            <summary>
            Abstract operation to write prompt and diagnostic information through - useful with context
            sensitive app commands where the output should only go to the user executing the command
            </summary>
            <param name="str">Text to write</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.Write(System.String,System.Object[])">
            <summary>
            Deafult implementation of a formatted write string
            </summary>
            <param name="format">Text to write</param>
            <param name="args">Parameters for format</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.Write(System.Char)">
            <summary>
            Default implementation of write a single character
            </summary>
            <param name="ch">Character to write</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.WriteLine(System.String)">
            <summary>
            Default implementation of write a whole line
            </summary>
            <param name="str">Text to write</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.GetCommand">
            <summary>
            Default implementation for requesting 0 or 1 complete app command
            </summary>
            <returns>Text entered by the user, or null if end of file</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.ProcessCommand(System.String[])">
            <summary>
            Take a command perform history substitution and comment stripping and
            finally execute the command
            </summary>
            <param name="args">Word baseed arguments for command execution</param>
            <returns>Flag to indicate if the caller should try and process more commands</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.WriteHistory">
            <summary>
            Write the history buffer using the WriteLine method
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.SubstituteVariables(System.String)">
            <summary>
            Substitutes environment variables
            </summary>
            <remarks>
            See <see cref="P:EQTG.General.Application.AppCommandLineProcessor.Variables"/>.<see cref="M:EQTG.General.Application.EnvironmentVariables.SubstituteValues(System.String)"/>.
            </remarks>
            <param name="text">Text containing environment variables</param>
            <returns>Text containing values</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogFatalError(System.String)">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="text">Text describing fatal error</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogFatalError(System.String,System.Object[])">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="format">Text describing fatal error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogError(System.String)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogError(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogAndThrowError(System.String)">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogAndThrowError(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogWarning(System.String)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the warning condition</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogWarning(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogInfo(System.String)">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="text">Text describing the informational event</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogInfo(System.String,System.Object[])">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="format">Text describing the informational event</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogDebug(System.String)">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="text">Debug text</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandLineProcessor.LogDebug(System.String,System.Object[])">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="format">Debug text</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="F:EQTG.General.Application.AppCommandLineProcessor.ourDiags">
            <summary>
            Diagnostics for the interface
            </summary>
        </member>
        <member name="F:EQTG.General.Application.AppCommandLineProcessor.myPrompt">
            <summary>
            Used to store a prompt - note if you want to change prompt functionaltiy then update
            the Prompt property accessors not this string
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.Echo">
            <summary>
            A work in progress.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.Prompt">
            <summary>
            The prompt property is accessed after each line is processed so interactive interfaces
            can provide the user with a visual clue that more input will be accepted for
            processing
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.Variables">
            <summary>
            Gets the environment variables.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.Item(System.String)">
            <summary>
            Gets the or sets the value of an environment variable.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.Current">
            <summary>
            Gets or sets the <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/> for this thread.
            </summary>
            <remarks>
            <para>This refers to the current command-line or Telnet shell, or during a call to 
            <see cref="M:EQTG.General.Application.AppCommander.ExecuteFromParameters(EQTG.General.Application.CommandParameterList)"/>, the 'context' parameter.</para>
            
            <para>Set to null if no AppCommandLineProcessor is available to this thread.</para>
            </remarks>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.Parent">
            <summary>
            Used to inherit charactersitics of an enclosing AppCommandLineProcessor
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.CommandLineContinuationString">
            <summary>
            Property used to access the string that denotes command line continuation for
            this processor.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandLineProcessor.CommandHistory">
            <summary>
            Gets the array used to store the command history
            </summary>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.Start">
            <summary>
            Starts the thread which handles this shell
            </summary>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.Stop">
            <summary>
            Requests that the shell's thread exits and waits for it to do so
            </summary>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.ThreadProc">
            <summary>
            Main procedure for thread
            </summary>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogFatalError(System.String)">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="text">Text describing fatal error</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogFatalError(System.String,System.Object[])">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="format">Text describing fatal error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogError(System.String)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogError(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogAndThrowError(System.String)">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogAndThrowError(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogWarning(System.String)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the warning condition</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogWarning(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogInfo(System.String)">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="text">Text describing the informational event</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogInfo(System.String,System.Object[])">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="format">Text describing the informational event</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogDebug(System.String)">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="text">Debug text</param>
        </member>
        <member name="M:EQTG.Network.TelnetShellBase.LogDebug(System.String,System.Object[])">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="format">Debug text</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="P:EQTG.Network.TelnetShellBase.Prompt">
            <summary>
            The prompt property is accessed after each line is processed so interactive interfaces
            can provide the user with a visual clue that more input will be accepted for
            processing
            </summary>
        </member>
        <member name="T:EQTG.Database.DBTransaction">
            <summary>
            Sets uo a transaction which will be rollback on error.
            It is not nestable.
            <B><P>using (DBTrans aTrans = new DBTrans(con))</P>
            <P>{</P>
            <P> ... some sql ...</P>
            <P> if (error) aTrans.Rollback()</P>
            <P> else aTrans.Commit()</P>
            <P>}</P></B>
            </summary>
        </member>
        <member name="M:EQTG.Database.DBTransaction.Commit">
            <summary>
            commits the transaction
            </summary>
        </member>
        <member name="M:EQTG.Database.DBTransaction.Rollback">
            <summary>
            Rollback the transaction
            </summary>
        </member>
        <member name="M:EQTG.Database.DBTransaction.Dispose">
            <summary>
            Causes the transaction to rollback if no commit has been called
            </summary>
        </member>
        <member name="F:EQTG.Database.DBUtil.NoOverrideTimeoutValue">
            <summary>
            Query timeout
            </summary>
        </member>
        <member name="F:EQTG.Database.DBUtil.OurClassDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.Database.DBUtil.setQueryTimeout(System.Int32)">
            <summary>
            Set the query timeout
            <param name="queryTimeout">the query timeout, in seconds</param>
            </summary>
        </member>
        <member name="M:EQTG.Database.DBUtil.unsetQueryTimeout">
            <summary>
            Unset the query timeout
            </summary>
        </member>
        <member name="M:EQTG.Database.DBUtil.OverrideSqlTimeout(System.Data.IDbCommand)">
            <summary>
            To set Command object with the overrided timeout value
            </summary>
            <param name="dbCmd"></param>
        </member>
        <member name="M:EQTG.Database.DBUtil.BuildParameters(System.Data.IDbCommand,System.Object[])">
            <summary>
            Adds an array of unnamed parameters to an <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <remarks>
            Use this method to populate the <see cref="P:System.Data.IDbCommand.Parameters"/> collection
            from an array of <see langword="object"/>.
            </remarks>
            <param name="command">An <see cref="T:System.Data.IDbCommand"/> that will receive the parameters.</param>
            <param name="args">An array of parameter values.</param>
        </member>
        <member name="M:EQTG.Database.DBUtil.ExecuteDBNonQuery(System.String,System.Data.IDbConnection,System.Object[])">
            <summary>
            Execute a query that does not return a results set
            </summary>
            <param name="sql">the query</param>
            <param name="db">the connection</param>
            <param name="args">Values used to replace any '?' placeholders in the SQL statement</param>
        </member>
        <member name="M:EQTG.Database.DBUtil.ExecuteDBNonQuery(System.String,System.Data.IDbTransaction,System.Object[])">
            <summary>
            Execute a query that does not return a results set
            </summary>
            <param name="sql">the query</param>
            <param name="tran">the transaction</param>
            <param name="args">Values used to replace any '?' placeholders in the SQL statement</param>
        </member>
        <member name="M:EQTG.Database.DBUtil.ExecuteDBScalar(System.String,System.Data.IDbConnection,System.Object[])">
            <summary>
            Executes the query, and returns the first column of the first row in the resultset returned 
            by the query. Extra columns or rows are ignored.
            </summary>
            <param name="sql">SQL query</param>
            <param name="db">Database connection on which to execute the query</param>
            <param name="args">Values used to replace any '?' placeholders in the SQL statement</param>
            <returns>The first column of the first row in the resultset</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.ExecuteDBScalar(System.String,System.Data.IDbTransaction,System.Object[])">
            <summary>
            Executes the query, and returns the first column of the first row in the resultset returned 
            by the query. Extra columns or rows are ignored.
            </summary>
            <param name="sql">SQL query</param>
            <param name="tran">Database transaction on which to execute the query</param>
            <param name="args">Values used to replace any '?' placeholders in the SQL statement</param>
            <returns>The first column of the first row in the resultset</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.ExecuteReader(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Executes a query and returns a IDataReader
            </summary>
            <param name="dbCon">Database Connection</param>
            <param name="sql">Query string</param>
            <param name="args">Values used to replace any '?' placeholders in the SQL statement</param>
            <returns>The IDataReader</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.ExecuteReader(System.Data.IDbConnection,System.String)">
            <summary>
            Executes a query and returns a IDataReader
            </summary>
            <param name="dbCon">Database Connection</param>
            <param name="sql">Query string</param>
            <returns>The IDataReader</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.GetDSNName(System.String)">
            <summary>
            Strips the DSN name out of the connection string
            </summary>
            <param name="connectionString">The connections string</param>
            <returns>The DSN</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.hasColumn(System.Data.IDataReader,System.String)">
            <summary>
            Checks to see if a given data reader contains a named column.
            like IDataRecord.GetOrdinal it does a case-insensitive check if the case-sensitive on fails.
            </summary>
            <param name="reader">The IDataReader to be checked</param>
            <param name="columnName">The name of the column to be checked.</param>
            <returns>bool</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.FormInsertStatement(System.String,System.String[])">
            <summary>
            Utility function to build an insert statement
            </summary>
            <param name="table">Table to insert into</param>
            <param name="values">List of values (in order)</param>
            <returns>The completed SQL statement</returns>
            <example >FormInsertStatement ("SomeTable","'StringValue'","42");
            gives:
            insert SomeTable values ('StringValue',42)
            </example>
        </member>
        <member name="M:EQTG.Database.DBUtil.CommandToString(System.Data.IDbCommand)">
            <summary>
            Describes a command object.
            </summary>
            <param name="command">The command.</param>
            <returns>The command text with a list of parameters.</returns>
            <remarks>
            This version of the method also describes the parameters included with command text.
            </remarks>
        </member>
        <member name="M:EQTG.Database.DBUtil.CleanConnectionString(System.String)">
            <summary>
            Strips the password from a connection string by removing any PWD= and Password= parameters.
            </summary>
            <param name="connectionString">Connection string to clean</param>
            <returns>connectionString, minus password</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.IsSelectQuery(System.String)">
            <summary>
            Determines whether the SQL text provided consists of a select query.
            </summary>
            <param name="sqlText">SQL text</param>
            <returns><see langword="true"/> if <paramref name="sqlText"/> is a select query; otherwise,
            <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.IsWriteQuery(System.String)">
            <summary>
            Determines whether the SQL text provided could write to the database.
            </summary>
            <param name="sqlText">SQL text</param>
            <returns><see langword="true"/> if <paramref name="sqlText"/> is a write query; otherwise,
            <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.Database.DBUtil.DumpSqlResults(System.String,System.Data.IDbConnection,System.Object[])">
            <summary>
            Dump the results of a SQL query to the logs
            </summary>
            <param name="sql">The SQL query</param>
            <param name="db">The database connection</param>
        </member>
        <member name="M:EQTG.Database.DBUtil.LogQueryTime(System.DateTime,System.String)">
            <summary>
            Logs out the time taken by the sql statement
            </summary>
            <param name="dtStart">The time the query was started</param>
            <param name="sql">The SQL query</param>
        </member>
        <member name="P:EQTG.Database.DBUtil.SqlRetryWait">
            <summary>
            Sleep N milliseconds between 2 execution. It will not sleep at last time execution.
            </summary>
        </member>
        <member name="T:EQTG.Database.Entitlements.DatabaseNameAndGroup">
            <summary>
            Description of databases and groups that a user belongs to.
            Also allows identification of the default database
            </summary>
        </member>
        <member name="F:EQTG.Database.Entitlements.DatabaseNameAndGroup.myDefaultDatabase">
            <summary>
            Indicator of whether this is the default database
            </summary>
        </member>
        <member name="F:EQTG.Database.Entitlements.DatabaseNameAndGroup.myDatabaseName">
            <summary>
            Name of the database storage
            </summary>
        </member>
        <member name="F:EQTG.Database.Entitlements.DatabaseNameAndGroup.myGroupName">
            <summary>
            Group name storage
            </summary>
        </member>
        <member name="F:EQTG.Database.Entitlements.DatabaseNameAndGroup.myOriginalGroupName">
            <summary>
            Original Group name storage
            </summary>
        </member>
        <member name="P:EQTG.Database.Entitlements.DatabaseNameAndGroup.DatabaseName">
            <summary>
            Name of database on dataserver
            </summary>
        </member>
        <member name="P:EQTG.Database.Entitlements.DatabaseNameAndGroup.GroupName">
            <summary>
            Group the user belongs to on the named database
            </summary>
        </member>
        <member name="P:EQTG.Database.Entitlements.DatabaseNameAndGroup.OriginalGroupName">
            <summary>
            Original Group that the user belonged to on the named database
            </summary>
        </member>
        <member name="P:EQTG.Database.Entitlements.DatabaseNameAndGroup.DefaultDatabase">
            <summary>
            Indicator as to whether this is the default database for the user
            </summary>
        </member>
        <member name="T:EQTG.Database.Entitlements.DatabaseUserException">
            <summary>
            Special exception class used when verifying data server config conssitency
            </summary>
        </member>
        <member name="P:EQTG.Database.Entitlements.DataServer.IsProduction">
            <summary>
            Production server property
            </summary>
        </member>
        <member name="T:EQTG.Database.Entitlements.DataServerAdministrator">
            <summary>
            Utility class providing the toolkit for administering database
            logins on a Sybase data server. 
            Functionality is presented in a fairly raw form to allow potential 
            re-use from multiple editors or tools
            </summary>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.#ctor(System.Data.IDbConnection)">
            <summary>
            C'tor
            </summary>
            <param name="connection">(Open) database connection</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.CreateLogin(System.Data.IDbConnection,System.Data.IDbTransaction,System.String,System.String,System.Collections.ArrayList)">
            <summary>
            Create a dataserver login and add the user to the supplied databases.
            Set the default database as well.
            </summary>
            <param name="connection">Database connection to use</param>
            <param name="trans">Transaction to use</param>
            <param name="login">Login id</param>
            <param name="password">(Dummy) password- will be reset</param>
            <param name="userDatabasesAndGroups">Databases the user will have access to</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.CreateDataserverLogin(System.Data.IDbConnection,System.Data.IDbTransaction,System.String,System.String,System.String)">
            <summary>
            Create login data server
            </summary>
            <param name="connection">Connection to use</param>
            <param name="trans">Transaction this belongs in</param>
            <param name="login">KLogin Id</param>
            <param name="password">(Temporary) Password</param>
            <param name="defaultDatabase">Name of the default database</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.LoginExists(System.Data.IDbConnection,System.String)">
            <summary>
            Check whether the specified login exists on the dataserver
            </summary>
            <param name="connection">Connection to check</param>
            <param name="login">Login to test</param>
            <returns>True if the login exists on the dataserver</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.GetCurrentDatabaseName(System.Data.IDbTransaction)">
            <summary>
            Determines the database name for the Server Administrator's Connection
            </summary>
            <param name="trans">Transaction to participate in. Can be null.</param>
            <returns>Database name for the connection</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.SetCurrentDatabase(System.String,System.Data.IDbTransaction)">
            <summary>
            Sets the current database for the Server Administrator's Connection
            </summary>
            <param name="databaseName">Database name to set connection to</param>
            <param name="trans">Transaction to participate in. Can be null.</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.DropUserFromDatabases(System.Data.IDbTransaction,System.String)">
            <summary>
            Drop the user from all databases on the dataserver
            </summary>
            <param name="trans">Transaction this should bbe done within</param>
            <param name="loginId">Login id</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.IsSystemDatabase(System.String)">
            <summary>
            Utility to identify system databases
            </summary>
            <param name="database">Name of database to check</param>
            <returns>True if this is a system database</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.DropUserLogin(System.String)">
            <summary>
            Drop the login from the dataserver
            </summary>
            <param name="loginId">Login to drop</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.GetAvailableDatabases">
            <summary>
            List all available databases for the user
            Requires that a stored procedure exists on the database with the 
            name 'listUserAvailableDatabases'
            The stored procedure nmay return as many results sets as required
            with the database names returned in a column called 'databaseName'
            </summary>
            <returns>List of databases available to the user on the data server on the connection</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.GetUserDefaultDatabase">
            <summary>
            Determine the default user database on our db connection
            Relies on stored procedure listAvasilableDatabases
            </summary>
            <returns>The default database, or string.Empty if none</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.GetLoginGroup(System.String,System.String)">
            <summary>
            Get the group the login belongs to on the specified database
            </summary>
            <param name="database">Database to check</param>
            <param name="login">Login Id</param>
            <returns>Group the login belongs to on the specified database</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.GrantSecurityOfficerRole(System.Boolean,System.String)">
            <summary>
            Grant the login the sso role
            </summary>
            <param name="grant">True if the role should be granted</param>
            <param name="login">Login id</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.IsAccountLocked(System.String)">
            <summary>
            Check if the specified account is locked
            </summary>
            <param name="login">Login id to check</param>
            <returns>True if the account is locked, false otherwise</returns>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.LockLogin(System.String,System.Boolean)">
            <summary>
            Lock the specified login on the dataserver
            </summary>
            <param name="login">Login to lock</param>
            <param name="lockLogin">True if the account should be locked, false to unlock the account</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.CreateDatabaseUser(System.String,System.String,System.Data.IDbConnection,System.Data.IDbTransaction,System.String)">
            <summary>
            Add the specified login the supplied database
            </summary>
            <param name="database">Name of the database</param>
            <param name="login">Login Id to add</param>
            <param name="connection">Database connection to use</param>
            <param name="trans">Transaction this should be done within</param>
            <param name="groupName">Name of the group on the database</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.ChangeUserGroupsForDatabase(System.String,System.Collections.ArrayList,System.Data.IDbConnection,System.Data.IDbTransaction)">
            <summary>
            Changes the Group that a User belongs to in a database
            </summary>
            <param name="loginId">LoginID to change User group</param>
            <param name="userGroups">List of DatabaseNameAndGroup objects, detailing which group a User should be in for a particular database.</param>
            <param name="connection">Connection to use</param>
            <param name="trans">Transaction to use</param>
            <remarks>
            Assumes that the Username is the same as the LoginId. Also assumes that caller has SSO priviliges.
            </remarks>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.DropDatabaseUser(System.String,System.Data.IDbConnection,System.Data.IDbTransaction,System.String)">
            <summary>
            Drop the login from the database
            </summary>
            <param name="database">Database to drop from</param>
            <param name="connection">Connection to use</param>
            <param name="trans">Transaction this should be done within</param>
            <param name="loginId">Login id to drop</param>
        </member>
        <member name="M:EQTG.Database.Entitlements.DataServerAdministrator.GetConnection">
            <summary>
            Access the member connection
            </summary>
            <returns>Member database connection as supplied by c'tor</returns>
        </member>
        <member name="F:EQTG.Database.Entitlements.DataServerAdministrator.myConnection">
            <summary>
            Connection storage
            </summary>
        </member>
        <member name="F:EQTG.Database.Entitlements.DataServerAdministrator.OurDiagnostics">
            <summary>
            Class diagnostics
            </summary>
        </member>
        <member name="T:EQTG.Database.Entitlements.DataServerPermissions">
            <summary>
            This class allows maintenance of dataserver and database permissions for a login
            on a Sybase (and possibly an MS-SQL data server)
            It has not interaction with any other user database tables.
            </summary>
        </member>
        <member name="T:EQTG.Database.FileEncryptedPasswordsManager">
            <summary>
            Wrapper around passwords and key file mechanism used to store passwords for functional Ids.
            </summary>
            <remarks>
            <para>This class allows you to retrieve a password for a batch account stored in the 
            passwords file for a given login on a given database.</para>
            
            <para>User logins are encrypted and stored separately in the SECuserPasswords table,
            accessed through <see cref="T:EQTG.Database.UserDBPasswordManager"/>.</para>
            </remarks>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.FileEncryptedPasswordsManager"/> class.
            </summary>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.FileEncryptedPasswordsManager"/> class
            using the security directory provided.
            </summary>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.AutoPasswordFromLoginAndServerName(System.String,System.String,EQTG.General.Application.CommandParameterList)">
            <summary>
            Extract the password from an encrypted password store (e.g. encrypt.txt)
            </summary>
            <remarks>
            <para>This provides an alternative to the standard login Id encryption applied
            to users, and storing encrypted passwords in the database.</para>
            <para>Assumes that the key in the encrypt.txt file is of format loginId.servername.</para>
            </remarks>
            <exception cref="T:System.ApplicationException">Thrown if the password could not be found</exception>
            <param name="loginId">Login Id for which we require the password</param>
            <param name="dataServer">Server name (key in passwords file)</param>
            <param name="commandParameters">Command parameters for this application, 
            optionally required for location of password file, else defaults to environment variable</param>
            <returns>Password for the given loginId on the specified data server</returns>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.AutoPasswordFromPasswordsFileKey(System.String,EQTG.General.Application.CommandParameterList)">
            <summary>
            Extract the password from an encrypted password store (e.g. encrypt.txt)
            </summary>
            <remarks>
            This provides an ALTERNATIVE to the standard login id encryption applied
            to users, and storing encrypted passwrods in the database.
            </remarks>
            <exception cref="T:System.ApplicationException">Thrown if the password could not be found</exception>
            <param name="passwordsFileKey">Key in the parameters file</param>
            <param name="commandParameters">Command parameters for this application, 
            optionally required for location of password file, else defaults to environment variable</param>
            <returns>Password for the given loginId on the specified data server</returns>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.GetPasswordFilesDirectory(EQTG.General.Application.CommandParameterList)">
            <summary>
            Extract the passwords files directory from either the command parameters or the environment
            </summary>
            <remarks>
            The password files directory is picked from one of the following:
            <list type="number">
            	<item>
            		<description>The directory specified by the -EQPASSWORDDIR parameter</description>
            	</item>
            	<item>
            		<description>The directory specified by the -securityDirectory parameter</description>
            	</item>
            	<item>
            		<description>The directory specified by the EQPASSWORDDIR environment variable</description>
            	</item>
            	<item>
            		<description>The \\ukeqsa05.eu.ssmb.com\EQTGdistribution\Security directory</description>
            	</item>
            </list>
            </remarks>
            <param name="parameterList">Parameter list from which to get location of files (optional - defaults to environment if not supplied)</param>
            <returns>Location of passwords files, based on command parameters or environment</returns>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.ReadKeyFromKeyFile(System.String)">
            <summary>
            Read key from key file in specified directory.
            Assumes file name is keys.txt
            Throws if cannot read properly.
            </summary>
            <param name="passwordsDirectory">Location of the key file</param>
        </member>
        <member name="M:EQTG.Database.FileEncryptedPasswordsManager.ReadEncryptedPasswordsFromFile(System.String)">
            <summary>
            Read encrypted passwords from file and store for later use.
            Assumes file name is encrypt.txt
            </summary>
            <param name="passwordsDirectory">Directory from which to read the file</param>
        </member>
        <member name="F:EQTG.Database.FileEncryptedPasswordsManager.myEncryptedPasswords">
            <summary>
            Storage of encrypted passwords
            </summary>
        </member>
        <member name="F:EQTG.Database.FileEncryptedPasswordsManager.myPasswordComments">
            <summary>
            Login comments
            </summary>
        </member>
        <member name="F:EQTG.Database.FileEncryptedPasswordsManager.myEncryptionKey">
            <summary>
            Storage of key to encrypt passwords
            </summary>
        </member>
        <member name="F:EQTG.Database.FileEncryptedPasswordsManager.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.Database.IDataRow">
            <summary>
            Interface matching the interface of System.Data.DataRow, which the boys at MS sdaly implemented as a class
            Only partially implemented so far
            Fill it in as you go along
            </summary>
        </member>
        <member name="T:EQTG.Database.DataRowAdapter">
            <summary>
            Wraps up an actual DataRow in our interface
            </summary>
        </member>
        <member name="T:EQTG.Database.IDbFactory">
            <summary>
            Abstract factory for DB objects
            </summary>
        </member>
        <member name="M:EQTG.Database.IDbFactory.DataParameter(System.String,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="value">The value of the parameter.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.IDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.IDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32,System.String)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <param name="sourceColumn">The parameter's column mapping.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.IDbFactory.DataParameter(System.String,System.Data.DbType,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="direction">The parameter's direction.</param>
            <param name="value">The value of the parameter.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.IDbFactory.DeriveParameters(System.Data.IDbCommand)">
            <summary>
            Function that takes a Command object, and populates its Parameters collection from the database
            </summary>
            <param name="command">
            Command to derive Parameters for
            </param>
        </member>
        <member name="T:EQTG.Database.InvokeDelegate">
            <summary>
            Delegate type used to call Invoke on a IWrapCommand
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:EQTG.Database.InvokeDelegate`1" -->
        <member name="M:EQTG.Database.IWrapCommand.Invoke(EQTG.Database.InvokeDelegate)">
            <summary>
            Invokes the specified delegate.
            </summary>
            <param name="command">The command.</param>
        </member>
        <member name="M:EQTG.Database.IWrapCommand`1.Invoke(EQTG.Database.InvokeDelegate{`0})">
            <summary>
            Invokes the specified delegate command and returns the response
            </summary>
            <param name="command">The command.</param>
            <returns></returns>
        </member>
        <member name="T:EQTG.Database.LoggedDatabase.LoggedCommand">
            <summary>
            EQTG Wrapper around commands. Supply an IDbConnection to create commands and
            call execute methods to get either a scalar value or a Reader
            Since this implements the IDbCommand interface you can put one of these between
            an IDbCommand and the client code, and thereby allow debugging of all Commands
            
            NOTE: We use late binding to the underlying connection so that if there is no connection
            the realCommand will through real data provider exceptions rather than them being
            replaced with our own.
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.#ctor(System.Data.IDbCommand)">
            <summary>
            Alternative DBCommand constructor, using pre-existing IDbCommand
            </summary>
            <param name="commandString">SQL to execute</param>
            <param name="connection">EQTG DBConnection instance</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.ExecuteReader">
            <summary>
            execute the query and get a reader to read multiple rows back
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.ExecuteReader(System.Data.CommandBehavior)">
            <summary>
            Forward interface
            </summary>
            <param name="behaviour">Command Behaviou r to use</param>
            <returns>Data reader</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.ExecuteScalar">
            <summary>
            execute the query and get a single object back, which you can be cast to the appropriate type
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.Cancel">
            <summary>
            Forward interface
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.Prepare">
            <summary>
            Forward interface
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.CreateParameter">
            <summary>
            Forward interface
            </summary>
            <returns>DataParameter interface</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.ExecuteNonQuery">
            <summary>
            Forward interface
            </summary>
            <returns>The number of rows affected</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.EnsureBoundLoggedConnection">
            <summary>
            This method allows late binding to the underlying IDbCommands connection. It checks to see
            if we were bound and attempt to do so if we were not
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.RecordTimeNow">
            <summary>
            This is used to set the LastQueryTime on our LoggedConnection (if set) to
            the current Time
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedCommand.Dispose">
            <summary>
            Forward the Dispose method
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedCommand.myRealCommand">
            <summary>
            Implementation OdbcCommand member visible within the Database library but not outside.
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedCommand.OurClassDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedCommand.myConnectionName">
            <summary>
            Name, useful for diagnostics. Supplied from connection.
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedCommand.myLoggedConnection">
            <summary>
            Used to store query time for the underlying connection
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.Connection">
            <summary>
            Forward connection property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.LoggedConnection">
            <summary>
            Forward connection property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.Transaction">
            <summary>
            Forward Transaction property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.CommandText">
            <summary>
            Forward CommandText property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.CommandTimeout">
            <summary>
            Forward CommandTimeout property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.CommandType">
            <summary>
            Forward CommandType property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.Parameters">
            <summary>
            Forward Parameters property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.ConnectionName">
            <summary>
            Connection name property, useful for diagnostics
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.UpdatedRowSource">
            <summary>
            Forward UpdatedRowSource property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedCommand.RealCommand">
            <summary>
            Access to real command for purposes of keeping logged commands/readers etc in sync
            </summary>
        </member>
        <member name="T:EQTG.Database.LoggedDatabase.LoggedConnection">
            <summary>
            EQTG wrapper around database connections.
            </summary>
            <remarks>
            <para>
            Supply a real <see cref="T:System.Data.IDbConnection"/> to this class and it will forward all calls through to it, 
            logging if required.
            </para>
            <para>
            <see cref="T:EQTG.Database.LoggedDatabase.LoggedConnection"/> binds to a LoggedConnectionImpl for the given <see cref="T:System.Data.IDbConnection"/> 
            or creates a new one if required.
            </para>
            </remarks>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.#ctor(System.Data.IDbConnection)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Database.LoggedDatabase.LoggedConnection"/> class.
            </summary>
            <param name="realConnection">The real <see cref="T:System.Data.IDbConnection"/> implementation.</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.Clone">
            <summary>
            Clones this Connection object
            </summary>
            <returns>
            A new database Connection object with the same characteristics as the source Connection. 
            The object supports the <see cref="T:System.Data.IDbConnection"/> interface.
            </returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.BeginTransaction">
            <summary>
            BeginTransaction method (forward to implementation)
            </summary>
            <returns>New Transaction</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            BeginTransaction method (forward to implementation)
            </summary>
            <param name="isolationLevel">Isolation level</param>
            <returns>New Transaction</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.ChangeDatabase(System.String)">
            <summary>
            ChangeDatabase method (forward to implementation)
            </summary>
            <param name="databaseName">New database to use</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.Close">
            <summary>
            Close method (forward to implementation)
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.Open">
            <summary>
            Open method (forward to implementation)
            </summary>v
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.CreateCommand">
            <summary>
            CreateCommand method. (forward to implementation)
            </summary>
            <returns>New Database command</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnection.Dispose">
            <summary>
            Dispose method (forward to implementation)
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnection.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnection.myImpl">
            <summary>
            Stores strong reference to implementation
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.SyncRoot">
            <summary>
            To access the object in a thread safe way lock against the underlying implementation
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.Connection">
            <summary>
            Returns the underlying connection object
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.ConnectionString">
            <summary>
            ConnectionString property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.ConnectionTimeout">
            <summary>
            Connection Timeout property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.Database">
            <summary>
            Database property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.State">
            <summary>
            State property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.ConnectionName">
            <summary>
            Connection name property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnection.LastQueryTime">
            <summary>
            Used to access the LastQueryTime of this connection
            </summary>
        </member>
        <member name="T:EQTG.Database.LoggedDatabase.LoggedConnectionImpl">
            <summary>
            EQTG Wrapper around database connections. Supply a real IDbConnection to this class
            and it will forward all calls through to it, logging if required.
            
            Note we use the proxy/implementation pattern so that we can be sure each IDbConection only gets
            one single LoggedConnectionImpl (so there is only one querytime on the connection).
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.GetConnection(System.Data.IDbConnection)">
            <summary>
            Obtains a <see cref="T:EQTG.Database.LoggedDatabase.LoggedConnectionImpl"/> for the given <see cref="T:System.Data.IDbConnection"/>,
            creating a new one if necessary.
            </summary>
            <param name="realConnection">The real <see cref="T:System.Data.IDbConnection"/> implementation.</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.BeginTransaction">
            <summary>
            BeginTransaction method (forward to implementation)
            </summary>
            <returns>New Transaction</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            BeginTransaction method (forward to implementation)
            </summary>
            <param name="isolationLevel">Isolation level</param>
            <returns>New Transaction</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.ChangeDatabase(System.String)">
            <summary>
            ChangeDatabase method (forward to implementation)
            </summary>
            <param name="databaseName">New database to use</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.Close">
            <summary>
            Close method (forward to implementation)
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.Open">
            <summary>
            Open method (forward to implementation)
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.CreateCommand">
            <summary>
            CreateCommand method. (forward to implementation)
            </summary>
            <returns>New Database command</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.Dispose">
            <summary>
            Dispose method (forward to implementation)
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.myRealConnection">
            <summary>
            Real IDbConnection implementation, to which we forward all implementation
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.mySpid">
            <summary>
            Spid id storage
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.myLastQueryTime">
            <summary>
            We store the last time that we executed a query in the dataserver so that we can
            spot when a query is running slowly
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.myConnectionName">
            <summary>
            Name, useful for diagnostics
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.OurConnCount">
            <summary>
            Counter to provide distinct connection names
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.OurIDbConnections">
            <summary>
            A hash of IDbConnection objects to their LoggedConnectionImpl
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.ConnectionString">
            <summary>
            ConnectionString property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.ConnectionTimeout">
            <summary>
            Connection Timeout property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.Database">
            <summary>
            Database property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.State">
            <summary>
            State property (forward to implementation)
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.ConnectionName">
            <summary>
            Connection name property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.LastQueryTime">
            <summary>
            Used to access the LastQueryTime of this connection
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedConnectionImpl.RealConnection">
            <summary>
            Gets the real <see cref="T:System.Data.IDbConnection"/> implementation, to which we forward all implementation
            </summary>
        </member>
        <member name="T:EQTG.Database.LoggedDatabase.LoggedDataAdapter">
            <summary>
            EQTG Wrapper around data adapters. Supply an IDataAdapter to create 
            Since this implements the IDataAdapter interface you can put one of these between
            an IDataAdapter and the client code, and thereby allow debugging of any IDataAdapter
            /// </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDataAdapter.#ctor(System.Data.IDbDataAdapter)">
            <summary>
            LoggedDataAdapter constructor
            </summary>
            <param name="dataAdapter">IDataAdapter instance</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)">
            <summary>
            Forward this method on to the real adapter
            </summary>
            <param name="dataSet">Data set to populate</param>
            <param name="schemaType">Schema type to forward</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDataAdapter.Fill(System.Data.DataSet)">
            <summary>
            Fill Data set
            </summary>
            <param name="dataSet">Dataset to populate</param>
            <returns>Number of items in Dataset</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDataAdapter.GetFillParameters">
            <summary>
            Get parameters set for SQL
            </summary>
            <returns>Set of parameters</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDataAdapter.Update(System.Data.DataSet)">
            <summary>
            Update the data source from the DataSet
            </summary>
            <param name="dataSet">DateSet to update from</param>
            <returns>Number of rows updated</returns>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedDataAdapter.myRealAdapter">
            <summary>
            Implementation Data Adapter
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedDataAdapter.OurClassDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.MissingMappingAction">
            <summary>
            MissingAction property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.MissingSchemaAction">
            <summary>
            Missing schema action property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.TableMappings">
            <summary>
            TableMappings property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.DeleteCommand">
            <summary>
            DeleteCommand property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.SelectCommand">
            <summary>
            SelectCommand property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.InsertCommand">
            <summary>
            SelectCommand property
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedDataAdapter.UpdateCommand">
            <summary>
            UpdateCommand property
            </summary>
        </member>
        <member name="T:EQTG.Database.LoggedDatabase.LoggedDbFactory">
            <summary>
            Wrapper factory to add logging to an IDbFactory implementation.
            Insert one of these between the client and you real IDbFactory implementation
            and all the database activity will be logged through the diagnostics system
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDbFactory.#ctor(EQTG.Database.IDbFactory)">
            <summary>
            C'tor
            </summary>
            <param name="realFactory">reald IDbFactory implementation that you would like to use</param>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32,System.String)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <param name="sourceColumn">The parameter's column mapping.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDbFactory.DataParameter(System.String,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="value">The value of the parameter.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDbFactory.DataParameter(System.String,System.Data.DbType,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="direction">The parameter's direction.</param>
            <param name="value">The value of the parameter.</param>
            <returns>A parameter.</returns>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedDbFactory.DebugDBHandler(System.Object[])">
            <summary>
            Handler for the debug_db appcommand
            </summary>
            <param name="args">Appcommand parameters: 0 to disable database logging; 1 to enable it</param>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedDbFactory.myRealFactory">
            <summary>
            Factory that actuall does the real work
            </summary>
        </member>
        <member name="T:EQTG.Database.LoggedDatabase.LoggedReader">
            <summary>
            Wrapper class around the data reader we are using. 
            It's required so we can add diagnostics.
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedReader.#ctor(EQTG.Database.LoggedDatabase.LoggedCommand,System.Data.IDataReader)">
            <summary>
            C'tor. Internal since it's always constructed by an IDbCommand execute type statement
            </summary>
        </member>
        <member name="M:EQTG.Database.LoggedDatabase.LoggedReader.CheckQueryTime(System.String,System.Boolean)">
            <summary>
            This is used to output a warning if a query is taking too long to run
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedReader.myLoggedCommand">
            <summary>
            This LoggedCommand will allow us to spot slow queries
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedReader.myAnyoneListeningToDebug">
            <summary>
            Marker flag to indicate whether anyone's listening to the subject
            </summary>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedReader.OurSlowQueryThreshold">
            <summary>
            Sets the timespan after which we shall report slow SQL for the connection
            </summary>
            <param name="?"></param>
            <returns></returns>
        </member>
        <member name="F:EQTG.Database.LoggedDatabase.LoggedReader.OurNumberOfSlowQueryWarnings">
            <summary>
            Specifies the number of SlowQuery warnings that will be generated per reader
            </summary>
        </member>
        <member name="P:EQTG.Database.LoggedDatabase.LoggedReader.RealDataReader">
            <summary>
            Data reader property, intended for use only by other Logged Data classes (read only)
            </summary>
        </member>
        <member name="T:EQTG.Database.MSSqlDbFactory">
            <summary>
            Concrete factory for Sql database work
            </summary>
        </member>
        <member name="M:EQTG.Database.MSSqlDbFactory.Command(System.String,System.Data.IDbConnection)">
            <summary>
            Command factory
            </summary>
            <param name="query">Query for command</param>
            <param name="connection">Connection to create the command with</param>
            <returns>New Command interface</returns>
        </member>
        <member name="M:EQTG.Database.MSSqlDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32)">
            <summary>
            Creates a new sql parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <returns>An sql parameter.</returns>
        </member>
        <member name="M:EQTG.Database.MSSqlDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32,System.String)">
            <summary>
            Creates a new sql parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <param name="sourceColumn">The parameter's column mapping.</param>
            <returns>An sql parameter.</returns>
        </member>
        <member name="M:EQTG.Database.MSSqlDbFactory.DataParameter(System.String,System.Object)">
            <summary>
            Creates a new sql parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="value">The value of the parameter.</param>
            <returns>An sql parameter.</returns>
        </member>
        <member name="M:EQTG.Database.MSSqlDbFactory.DataParameter(System.String,System.Data.DbType,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="direction">The parameter's direction.</param>
            <param name="value">The value of the parameter.</param>
            <returns>An SQL parameter.</returns>
        </member>
        <member name="T:EQTG.Database.ODBCDbFactory">
            <summary>
            Concrete factory for ODBC database work
            </summary>
        </member>
        <member name="M:EQTG.Database.ODBCDbFactory.Connection(System.String)">
            <summary>
            Connection factory
            </summary>
            <param name="connectionString">Connection details to initialise the connection with</param>
            <returns>New Connection interface</returns>
        </member>
        <member name="M:EQTG.Database.ODBCDbFactory.Command(System.String,System.Data.IDbConnection)">
            <summary>
            Command factory
            </summary>
            <param name="query">Query for command</param>
            <param name="connection">Connection to create the command with</param>
            <returns>New Command interface</returns>
        </member>
        <member name="M:EQTG.Database.ODBCDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32)">
            <summary>
            Creates a new odbc parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <returns>An odbc parameter.</returns>
        </member>
        <member name="M:EQTG.Database.ODBCDbFactory.DataParameter(System.String,System.Data.DbType,System.Int32,System.String)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="size">The parameter's size in bytes.</param>
            <param name="sourceColumn">The parameter's column mapping.</param>
            <returns>An odbc parameter.</returns>
        </member>
        <member name="M:EQTG.Database.ODBCDbFactory.DataParameter(System.String,System.Data.DbType,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="type">The parameter's dbtype.</param>
            <param name="direction">The parameter's direction.</param>
            <param name="value">The value of the parameter.</param>
            <returns>An odbc parameter.</returns>
        </member>
        <member name="M:EQTG.Database.ODBCDbFactory.DataParameter(System.String,System.Object)">
            <summary>
            Creates a new parameter.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="value">The value of the parameter.</param>
            <returns>An odbc parameter.</returns>
        </member>
        <member name="T:EQTG.Database.ODBCSourceLists">
            <summary>
            Gets the list of ODBC source names.
            </summary>
            <remarks>
            <para>This class allows you to:</para>
            <list type="bullet">
            	<item>
            		<description>Get just user sources with GetUserDSNList</description>
            	</item>
            	<item>
            		<description>Get just system sources with GetSystemDSNList</description>
            	</item>
            	<item>
            		<description>Get all user and system sources with GetAllDSNList</description>
            	</item>
            </list>
            
            <para>The returned list can be sorted. You can also restrict the returned list 
            using a standard regular expression.</para>
            
            <example>Code to get sorted list and put in a combo box, returning only those beginning with DRMS:
            <code>
            ArrayList odbcSourceNames = new ArrayList();
            odbcSourceLists.GetAllDSNList(odbcSourceNames, true /* sort the list */, "DRMS*");
            dbName.Items.AddRange( odbcSourceNames.ToArray() );
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:EQTG.Database.ODBCSourceLists.GetUserDSNList(System.Collections.ArrayList,System.Boolean,System.String)">
            <summary>
            Get all ODBC sources from the user DSNs
            </summary>
            <param name="list">List to populate</param>
            <param name="bSort">True if list should be alphabetically sorted</param>
            <param name="filter">Optional regular expression filter</param>
        </member>
        <member name="M:EQTG.Database.ODBCSourceLists.GetSystemDSNList(System.Collections.ArrayList,System.Boolean,System.String)">
            <summary>
            Get all ODBC sources from the system DSNs
            </summary>
            <param name="list">List to populate</param>
            <param name="bSort">True if list should be alphabetically sorted</param>
            <param name="filter">Optional regular expression filter</param>
        </member>
        <member name="M:EQTG.Database.ODBCSourceLists.GetAllDSNList(System.Collections.ArrayList,System.Boolean,System.String)">
            <summary>
            Get all ODBC sources from both the user and system DSNs
            </summary>
            <param name="list">List to populate</param>
            <param name="bSort">True if list should be alphabetically sorted</param>
            <param name="filter">Optional regular expression filter</param>
        </member>
        <member name="M:EQTG.Database.ODBCSourceLists.AddODBCSourceNames(System.Collections.ArrayList,Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Add ODBC source names from the given registry section
            </summary>
            <param name="list">List to populate</param>
            <param name="hive">Registry section to inspect</param>
            <param name="filter">Regular expression match</param>
        </member>
        <member name="T:EQTG.Database.PosIdList">
            <summary>
            Manages the temporary table #positionIds which is used by a number of stored procedures
            </summary>
        </member>
        <member name="T:EQTG.Database.SortBySurname">
            <summary>
            Instance of IComparer which sorts DataRows by the surname embedded in the field
            "name"
            </summary>
        </member>
        <member name="T:EQTG.Database.DatabaseHelper">
            <summary>
            The DatabaseHelper class is intended to encapsulate high performance, scalable best practices for 
            common uses of SqlClient
            </summary>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.AttachParameters(System.Data.IDbCommand,System.Data.IDataParameter[])">
            <summary>
            This method is used to attach array of SqlParameters to a IDbCommand.
            
            This method will assign a value of DbNull to any parameter with a direction of
            InputOutput and a value of null.  
            
            This behavior will prevent default values from being used, but
            this will be the less common case than an intended pure output parameter (derived as InputOutput)
            where the user provided no input value.
            </summary>
            <param name="command">The command to which the parameters will be added</param>
            <param name="commandParameters">An array of SqlParameters to be added to command</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.AssignParameterValues(System.Data.IDataParameter[],System.Data.DataRow)">
            <summary>
            This method assigns dataRow column values to an array of SqlParameters
            </summary>
            <param name="commandParameters">Array of SqlParameters to be assigned values</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.AssignParameterValues(System.Data.IDataParameter[],System.Object[])">
            <summary>
            This method assigns an array of values to an array of SqlParameters
            </summary>
            <param name="commandParameters">Array of SqlParameters to be assigned values</param>
            <param name="parameterValues">Array of objects holding the values to be assigned</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.PrepareCommand(System.Data.IDbCommand,System.Data.IDbConnection,System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[],System.Boolean@)">
            <summary>
            This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
            to the provided command
            </summary>
            <param name="command">The IDbCommand to be prepared</param>
            <param name="connection">A valid IDbConnection, on which to execute this command</param>
            <param name="transaction">A valid IDbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="mustCloseConnection"><c>true</c> if the connection was opened by the method, otherwose is false.</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns no resultset and takes no parameters) against the database specified in 
            the connection string
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns no resultset) against the database specified in the connection string 
            using the provided parameters
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns no resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(connString, "PublishOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored prcedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns no resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns no resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns no resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(conn, "PublishOrders", 24, 36);
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns no resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns no resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQuery(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns no resultset) against the specified 
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(conn, trans, "PublishOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(connString, "GetOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(conn, "GetOrders", 24, 36);
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDataset(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified 
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(trans, "GetOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbConnection,System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[],EQTG.Database.DatabaseHelper.SqlConnectionOwnership)">
            <summary>
            Create and prepare a IDbCommand, and call ExecuteReader with the appropriate CommandBehavior.
            </summary>
            <remarks>
            If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
            
            If the caller provided the connection, we want to leave it to them to manage.
            </remarks>
            <param name="connection">A valid IDbConnection, on which to execute this command</param>
            <param name="transaction">A valid IDbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="connectionOwnership">Indicates whether the connection parameter was provided by the caller, or created by DatabaseHelper</param>
            <returns>IDataReader containing the results of the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             IDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             IDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             IDataReader dr = ExecuteReader(connString, "GetOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <remarks>
            e.g.:  
             IDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             IDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             IDataReader dr = ExecuteReader(conn, "GetOrders", 24, 36);
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             IDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
              IDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReader(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             IDataReader dr = ExecuteReader(trans, "GetOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a 1x1 resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, "GetOrderCount", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a 1x1 resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, "GetOrderCount", 24, 36);
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute a IDbCommand (that returns a 1x1 resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a 1x1 resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount", new IDataParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalar(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a 1x1 resultset) against the specified
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, "GetOrderCount", 24, 36);
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.String,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.String,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.String,System.String,System.Data.DataSet,System.String[],System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, 24);
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>    
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <remarks>
            e.g.:  
             FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>    
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbConnection,System.String,System.Data.DataSet,System.String[],System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             FillDataset(conn, "GetOrders", ds, new string[] {"orders"}, 24, 36);
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            Execute a IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             FillDataset(trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Execute a IDbCommand (that returns a resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             FillDataset(trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new IDataParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbTransaction,System.String,System.Data.DataSet,System.String[],System.Object[])">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified 
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             FillDataset(trans, "GetOrders", ds, new string[]{"orders"}, 24, 36);
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.FillDataset(System.Data.IDbConnection,System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Private helper method that execute a IDbCommand (that returns a resultset) against the specified IDbTransaction and IDbConnection
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             FillDataset(conn, trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new IDataParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.CreateCommand(System.Data.IDbConnection,System.String,System.String[])">
            <summary>
            Simplify the creation of a Sql command object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <remarks>
            e.g.:  
             IDbCommand command = CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
            </remarks>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
            <returns>A valid IDbCommand object</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQueryTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns no resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQueryTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns no resultset) against the specified IDbConnection 
            using the dataRow column values as the stored procedure's parameters values.  
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteNonQueryTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns no resultset) against the specified
            IDbTransaction using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDatasetTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDatasetTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the dataRow column values as the store procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteDatasetTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbTransaction 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReaderTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReaderTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteReaderTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a resultset) against the specified IDbTransaction 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalarTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalarTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelper.ExecuteScalarTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via a IDbCommand (that returns a 1x1 resultset) against the specified IDbTransaction
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="T:EQTG.Database.DatabaseHelper.SqlConnectionOwnership">
            <summary>
            This enum is used to indicate whether the connection was provided by the caller, or created by DatabaseHelper, so that
            we can set the appropriate CommandBehavior when calling ExecuteReader()
            </summary>
        </member>
        <member name="F:EQTG.Database.DatabaseHelper.SqlConnectionOwnership.Internal">
            <summary>Connection is owned and managed by DatabaseHelper</summary>
        </member>
        <member name="F:EQTG.Database.DatabaseHelper.SqlConnectionOwnership.External">
            <summary>Connection is owned and managed by the caller</summary>
        </member>
        <member name="T:EQTG.Database.DatabaseHelperParameterCache">
            <summary>
            DatabaseHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
            ability to discover parameters for stored procedures at run-time.
            </summary>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.DiscoverSpParameterSet(System.Data.IDbConnection,System.String,System.Boolean)">
            <summary>
            Resolve at run time the appropriate set of SqlParameters for a stored procedure
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">Whether or not to include their return value parameter</param>
            <returns>The parameter array discovered.</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.CloneParameters(System.Data.IDataParameter[])">
            <summary>
            Deep copy of cached IDataParameter array
            </summary>
            <param name="originalParameters"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.CacheParameterSet(System.String,System.String,System.Data.IDataParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters to be cached</param>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.GetCachedParameterSet(System.String,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An array of SqlParamters</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.GetSpParameterSet(System.String,System.String)">
            <summary>
            Retrieves the set of SqlParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of SqlParameters</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.GetSpParameterSet(System.String,System.String,System.Boolean)">
            <summary>
            Retrieves the set of SqlParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for a IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of SqlParameters</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.GetSpParameterSet(System.Data.IDbConnection,System.String)">
            <summary>
            Retrieves the set of SqlParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of SqlParameters</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.GetSpParameterSet(System.Data.IDbConnection,System.String,System.Boolean)">
            <summary>
            Retrieves the set of SqlParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of SqlParameters</returns>
        </member>
        <member name="M:EQTG.Database.DatabaseHelperParameterCache.GetSpParameterSetInternal(System.Data.IDbConnection,System.String,System.Boolean)">
            <summary>
            Retrieves the set of SqlParameters appropriate for the stored procedure
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of SqlParameters</returns>
        </member>
        <member name="T:EQTG.Database.UserDBPasswordManager">
            <summary>
            UserDBPasswordManager controls access to the SecUserPasswordTable and
            allows a client to get the logon details for a particular NTUser. 
            This will allow the client to support the AutoLogon feature.
            <example>
            </example>
            </summary>
        </member>
        <member name="M:EQTG.Database.UserDBPasswordManager.RandomPassword">
            <summary>
             makes a random password
            </summary>
            <returns>30 char long password</returns>
        </member>
        <member name="M:EQTG.Database.UserDBPasswordManager.GetShortNTUser">
            <summary>
            gets the nt user strips out any domain name
            </summary>
            <returns>the nt user</returns>
        </member>
        <member name="M:EQTG.Database.UserDBPasswordManager.SetOverrideField(System.String,System.Char)">
            <summary>
            Sets the value of the override field in SECuserPasswords for the user.
            </summary>
            <param name="dbUser">Database user name.</param>
            <param name="overrideValue">Override value to set.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.UserDBPasswordManager.ResetPassword(System.String)">
            <summary>
            resets the password in secuserpassword and db login to a random password
            </summary>
            <param name="ntUserName"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.UserDBPasswordManager.ResetPassword(System.String,System.String)">
            <summary>
            resets the password in secuserpassword and db login to a specified password
            </summary>
            <param name="ntUserName">the nt logon name</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.UserDBPasswordManager.LookUpUser(System.String,System.String@,System.String@,System.String@)">
            <summary>
             Gets the db logon and password from the nt user, suitable for calling by interactive programs only
            </summary>
            <param name="dbUser">OUT db user</param>
            <param name="password">OUT db password</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:EQTG.Database.Helper.getMethodFromClass``1(``0,System.String,System.Object[])">
            <summary>
            Get a method from an object.
            Updated 20090330 to search by argument list as well as name, so it can cope with overloaded method names.
            </summary>
            <typeparam name="TObj"></typeparam>
            <param name="obj"></param>
            <param name="methodName"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Database.WrapCommand`1.Invoke(EQTG.Database.InvokeDelegate{`0})">
            <summary>
            Invokes the specified delegate command and returns the response
            </summary>
            <param name="command">The command.</param>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.Application.AppCommandAttribute">
            <summary>
            Represents an application command, or appcommand.
            </summary>
            <remarks>
            <para>An appcommand can be executed from the telnet interface or from the command line.
            All appcommands are also command-line parameters.</para>
            
            <para>When an appcommand is executed, its handler is called and passed an array containing
            the command's name followed by any parameters passed to the command.</para>
            
            <para>Appcommands are managed by the <see cref="T:EQTG.General.Application.AppCommander"/> class.</para>
            </remarks>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.#ctor">
            <summary>
            Constructs an appcommand
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs an appcommand
            </summary>
            <param name="category">Command category, e.g. database</param>
            <param name="name">Command name, e.g. debug_db</param>
            <param name="description">Helpful one-line description of this command</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.#ctor(System.String,System.String,System.String,EQTG.General.Application.AppCommandModifier)">
            <summary>
            Constructs an appcommand
            </summary>
            <param name="category">Command category, e.g. database</param>
            <param name="name">Command name, e.g. debug_db</param>
            <param name="description">Helpful one-line description of this command</param>
            <param name="isContextSensitive">Determines if the command requires context to execute</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.CompareTo(System.Object)">
            <summary>
            IComparable.CompareTo implementation.
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current
            <see cref="T:EQTG.General.Application.AppCommandAttribute"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current 
            <see cref="T:EQTG.General.Application.AppCommandAttribute"/>.</param>
            <returns>true if the specified <see cref="T:System.Object"/> is equal to the current
            <see cref="T:EQTG.General.Application.AppCommandAttribute"/>; otherwise, false.</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.GetHashCode">
            <summary>
            Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures 
            like a hash table.
            </summary>
            <returns>A hash code for the current <see cref="T:EQTG.General.Application.AppCommandAttribute"/>.</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.Matches(System.String)">
            <summary>
            Checks whether this appcommand matches the command name provided.
            </summary>
            <remarks>
            The match is case-sensitive, but the internal command name is always lower-case.
            </remarks>
            <param name="name">Command name to check</param>
            <returns>true if this command's name matches the name passed, or false otherwise</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommandAttribute.SimilarTo(System.String)">
            <summary>
            Checks whether this appcommand's name is similar to the command name provided.
            </summary>
            <remarks>
            <para>This method is used when the user types an invalid command name, to generate a list 
            of commands similar to what the user typed.</para>
            
            <para>The match is case-sensitive, but the internal command name is always lower-case.</para>
            </remarks>
            <param name="name">Command name to check</param>
            <returns>true if this command's name is similar to the name passed, or false otherwise</returns>
        </member>
        <member name="P:EQTG.General.Application.AppCommandAttribute.Category">
            <summary>
            Command category, e.g. database
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandAttribute.Name">
            <summary>
            Command name, e.g. debug_db
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandAttribute.Description">
            <summary>
            Helpful one-line description of this command
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandAttribute.Modifiers">
            <summary>
            A Modifier specifies a modification to the way an AppCommand is executed
            </summary>
        </member>
        <member name="F:EQTG.General.Application.AppCommandModifier.None">
            <summary>
            Default Modifier
            </summary>
        </member>
        <member name="F:EQTG.General.Application.AppCommandModifier.ContextSensitive">
            <summary>
            A ContextSensitive app command will be invoked with an extra argument - an AppCommandProcessor
            to provide context in which to run the command
            </summary>
        </member>
        <member name="T:EQTG.General.Application.UnknownAppCommandException">
            <summary>
            The exception that is thrown when an unknown app command name is encountered
            </summary>
        </member>
        <member name="T:EQTG.General.Application.AppCommander">
            <summary>
            Class to manage AppCommand objects.
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.Register(EQTG.General.Application.AppCommandAttribute,System.Reflection.MethodInfo)">
            <summary>
            Registers an AppCommand with this object
            </summary>
            <param name="cmd">AppCommand object to register</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.IgnoreThisAssembly(System.Reflection.AssemblyName)">
            <summary>
            Predicate indicating if this assembly should not be registered
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.RegisterAssembly(System.Reflection.Assembly)">
            <summary>
            Registers all the AppCommands declared in an assembly and any assemblies referenced
            by that assembly.
            </summary>
            <param name="assembly">Assembly containing one or more AppCommandAttributes</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.Unregister(EQTG.General.Application.AppCommandAttribute)">
            <summary>
            Unregisters an AppCommand from this object
            </summary>
            <param name="cmd">AppCommand object to unregister</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.UnregisterAssembly(System.Reflection.Assembly)">
            <summary>
            Unregisters all the AppCommands declared in an assembly
            </summary>
            <param name="assembly">Assembly containing one or more AppCommandAttributes</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.TryExecute(EQTG.General.Application.AppCommandLineProcessor,System.Object[])">
            <summary>
            Locates the appropriate AppCommand given the command line provided, and executes it
            </summary>
            <param name="args">Array of parameters to pass to the handler. The first element is always
            <param name="context">Provides the context for ContextSensitive app commands</param>
            the command name as the user typed it.</param>
            <returns>true if the AppCommand could be located and executed, or false otherwise</returns>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.Execute(System.Object[])">
            <summary>
            For compatibility with older interfaces
            </summary>
            <param name="context"></param>
            <param name="args"></param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.Execute(EQTG.General.Application.AppCommandLineProcessor,System.Object[])">
            <summary>
            Locates the appropriate AppCommand given the command line provided, and executes it
            </summary>
            <remarks>Throws UnknownAppCommandException if provided an unknown command</remarks>
            <param name="args">Array of parameters to pass to the handler. The first element is always
            the command name as the user typed it.</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.ExecuteFromParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Walks the CommandParameterList provided and attempts to execute each parameter as an
            AppCommand. The values associated with each parameter are passed to the AppCommand
            that corresponds to that parameter.
            
            If a parameter in the list does not match any known AppCommand it is ignored.
            </summary>
            <param name="cpl">Command parameter list</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.ExecuteFromParameters(EQTG.General.Application.AppCommandLineProcessor,EQTG.General.Application.CommandParameterList)">
            <summary>
            Walks the CommandParameterList provided and attempts to execute each parameter as an
            AppCommand. The values associated with each parameter are passed to the AppCommand
            that corresponds to that parameter.
            
            If a parameter in the list does not match any known AppCommand it is ignored.
            </summary>
            <param name="context">Shell instance to pass to context-sensitive appcommands</param>
            <param name="cpl">Command parameter list</param>
        </member>
        <member name="M:EQTG.General.Application.AppCommander.RegisterCommandsInUsage(EQTG.General.Application.UsageParameters)">
            <summary>
            Registers this object's AppCommands with the UsageParameters provided
            </summary>
            <param name="usage">UsageParameters object in which to register</param>
        </member>
        <member name="F:EQTG.General.Application.AppCommander.ourAssemblies">
            <summary>
            A hash storing assembly names - used to decide if an assembly has already been processed or not
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommander.Commands">
            <summary>
            List of appcommands that this AppCommander knows about. Each element is an
            AppCommand object.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.AppCommandEventArgs">
            <summary>
            Provides data for the AppCommander.ExecuteCommand event
            </summary>
        </member>
        <member name="M:EQTG.General.Application.AppCommandEventArgs.#ctor(EQTG.General.Application.AppCommandLineProcessor,System.Collections.IList)">
            <summary>
            Constructs an AppCommandEventArgs
            </summary>
            <param name="context">AppCommandLineProcessor passed to AppCommander.Execute 
            if specified, otherwise the value of AppCommandLineProcessor.Current. 
            Can be null.</param>
            <param name="arguments">List of arguments passed to AppCommander.Execute</param>
        </member>
        <member name="P:EQTG.General.Application.AppCommandEventArgs.Context">
            <summary>
            AppCommandLineProcessor passed to AppCommander.Execute 
            if specified, otherwise the value of AppCommandLineProcessor.Current. 
            Can be null.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandEventArgs.Arguments">
            <summary>
            List of arguments passed to AppCommander.Execute
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandEventArgs.Name">
            <summary>
            Command name. This is the value of the first argument.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.AppCommandEventArgs.Handled">
            <summary>
            Indicates whether an event handler has handled the app command
            </summary>
            <remarks>In your event handler, check if Handled is already set.
            If so, don't attempt to handle it. Otherwise, set Handled to true 
            if your event handler handles the app command.</remarks>
        </member>
        <member name="T:EQTG.General.Application.ExecuteCommandEventHandler">
            <summary>
            Represents the method that will handle the ExecuteCommand event of AppCommander.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ApplicationInformation">
            <summary>
            Extracts basic information for display
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ApplicationInformation.BasicInformation(EQTG.General.Application.CommandParameterList)">
            <summary>
            Create a string representation of basic information about process, CLR and command parameters
            </summary>
            <param name="parameterList">Parameter list</param>
            <returns>String representation of basic information</returns>
        </member>
        <member name="M:EQTG.General.Application.ApplicationInformation.BasicStartupInformation(System.String,EQTG.General.Application.CommandParameterList)">
            <summary>
            Create a string representation of basic information about process, CLR and command parameters
            Includes the startup time and name
            </summary>
            <param name="appName">Application name</param>
            <param name="paramList">Parameter list</param>
            <returns>String representation of startup information</returns>
        </member>
        <member name="F:EQTG.General.Application.ApplicationInformation.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ApplicationServer.IActiveApplicationComponent">
            <summary>
            An IActiveApplicationComponent is used by threads to ensure they provide the moethods that the
            application server needs to start and stop things gracefully
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IActiveApplicationComponent.Start">
            <summary>
            Start an active component should return immeadiately
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IActiveApplicationComponent.Stop">
            <summary>
            Stop an active component should return immeadiately
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IActiveApplicationComponent.Join">
            <summary>
            Join against active component after a stop(). Should return when the component is not longer active
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider">
            <summary>
            An interface through which application components access services of the application container
            
            Your application container implements this interface to handle adding service components to the application
            and ensuring that services can find each other
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.GetApplicationComponent(System.String)">
            <summary>
            Returns the specified component from our container
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.AddComponent(EQTG.General.Application.ApplicationServer.IApplicationComponent)">
            <summary>
            Adds a new component to the application container
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.RemoveComponent(EQTG.General.Application.ApplicationServer.IApplicationComponent)">
            <summary>
            This removes a component from the application container. If all references to it are
            removed it will be garbage collected.
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.GetRawParameterVerbose(System.String)">
            <summary>
            Used to read a command line parameter and print out the read value to the log file if it is not blank
            </summary>
            <param name="param"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.GetIntParameter(System.String,System.Int32@)">
            <summary>
            Used to read a command line parameter that is initialy set to a defaulted value
            </summary>
            <param name="paramName"></param>
            <param name="param"></param>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.GetStringParameter(System.String,System.String@)">
            <summary>
            Used to read a command line parameter that is initially set to a defaulted value
            </summary>
            <param name="paramName"></param>
            <param name="param"></param>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.GetDoubleParameter(System.String,System.Double@)">
            <summary>
            Used to read a command line parameter that is initially set to a defaulted value
            </summary>
            <param name="paramName"></param>
            <param name="param"></param>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.GetTimeSpanParameter(System.String,System.TimeSpan@)">
            <summary>
            Used to read a command line parameter that is initially set to a defaulted vaule
            </summary>
            <param name="paramName"></param>
            <param name="param"></param>
        </member>
        <member name="M:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.LogicalNameAndNamespace">
            <summary>
            Returns the Logical Name and Namespace for the application
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.CommandParameterList">
            <summary>
            Returns the command parameter list
            </summary>
        </member>
        <member name="P:EQTG.General.Application.ApplicationServer.IApplicationServiceProvider.BinaryName">
            <summary>
            Convenience to help us locate our performance counters
            </summary>
        </member>
        <member name="T:EQTG.General.Application.CommandParameterList">
            <summary>
            Represents a list of command parameters.
            </summary>
            <remarks>
            <para>These parameters may be sourced from the registry, command line or AppSettings.
            Use as an alternative to the <see cref="M:System.Environment.GetCommandLineArgs"/> method.</para>
            
            <para>Reading operation includes tokenising of the arguments, with '-' as the indication of a new argument.
            There is currently no support for 'default' arguments, such as used by grep. All arguments MUST use the '-' character
            if read from the command line. Registry parsing cannot support this.</para>
            
            <para>Stores the name of the binary, since this is the first argument in the environment parameter list.</para>
            
            <para>Typically invoke one of the Parse methods and store the resultant <see cref="T:EQTG.General.Application.CommandParameterList"/>.</para>
            </remarks>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.#ctor">
            <summary>
            Private constructor. Use static factory methods
            </summary>
        </member>
        <member name="F:EQTG.General.Application.CommandParameterList.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.GetArg(System.String,System.String)">
            <summary>
            Access the single string value for a parameter specified by name.
            If the parameter does not exist then a default value will be returned.
            </summary>
            <param name="paramName">Name of the parameter</param>
            <param name="defaultValue">Value to return if the parameter is not present</param>
            <returns>String value of the parameter</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.GetArg(System.String)">
            <summary>
            Access the single string value for a parameter specified by name.
            If the parameter does not exist then an empty string will be returned.
            </summary>
            <param name="paramName">Name of the parameter</param>
            <returns>String value of the parameter</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.GetArgs(System.String)">
            <summary>
            Access the full list of values for a parameter specified by name.
            </summary>
            <param name="paramName">Name of the parameter</param>
            <returns>The found parameter object or null</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.HasArg(System.String)">
            <summary>
            Check if the named parameter is present in this command parameter list
            </summary>
            <param name="paramName">Name of the parameter to locate</param>
            <returns>True if the specified parameter is present</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.IndexOfArg(System.String)">
            <summary>
            Return the index of the given arg.
            </summary>
            <param name="paramName">Name of the parameter to locate</param>
            <returns>the index of the paramter within the collection</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.BinaryName">
            <summary>
            Name of this binary
            </summary>
            <returns>Name of the binary running</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.BinaryNameWithoutExtension">
            <summary>
            Name of the binary without an extension
            </summary>
            <returns>Name of the binary without the .exe extension</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.CopySubset(System.String)">
            <summary>
            Creates a new command parameter list consisting of all parameters whose names start
            with the given prefix
            </summary>
            <param name="prefix">Prefix to look for</param>
            <returns>A new CommandParameterList</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgsFromRegistry(Microsoft.Win32.RegistryKey)">
            <summary>
            Read command parameters from a registry key.
            </summary>
            <remarks>
            Parameters are specified as string values in the registry. The parameter's name
            is taken from the name of the string value, and the string value's value is treated
            as a list of parameter values separated by spaces.
            </remarks>
            <note>
            Use quotes (") around the registry string if you want it to be treated as a single value.
            </note>
            <param name="key"><see cref="T:Microsoft.Win32.RegistryKey"/> to read the command parameters from.</param>
            <returns>A new CommandParameterList</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgsFromConfigurationAppSettings(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Create command parameters from AppSettings.
            Useful for e.g. ASP.NET apps.
            </summary>
            <param name="appSettings">App Settings to parse args from</param>
            <returns>CommandParameterList parsed from appSettings</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgsFromConfigurationAppSettings">
            <summary>
            Create command parameters from AppSettings. Use the default app settings for the application
            </summary>
            <returns>CommandParameterList parsed from appSettings</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgs(System.String[])">
            <summary>
            Parse command arguments from a string array
            </summary>
            <param name="args">String Array of arguments</param>
            <returns>A new CommandParameterList</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.AddParameter(EQTG.General.Application.CommandParameterList,System.String,System.Collections.ArrayList,EQTG.General.Application.CommandParameterSource)">
            <summary>
            Convenience method to encapsulate the addition of a command parameter.
            </summary>
            <param name="commandParameterList">The list the current parameter will be added to</param>
            <param name="name">name of the parameter</param>
            <param name="values">values of the parameter</param>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgsFromString(System.String)">
            <summary>
            Parse arguments from a string
            </summary>
            <param name="cmdLineText">String text</param>
            <returns>CommandParameterList</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgsFromCommandLine">
            <summary>
            Parse arguments from system environment text
            </summary>
            <returns>New Command Parameter List</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ParseArgsFromCommandLine(System.String[])">
            <summary>
            Parse arguments from parameters provided
            </summary>
            <returns>New Command Parameter List</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.LogCommandParameterListToDiagnostics">
            <summary>
            This method writes each of our command parameters to the Diagnostics for this class.
            
            This ensures that we know exactly what parmeters were used to start an application since
            there are so many that can cause problems e.g. -provider in EQTG.Database modules.
            </summary>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.ToString">
            <summary>
            Override string representation
            </summary>
            <returns>String representation of command parameters</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>A new object that is a copy of this instance.</returns>
        </member>
        <member name="M:EQTG.General.Application.CommandParameterList.Concatenate(EQTG.General.Application.CommandParameterList)">
            <summary>
            Returns the concatenated contents of a command parameter list to an original
              one, replacing the source command parameters where the same.
            </summary>
            <param name="listToAppend">the new list</param>
            <returns>the concatanation of both command parameter lists</returns>
        </member>
        <member name="F:EQTG.General.Application.CommandParameterList.myBinaryName">
            <summary>
            Storage for the binary name
            </summary>
        </member>
        <member name="F:EQTG.General.Application.CommandParameterList.OurNonDisclosableParameters">
            <summary>
            List of non-disclosable parameters - i.e. passwords!
            </summary>
        </member>
        <member name="P:EQTG.General.Application.CommandParameterList.NonDisclosableParameters">
            <summary>
            Static set of parameters we will not disclose.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.CommandParameter">
            <summary>
            Command parameter as read from the environment, command line, registry or elsewhere.
            </summary>
            <remarks>
            <para>A parameter can be specified multiple times and therefore have multiple values.
            These are stored internally as an <see cref="T:System.Collections.ArrayList"/>.</para>
            <para>To access the parameter's values as a parsed list, use <see cref="P:EQTG.General.Application.CommandParameter.Values"/>. To
            access the parameter's value as a single string, without parsing, use <see cref="P:EQTG.General.Application.CommandParameter.Text"/>.</para>
            </remarks>
        </member>
        <member name="M:EQTG.General.Application.CommandParameter.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.CommandParameter"/> class.
            </summary>
            <param name="name">Name of the parameter</param>
        </member>
        <member name="M:EQTG.General.Application.CommandParameter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.CommandParameter"/> class.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="text">Parameter value as text</param>
            <remarks><c>text</c> is stored in the <see cref="P:EQTG.General.Application.CommandParameter.Text"/> property, then parsed 
            using <see cref="M:EQTG.General.BasicTypes.StringUtils.TokeniseCommandLine(System.String)"/> and stored in the 
            <see cref="P:EQTG.General.Application.CommandParameter.Values"/> property.</remarks>
        </member>
        <member name="M:EQTG.General.Application.CommandParameter.#ctor(System.String,System.Collections.ICollection)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.CommandParameter"/> class.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="values">List of parameter values</param>
            <remarks>The <c>values</c> list is copied to the <see cref="P:EQTG.General.Application.CommandParameter.Values"/>
            property, then concatenated and stored in the <see cref="P:EQTG.General.Application.CommandParameter.Text"/> property.</remarks>
        </member>
        <member name="M:EQTG.General.Application.CommandParameter.#ctor(System.String,System.Collections.ICollection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.CommandParameter"/> class.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="values">List of parameter values</param>
            <param name="text">Parameter value as text</param>
            <remarks>The <c>values</c> list is copied to the <see cref="P:EQTG.General.Application.CommandParameter.Values"/>
            property, and <c>text</c> is stored in the <see cref="P:EQTG.General.Application.CommandParameter.Text"/> property.</remarks>
        </member>
        <member name="M:EQTG.General.Application.CommandParameter.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>A new object that is a copy of this instance.</returns>
        </member>
        <member name="F:EQTG.General.Application.CommandParameter.myArgName">
            <summary>
            Storage for the argument name
            </summary>
        </member>
        <member name="F:EQTG.General.Application.CommandParameter.myArgValues">
            <summary>
            Storage for the list of argument values
            </summary>
        </member>
        <member name="F:EQTG.General.Application.CommandParameter.myParameterSource">
            <summary>
            Indicates the origin of this command line parameter.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.CommandParameter.Name">
            <summary>
            Gets the parameter's name.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.CommandParameter.Values">
            <summary>
            Gets a list containing the parameter's values.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.CommandParameter.Text">
            <summary>
            Gets the full text of the parameter's values.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.CommandParameter.Source">
            <summary>
            Returns the source of the command parameter
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ConsoleCommandProcessor">
            <summary>
            Lets a user type app commands into an application console window.
            </summary>
            <remarks>
            <example>The simplest use of this class would is:
            <code>
            ConsoleCommandProcessor cli = new ConsoleCommandProcessor();
            cli.Prompt = "MyApplicationName";
            
            // Start processing commands and wait until user types exit
            cli.Start().Join();
            </code></example>
            </remarks>
        </member>
        <member name="F:EQTG.General.Application.ConsoleCommandProcessor.myThread">
            <summary>
            Thread used to process commands entered by the user
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.#ctor">
            <summary>
            Constructore - sets the prompt to CLI by default
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.#ctor(EQTG.General.Application.AppCommandLineProcessor)">
            <summary>
            Constructore - sets the prompt to CLI by default
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.#ctor(EQTG.General.Diagnostic.DiagnosticsMethodsBase)">
            <summary>
            
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.#ctor(EQTG.General.Application.AppCommandLineProcessor,EQTG.General.Diagnostic.DiagnosticsMethodsBase)">
            <summary>
            
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.Init">
            <summary>
            Generic Initialisation of this component
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.Start">
            <summary>
            Starts the thread which handles this shell
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.Stop">
            <summary>
            Requests that the shell's thread exits and waits for it to do so
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.Join">
            <summary>
            Wait for the processors thread to exit before returning
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.ThreadProc">
            <summary>
            Simple command processing loop
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.ReadLine">
            <summary>
            Implement ReadLine to get input from the console
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.Write(System.String)">
            <summary>
            Implement Write to send input to the console
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:EQTG.General.Application.ConsoleCommandProcessor.Authenticate(System.String@)">
            <summary>
            Work in progress
            </summary>
            <param name="userName"></param>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.Application.ConsoleEvent">
            <summary>
            Console event that has occurred. 
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ConsoleEventHandler">
            <summary>
            Handler to be called when a console event occurs.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ConsoleHandler">
            <summary>
            Handler for console events. Use this to link up to appropriate functions
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ConsoleHandler.AddConsoleEventHandler(EQTG.General.Application.ConsoleEventHandler)">
            <summary>
            Function to add the handler
            </summary>
            <param name="handler">Handler function</param>
        </member>
        <member name="M:EQTG.General.Application.ConsoleHandler.SetConsoleCtrlHandler(EQTG.General.Application.ConsoleEventHandler,System.Boolean)">
            <summary>
            Imported WIN32 function for console handling
            </summary>
        </member>
        <member name="F:EQTG.General.Application.ConsoleHandler.myConsoleEventHandlers">
            <summary>
            Store for all handlers to ensure they don't get garbage collected
            </summary>
        </member>
        <member name="T:EQTG.General.Application.DatabaseAppCommandReader">
            <summary>
            Utility to read command parameters from applicationFlags database table
            </summary>
        </member>
        <member name="T:EQTG.General.Application.DBAppSession">
            <summary>
            Class to wrap entries into database table ETSsession and to store the ETS session id returned by the trigger
            </summary>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.#ctor(EQTG.Database.DBConnectionDetails)">
            <summary>
            C'tor
            </summary>
            <param name="details">Database connection details</param>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.#ctor(EQTG.Database.DBConnectionDetails,EQTG.Database.IDbFactory)">
            <summary>
            C'tor
            </summary>
            <param name="details">Database connection details</param>
            <param name="factory">Option factory - can be null</param>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.Start">
            <summary>
            Start DB App Session (register in database)
            </summary>
            <param name="userName">User name</param>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.Start(System.String)">
            <summary>
            Start DB App Session (register in database)
            </summary>
            <param name="userName">User name</param>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.Start(System.String,System.String)">
            <summary>
            Start DB App Session (register in database)
            </summary>
            <param name="appName">Application name</param>
            <param name="userName">User name</param>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.Start(System.String,System.String,System.Int32)">
            <summary>
            Start DB App Session (register in database)
            </summary>
            <param name="appName">Application name</param>
            <param name="userName">User name</param>
            <param name="telnetPort">Port number of Telnet server</param>
        </member>
        <member name="M:EQTG.General.Application.DBAppSession.Stop">
            <summary>
            Indicate that this has ended in the database
            </summary>
        </member>
        <member name="F:EQTG.General.Application.DBAppSession.OurDiagnostics">
            <summary>
            Class diagnostics instance.
            </summary>
        </member>
        <member name="F:EQTG.General.Application.DBAppSession.myDbFactory">
            <summary>
            Database factory interface to create database connections and queries
            </summary>
        </member>
        <member name="F:EQTG.General.Application.DBAppSession.myConnectionDetails">
            <summary>
            Database details
            </summary>
        </member>
        <member name="F:EQTG.General.Application.DBAppSession.mySessionId">
            <summary>
            Unique ETS session id as returned from the database trigger
            </summary>
        </member>
        <member name="P:EQTG.General.Application.DBAppSession.DBFactory">
            <summary>
            DBFactory property. Will default to DBSelector.Factory otherwise
            </summary>
        </member>
        <member name="P:EQTG.General.Application.DBAppSession.SessionId">
            <summary>
            Unique Session ID prioperty as assigned by the ETSsession trigger
            </summary>
        </member>
        <member name="T:EQTG.General.Application.DRMSUser">
            <summary>
            Wraps (simply) the CDM_employees table in the DRMS database
            </summary>
        </member>
        <member name="M:EQTG.General.Application.DRMSUser.#ctor(System.Data.IDataReader)">
            <summary>
            Constructor - Builds a DRMSUser object from teh results of a query against the CDM_employees table
            </summary>
            <param name="reader">An IDataReader derived object which contains the results of a query against the CDM_employees table</param>
        </member>
        <member name="M:EQTG.General.Application.DRMSUser.fromString(System.String)">
            <summary>
            Helper function to convert a strinf value to the appropriate EmployeeType
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.DRMSUser.findUserFromName(System.String)">
            <summary>
            Lookup the correct DRMSUser object from the name as found in the l_name field of CDM_employees
            </summary>
            <param name="name">Name of user</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.DRMSUser.findUserFromSoeID(System.String)">
            <summary>
            Lookup the correct DRMSUser object from the soeid as found in the f_name field of the CDM_employees table
            </summary>
            <param name="soe"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.DRMSUser.findUserFromEmpId(System.Int32)">
            <summary>
            Lookup the correct DRMSUser object from the database id as found in the emp_id field of the CDM_emplpoyees table.
            </summary>
            <param name="empId"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.DRMSUser.initUsers(EQTG.General.Application.CommandParameterList)">
            <summary>
            Called by an application to Initialise the list of users
            </summary>
            <param name="someParams">A Command parameter list which has DRMS database connection information</param>
        </member>
        <member name="T:EQTG.General.Application.DRMSUser.EmployeeType">
            <summary>
            Enum representing the values of the emp_type column in CDM_employees
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EnvironmentVariables.ShowStackTrace">
            <summary>
            Name of the environment variable that determines if an <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/> shows 
            a stack trace when an appCommand generates an exception.
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EnvironmentVariables.ShouldExitNow">
            <summary>
            Name of the environment variable that determines if an <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/>
            should exit.
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EnvironmentVariables.Echo">
            <summary>
            Name of the environment variable that determines if an <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/>
            echoes commands.
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EnvironmentVariables.OurDiagnostics">
            <summary>
            Class wide diagnostics
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.EnvironmentVariables"/> class.
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.#ctor(EQTG.General.Application.EnvironmentVariables)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Application.EnvironmentVariables"/> class that
            inherits its initial values from another instance.
            </summary>
            <param name="inheritFrom"><see cref="T:EQTG.General.Application.EnvironmentVariables"/> from which initial
            values are copied.</param>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the environment variables.
            </summary>
            <remarks>
            The enumerator returned provides objects of type <see cref="T:System.Collections.DictionaryEntry"/>.
            </remarks>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the 
            environment variables.</returns>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.Export(System.String)">
            <summary>
            Marks a variable to be exported to <see cref="T:EQTG.General.Application.EnvironmentVariables"/> that inherit
            from this instance.
            </summary>
            <param name="envKey">Name of the variable to export</param>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.IsExported(System.String)">
            <summary>
            Returns a value indicating whether a variable is to be exported to 
            <see cref="T:EQTG.General.Application.EnvironmentVariables"/> that inherit from this instance.
            </summary>
            <param name="envKey">Variable name</param>
            <returns>true if the variable is exported, or false otherwise</returns>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.GetValue(System.String)">
            <summary>
            Gets a variable's value.
            </summary>
            <param name="envKey">Variable name</param>
            <returns>Variable's value, or null if the variable does not exist</returns>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.SetValue(System.String,System.Object)">
            <summary>
            Sets a variable's value.
            </summary>
            <param name="envKey">Variable name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.Remove(System.String)">
            <summary>
            Removes a variable from the list.
            </summary>
            <param name="envKey">Name of the variable to remove.</param>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.SubstituteValues(System.String)">
            <summary>
            Searches the string for environment variables and replaces them with their
            values from the environment.
            </summary>
            <remarks>
            An environment variable is recognised by the following rules:
            <list type="bullet">
            	<item>
            		<description>A $ sign that is not preceded by one or more \, followed by a letter or underscore, followed by letters, digits and underscores</description>
            	</item>
            	<item>
            		<description>A $ sign that is not preceded by one or more \, followed by (, followed by one or more characters of any type, followed by ). The name of the variable is the text enclosed in the brackets.</description>
            	</item>
            </list>
            \$ is replaced by $ and no variable is expanded, \\$ is replaced by \$ etc.
            </remarks>
            <param name="text">Text to search and replace environment variables</param>
            <returns>Expanded text</returns>
        </member>
        <member name="M:EQTG.General.Application.EnvironmentVariables.ParseNames(System.String)">
            <summary>
            Gets the names of environment variables referred to in the string provided.
            </summary>
            <param name="text">Text to search for environment variables</param>
            <remarks>Uses the same parsing rules as <see cref="M:EQTG.General.Application.EnvironmentVariables.SubstituteValues(System.String)"/>.</remarks>
            <returns>Array of variable names</returns>
        </member>
        <member name="P:EQTG.General.Application.EnvironmentVariables.UndelimitedRegex">
            <summary>
            Regular expression for a variable that isn't bracketed. 
            i.e. $xya where 
            the first character of the variable name must be a letter or an underscore
            and the other characters can be letters, digits or underscores. 
            Escaping the $ is handled in the code
            This is static so that it only gets compiled once.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.EnvironmentVariables.DelimitedRegex">
            <summary>
            Regular expression for a variable that is bracket delimited. 
            i.e. $(xyassd) where the variable name which is delimited by the brackets and can contain any letters/digits/underscores
            Escaping the $ is handled in the code
            This is static so that it only gets compiled once.
            </summary>
        </member>
        <member name="P:EQTG.General.Application.EnvironmentVariables.Item(System.String)">
            <summary>
            A hash of strings to objects - this is used when an appCommand would otherwise need a static
            variable to access a class.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.VariableNameMatch">
            <summary>
            Internal class used to keep track of environment variable name matches within a string.
            </summary>
        </member>
        <member name="T:EQTG.General.Application.EQTGConsoleApp">
            <summary>
            Example code to show how to write a standard console app based on the EQTG framework
            Supports diagnostics and UsageParameters
            Also includes basic Database support
            
            Sample command line arguments might be..
            -S DRMS_DM1 -U eqjobs -eqPasswordDir g:\jobs\security 
            Optionally add -consoleDiagnostics local://diagnostics.xml to turn on database logging
            </summary>
        </member>
        <member name="T:EQTG.General.Application.IEQTGApplicationHost">
            <summary>
            Interface for an application implementation to get information about its host 
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.Run(System.Object)">
            <summary>
            Run method, run as instance to help storage of member variables 
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.DaemonNamespace">
            <summary>
            Daemon namespace implementation
            </summary>
            <returns>Blank - irrelevant for console app</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.GetCommandParameters">
            <summary>
            Implementation of IEQTGApplicationHost function.
            </summary>
            <returns>Command parameters as read from command line</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.GetAppSession">
            <summary>
            Implementation of IEQTGApplicationHost function.
            </summary>
            <returns>Database app session as created from command parameters</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.GetDBConnectionDetails">
            <summary>
            Implementation of IEQTGApplicationHost function.
            </summary>
            <returns>Connection details as read from command parameters</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.DBConnection">
            <summary>
            Creates a database connection using the application's default details.
            
            Equivalent to:
            	return DBSelector.Factory.Connection(GetDBConnectionDetails().ConnectionString());
            </summary>
            <returns>New object implementing IDbConnection</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGConsoleApp.DiagnosticsViews">
            <summary>
            Access to the ViewList used by the application
            </summary>
            <returns>DiagnosticViewList used by application</returns>
        </member>
        <member name="F:EQTG.General.Application.EQTGConsoleApp.myApplicationImplementation">
            <summary>
            Storage of application implementation
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGConsoleApp.myCommandParameters">
            <summary>
            Member command parameters
            See http://eqtgweb.eu.ssmb.com/Development/csharpeqtgframework.htm#commandParameters
            for more details on the CommandParameterList class
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGConsoleApp.myDbDetails">
            <summary>
            Storage for connection details (required for shutdown)
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGConsoleApp.myAppSession">
            <summary>
            Database app session
            See http://eqtgweb.eu.ssmb.com/Development/csharpeqtgframework.htm#databaseSessionLogging
            for more details on the DBAppSession
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGConsoleApp.OurDiagnostics">
            <summary>
            Standard ClassDiagnostics instance
            See http://eqtgweb.eu.ssmb.com/Development/csharpeqtg/writingDiagnostics.htm
            for more details on writing diagnostics
            </summary>
        </member>
        <member name="T:EQTG.General.Application.EQTGServiceOrConsoleApp">
            <summary>
            A 'host' class that invokes your app when run as a service or console.  
            </summary>
            <remarks>
            <para>Your Main creates it and calls <see cref="M:EQTG.General.Application.EQTGServiceOrConsoleApp.Run(System.Object)"/> in the case of a service or console.  It 
            calls your class's <see cref="M:EQTG.General.Application.EQTGServiceOrConsoleApp.Run(System.Object)"/> direct if you're a console app, or gets called back by 
            the SCM to start if its a service, and starts a thread which calls your class's 
            <see cref="M:EQTG.General.Application.EQTGServiceOrConsoleApp.Run(System.Object)"/>.</para>
            
            <para>Run with no command parameters if installed as a service.</para>
            <para>Run with -asWin32Console if you want to run as a console application instead.</para>
            </remarks>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.Run(System.Object)">
            <summary>
            Run method, run as instance to help storage of member variables 
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.RunImplementation(System.String,System.String)">
            <summary>
            Run routine. Launch the processing thead.
            </summary>
            <param name="daemonLogicalName">Logical of the daemon i.e. SpotPricePublisher</param>
            <param name="daemonNamespace">Namespace (e.g. UA/PROD)</param>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.DaemonNamespace">
            <summary>
            Daemon namespace implementation
            </summary>
            <returns>Daemon namespace</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.DoProcessing">
            <summary>
            Basic processing implementation, assumes that the Run() method of the implementation will block
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.GetCommandParameters">
            <summary>
            Implementation of IEQTGApplicationHost function.
            </summary>
            <returns>Command parameters as read from command line</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.GetAppSession">
            <summary>
            Implementation of IEQTGApplicationHost function.
            </summary>
            <returns>Database app session as created from command parameters</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.GetDBConnectionDetails">
            <summary>
            Implementation of IEQTGApplicationHost function.
            </summary>
            <returns>Connection details as read from command parameters</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.GetDaemonProcess">
            <summary>
            The Daemon Process object has loads of handy information... why hide it?
            </summary>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.DBConnection">
            <summary>
            Creates a database connection using the application's default details.
            
            Equivalent to:
            	return DBSelector.Factory.Connection(GetDBConnectionDetails().ConnectionString());
            </summary>
            <returns>New object implementing IDbConnection</returns>
        </member>
        <member name="M:EQTG.General.Application.EQTGServiceOrConsoleApp.DiagnosticsViews">
            <summary>
            Access to the ViewList used by the application
            </summary>
            <returns>DiagnosticViewList used by application</returns>
        </member>
        <member name="F:EQTG.General.Application.EQTGServiceOrConsoleApp.myApplicationImplementation">
            <summary>
            Storage of application implementation
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGServiceOrConsoleApp.myApplicationServiceImplementation">
            <summary>
            Storage of application service implementation
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGServiceOrConsoleApp.OurDiagnostics">
            <summary>
            Standard ClassDiagnostics instance
            See http://eqtgweb.eu.ssmb.com/Development/csharpeqtg/writingDiagnostics.htm
            for more details on writing diagnostics
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGServiceOrConsoleApp.myDaemonProcessImplementation">
            <summary>
            Member EQTGDaemonProcess
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGServiceOrConsoleApp.myProcessingThread">
            <summary>
            Processing thread, delegated to application implementaion
            </summary>
        </member>
        <member name="F:EQTG.General.Application.EQTGServiceOrConsoleApp.myDaemonNamespace">
            <summary>
            Namespace storage
            </summary>
        </member>
        <member name="T:EQTG.General.Application.EQTGServiceOrConsoleApp.StopCallbackDaemon">
            <summary>
            We have to derive from EQTGDaemonProcess in order to receive shutdown notification
            This class provides us a hook into the shutdown sequence
            </summary>
        </member>
        <member name="T:EQTG.General.Application.IEQTGApplication">
            <summary>
            Interface for an application to present to its host for minimal functionality
            </summary>
        </member>
        <member name="T:EQTG.General.Application.IEQTGApplicationEvents">
            <summary>
            Interface for an application implementation to receive
            extra callbacks during its container initialisation and shutdown
            </summary>
        </member>
        <member name="T:EQTG.General.Application.IEQTGServiceOrConsoleApplication">
            <summary>
            Interface for an application to present to its host for minimal functionality
            for a ServiceOrConsoleApp
            </summary>
        </member>
        <member name="M:EQTG.General.Application.IEQTGServiceOrConsoleApplication.DaemonLogicalName">
            <summary>
            Logical name of the daemon
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.IEQTGServiceOrConsoleApplication.StopProcessing">
            <summary>
            This is called to allow implementers to shut down cleanly
            </summary>
        </member>
        <member name="T:EQTG.General.Application.NamespaceDoc">
            <summary>
            <h1>App Commands</h1>
            <para>App commands allow you to attach a C# method to a command, which can be invoked 
            	from the command line, the console, a script or a telnet session. They are 
            	similar in concept to the C++ implementation, but they are done differently.</para>
            <h1>Writing your own</h1>
            <para>To create your own app command, use <see cref="T:EQTG.General.Application.AppCommandAttribute"/> on any 
            	static method. Methods can be private, public or protected as appropriate.</para>
            <code>
            [AppCommand("database", "debug_db", "Enables or disables database logging")]
            static public void DebugDBHandler(object[] args)
            </code>
            <para>In this example, the app command is called <b>debug_db</b>. In the help screen, 
            	it appears in the <b>database</b> section, and it <b>Enables or disables database 
            		logging</b>. Note that app command names aren't case-sensitive, and can be 
            	entered with or without underscores (_).</para>
            <para>The AppCommand constructor takes an optional fourth argument of type <see cref="T:EQTG.General.Application.AppCommandModifier"/>. 
            	If you use <see cref="F:EQTG.General.Application.AppCommandModifier.ContextSensitive"/> here, the C# libraries 
            	will pass your method an extra parameter of type <see cref="T:EQTG.General.Application.AppCommandLineProcessor"/>.
            	<see cref="M:EQTG.General.Application.AppCommandLineProcessor.Write(System.String)"/> is useful for writing text from your app 
            	command method. For example, when an app command is entered from a telnet 
            	session, the <see cref="M:EQTG.General.Application.AppCommandLineProcessor.Write(System.String)"/> method sends output to the same telnet session. 
            	You can also use the <see cref="T:EQTG.General.Diagnostic.ClassDiagnostics"/> class to write output 
            	according to the diagnostics configuration.</para>
            <code>
            [AppCommand("terminalIO", "cls", "Clear screen if terminal supports escape codes", AppCommandModifiers.ContextSensitive)]
            static public void CLS(AppCommandLineProcessor context, object[] args)
            {
            	context.Write("\x1b[2J");
            }
            </code>
            <para>In your application's startup code, you will need to execute any app commands 
            	that the user entered on the command line (or the registry, or the web.config, 
            	etc.):</para>
            <code>AppCommander.ExecuteFromParameters(commandLine);</code>
            <h1>App commands built into the C# libraries</h1>
            <list type="table">
            	<listheader>
            		<term>Syntax</term>
            		<description>Purpose</description>
            	</listheader>
            	<item>
            		<term>debug_db <em>enable</em></term>
            		<description>debug_db 1 enables database logging;
            			debug_db 0 disables it</description>
            	</item>
            	<item>
            		<term>help</term>
            		<description>Display list of available commands</description>
            	</item>
            	<item>
            		<term>history</term>
            		<description>Display command history</description>
            	</item>
            	<item>
            		<term>clearHistory</term>
            		<description>Clear the command history</description>
            	</item>
            	<item>
            		<term>cd</term>
            		<description>Change directory</description>
            	</item>
            	<item>
            		<term>pwd</term>
            		<description>Print the current working directory</description>
            	</item>
            	<item>
            		<term>dir <EM>directory</EM></term>
            		<description>List the directories and files in the current working or specified directory</description>
            	</item>
            	<item>
            		<term>echo</term>
            		<description>Echo arguments back to caller</description>
            	</item>
            	<item>
            		<term>source</term>
            		<description>Source a script into the processor</description>
            	</item>
            	<item>
            		<term>diag <em>className</em> <em>level</em></term>
            		<description>Configures diagnostics for class <em>className</em>.
            			<em>className</em> includes the full namespace and class name.
            					<em>level</em> is one of: fatal, error, warning, info, debug</description>
            	</item>
            	<item>
            		<term>cls</term>
            		<description>Clear screen if terminal supports escape codes</description>
            	</item>
            </list>
            <h1>Telnet</h1>
            <para>The <see cref="T:EQTG.Network.TelnetServer"/> class implements a telnet server which 
            	accepts connections, each of which runs an interactive shell for entering app 
            	commands. The <see cref="T:EQTG.Database.DBTelnetShell"/> class prompts for a user name and 
            	password, which it authenticates against the database before giving the user a 
            	prompt.</para>
            <para>To use a telnet server:</para>
            <code>
            // Construct a set of database connection details
            DBConnectionDetails db = DBConnectionDetails.CreateFromCommandParametersAndNTUser(commandLine);
            
            // Tell DBTelnetShell how to connect to the database
            DBTelnetShell.DefaultConnectionDetails = db;
            
            // Create a TelnetServer that uses the DBTelnetShell class					
            TelnetServer telnet = new TelnetServer(
            12345 /* port number */, 
            typeof(DBTelnetShell) /* typeof shell we're using */);
            					
            // Start the server
            telnet.Start();
            								
            RunTheApplication();
            										
            // Close any outstanding telnet shells
            telnet.Stop();
            </code>
            <h1>Scripting</h1>
            <para>The <see cref="T:EQTG.General.Application.ScriptCommandProcessor"/> class 
            	implements a script processor which loads files from disk and executes the 
            	contained app commands. Each app command must begin and finish on it's own 
            	line. AppCommands may not span lines. Blank lines and lines beginning with a 
            	'#' are ignored by the processor.</para>
            <para>To use a <see cref="T:EQTG.General.Application.ScriptCommandProcessor"/>:</para>
            <code>
            // Construct Script Processing component
            ScriptCommandProcessor cli = new ScriptCommandProcessor();
            // Ask the script processor to process files.
            / Each call returns when the files has been fully processed
            cli.ProcessFile("startup.es");
            cli.ProcessFile("report.es");
            	</code>
            <h1>Console</h1>
            <para>The <see cref="T:EQTG.General.Application.ConsoleCommandProcessor"/> class 
            	implements a console driven interactive shell for entering app commands.</para>
            <para>To use a <see cref="T:EQTG.General.Application.ConsoleCommandProcessor"/>:</para>
            <code>
            // Construct a ConsoleCommandProcessor
            ConsoleCommandProcessor cli = new ConsoleCommandProcessor();
            
            // Set configurable region of the prompt so user knows which application they are using
            cli.Prompt = GetApplicationName();
            
            // Start a thread in which console commands are run - do not use the console from any other thread
            cli.Start().Join();
            
            // Other processing goes here
            // ...
            
            // Once we are ready to exit the application join with the cli thread so the
            // application doesn't just die on the user - they must type 'exit'
            cli.Join();
            	</code>
            </summary>
        </member>
        <member name="T:EQTG.General.Application.ScriptCommandProcessor">
            <summary>
            Lets a user type app commands into an application console window.
            </summary>
            <remarks>
            You can use the source command from any command line interface to create a script processor and
            execute the enclosed commands.
            </remarks>
            <example>
            The simplest use of this class would is:
            <code>
            ScriptCommandProcessor cli = new ScriptCommandProcessor();
            cli.ProcessFile("Myscript.es");
            </code>
            </example>
        </member>
        <member name="F:EQTG.General.Application.ScriptCommandProcessor.myCurrentFile">
            <summary>
            During ProcessFile this reader is used to get lines from the script file
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.#ctor(EQTG.General.Application.AppCommandLineProcessor)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.ProcessFile(System.String)">
            <summary>
            Simple command processing loop
            </summary>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.ReadLine">
            <summary>
            Implement ReadLine to get input from the console
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.Write(System.String)">
            <summary>
            Implement Write to send input to the console
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.GetCommand">
            <summary>
            There is no need to write a prompt when processing the script
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Application.ScriptCommandProcessor.Authenticate(System.String@)">
            <summary>
            Work in progress
            </summary>
            <param name="userName"></param>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Application.ScriptCommandProcessor.Prompt">
            <summary>
            The prompt property is accessed after each line is processed so interactive interfaces
            can provide the user with a visual clue that more input will be accepted for
            processing. Since we are a file provide no prompt
            </summary>
        </member>
        <member name="T:EQTG.General.Application.UsageParameters">
            <summary>
            Holder and basic validator for command parameters
            </summary>
        </member>
        <member name="M:EQTG.General.Application.UsageParameters.ValidateParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Validate the supplied parameters against requirements
            </summary>
            <param name="paramList">Parameter list to check agains</param>
            <returns>True if the supplied parameters matched the required parameters</returns>
        </member>
        <member name="M:EQTG.General.Application.UsageParameters.OutputParameterInformation">
            <summary>
            Required parameters
            </summary>
        </member>
        <member name="M:EQTG.General.Application.UsageParameters.AddNewParameter(System.String,System.String,System.Boolean)">
            <summary>
            Add a parameter to check
            </summary>
            <param name="argName">Parameter name</param>
            <param name="description">Description of the parameter</param>
            <param name="mandatory">True if this parameter is mandatory</param>
            <returns>Newly created parameter info, in case anyone wants it</returns>
        </member>
        <member name="F:EQTG.General.Application.UsageParameters.DefaultInstance">
            <summary>
            Default instance for convenience
            </summary>
        </member>
        <member name="F:EQTG.General.Application.UsageParameters.myParameterList">
            <summary>
            Storage of usage parameters
            </summary>
        </member>
        <member name="F:EQTG.General.Application.UsageParameters.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.General.Application.UsageParameterInfo">
            <summary>
            Class to represent usage of a given command parameter in an application
            </summary>
        </member>
        <member name="F:EQTG.General.Application.UsageParameterInfo.myArgName">
            <summary>
            Name of argument
            </summary>
        </member>
        <member name="F:EQTG.General.Application.UsageParameterInfo.myMandatory">
            <summary>
            Storage of mandatory status
            </summary>
        </member>
        <member name="F:EQTG.General.Application.UsageParameterInfo.myDescription">
            <summary>
            Description storage
            </summary>
        </member>
        <member name="P:EQTG.General.Application.UsageParameterInfo.Mandatory">
            <summary>
            True of this argument is mandatory
            </summary>
        </member>
        <member name="P:EQTG.General.Application.UsageParameterInfo.ArgName">
            <summary>
            Name of the argument
            </summary>
        </member>
        <member name="P:EQTG.General.Application.UsageParameterInfo.Description">
            <summary>
            Description of this argument
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.AverageStore">
            <summary>
            Encapsulation of keeping a running average
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.AverageStore.Add(System.Single)">
            <summary>
            Add a value to the running average
            </summary>
            <param name="f"></param>
        </member>
        <member name="F:EQTG.General.BasicTypes.AverageStore.myTotal">
            <summary>
            Total sum of items
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.AverageStore.myCount">
            <summary>
            Total number of items
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.AverageStore.myMin">
            <summary>
            Minimum value
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.AverageStore.myMax">
            <summary>
            Maximum value
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.AverageStore.Average">
            <summary>
            Return the average of the total
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.AverageStore.Max">
            <summary>
            Max value
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.AverageStore.Min">
            <summary>
            Min value
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.AverageStore.Count">
            <summary>
            Count property
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.BoolUtils">
            <summary>
            Summary description for BoolUtils.
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.BoolUtils.#ctor">
            <summary>
            This class has only static methods, hence only a private constructor
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.CharUtils">
            <summary>
            A collection of useful methods for manipulating chars.
            </summary>
            <remarks>
            Many of these functions are available in the Microsoft.VisualBasic namespace, but this
            provides an EQTG alternative.
            </remarks>
        </member>
        <member name="M:EQTG.General.BasicTypes.CharUtils.#ctor">
            <summary>
            The constructor.
            </summary>
            <remarks>
            This is private to prevent this class being instantiated.
            </remarks>
        </member>
        <member name="M:EQTG.General.BasicTypes.CharUtils.Chr(System.Int32)">
            <summary>
            Return the character of the given character value
            </summary>
            <param name="i">The character value.</param>
            <returns>The character.</returns>
        </member>
        <member name="F:EQTG.General.BasicTypes.CharUtils.Crlf">
            <summary>
            The VBCrlf, Carriage Return Line Feed string.
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.CharUtils.isNumeric(System.Char)">
            <summary>
            Determines if the character is a number.
            </summary>
            <param name="ch">The character.</param>
            <returns>A boolean.</returns>
            <remarks>
            If the given character is in between 0 and 9 then
            return true, otherwise false
            </remarks>
        </member>
        <member name="T:EQTG.General.BasicTypes.Date">
            <summary>
            Represents a date.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.Date.LATESTROVER">
            <summary>
            Used in the database to denote the latest version of an object.
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.RollingConventionFromString(System.String,System.Boolean)">
            <summary>
            Returns the <see cref="T:EQTG.General.BasicTypes.RollingConvention"/> indicated by the specified database short code.
            </summary>
            <param name="s">A rolling convention code from the database.</param>
            <returns>The <see cref="T:EQTG.General.BasicTypes.RollingConvention"/> equivalent to <paramref name="s"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s"/> is not a recognised rolling convention code.</exception>
            <remarks>
            Codes are mapped as follows:
            <list type="table">
            	<listheader>
            		<term>Database Code</term>
            		<description><see cref="T:EQTG.General.BasicTypes.RollingConvention"/></description>
            	</listheader>
            	<item>
            		<term>NON</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.NONE"/></description>
            	</item>
            	<item>
            		<term>FWD</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.FWD"/></description>
            	</item>
            	<item>
            		<term>FIM</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.FIM"/></description>
            	</item>
            	<item>
            		<term>BWD</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.BWD"/></description>
            	</item>
            	<item>
            		<term>BIM</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.BIM"/></description>
            	</item>
            	<item>
            		<term>EOM</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.EOM"/></description>
            	</item>
            	<item>
            		<term>EMp</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.EOMp"/></description>
            	</item>
            	<item>
            		<term>EMn</term>
            		<description><see cref="F:EQTG.General.BasicTypes.RollingConvention.EOMn"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="F:EQTG.General.BasicTypes.Date.LATEST">
            <summary>
            Denotes the latest version of an object.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.Date.NODATE">
            <summary>
            Used as a placeholder to represent no date.
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.BasicTypes.Date"/> class.
            </summary>
            <param name="roverDate">A date in rover8 format.</param>
            <example><code>
            Date date = new Date(20060201);
            </code></example>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.BasicTypes.Date"/> class.
            </summary>
            <param name="dt">A date.</param>
            <example><code>
            Date date = new Date(new DateTime(2006, 2, 1));
            </code></example>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.Parse(System.String)">
            <summary>
            Parses a date from string
            </summary>
            <remarks>May throw format exception</remarks>
            <param name="dateString">Date string to parse</param>
            <returns>New date</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.BasicTypes.Date"/> class.
            </summary>
            <param name="day">The day (1 through the number of days in <paramref name="month"/>).</param>
            <param name="month">The month (1 through 12).</param>
            <param name="year">The year (0 through 9999).</param>
            <example><code>
            Date date = new Date(1, 2, 2006);
            </code></example>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.ToString">
            <summary>
            Returns the date as a string in rover8 format.
            </summary>
            <returns>The date as a string in rover8 format.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication of their relative values.
            </summary>
            <param name="o">An object to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="o"/>.
            <list type="table">
            	<listheader>
            		<term>Return Value</term>
            		<description>Description</description>
            	</listheader>
            	<item>
            		<term>Less than zero</term>
            		<description>This instance is less than <paramref name="o"/>.</description>
            	</item>
            	<item>
            		<term>Zero</term>
            		<description>This instance is equal to <paramref name="o"/>.</description>
            	</item>
            	<item>
            		<term>Greater than zero</term>
            		<description>This instance is greater than <paramref name="o"/>.</description>
            	</item>
            </list>
            </returns>
            <exception cref="T:System.InvalidCastException"><paramref name="o"/> is not a <see cref="T:EQTG.General.BasicTypes.Date"/>.</exception>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.rover8">
            <summary>
            Returns the value of the <see cref="P:EQTG.General.BasicTypes.Date.Rover8"/> property.
            </summary>
            <remarks>
            Temporarily added until spot price publisher is cut over to new code.
            </remarks>
            <returns>The value of the <see cref="P:EQTG.General.BasicTypes.Date.Rover8"/> property.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="o">An object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="o"/> is an instance of <see cref="T:EQTG.General.BasicTypes.Date"/>
            and equals the value of this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.startOfMonth">
            <summary>
            Returns the value of the <see cref="P:EQTG.General.BasicTypes.Date.FirstDayOfMonth"/> property.
            </summary>
            <returns>The value of the <see cref="P:EQTG.General.BasicTypes.Date.FirstDayOfMonth"/> property.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.parseDate(System.String)">
            <summary>
            Converts the string representation of a rover8 date into its <see cref="T:EQTG.General.BasicTypes.Date"/> equivalent.
            </summary>
            <param name="dStr">A string containing a date to convert, in rover8 format.</param>
            <returns>A <see cref="T:EQTG.General.BasicTypes.Date"/> equivalent to the date contained in <paramref name="dStr"/>, or
            <see cref="F:EQTG.General.BasicTypes.Date.NODATE"/> if <paramref name="dStr"/> is not recognised as a rover8 date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.FromXmlDate(System.String)">
            <summary>
            Converts the string representation of an XML date into its <see cref="T:EQTG.General.BasicTypes.Date"/> equivalent.
            </summary>
            <param name="xmlString">A string containing a date to convert, in yyyy-MM-dd format.</param>
            <returns>A <see cref="T:EQTG.General.BasicTypes.Date"/> equivalent to the date contained in <paramref name="xmlString"/>, or
            <see langword="null"/> if <paramref name="xmlString"/> is not recognised as a date in yyyy-MM-dd format.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.ToXmlDate">
            <summary>
            Returns the date in XML format.
            </summary>
            <returns>The date in yyyy-MM-dd format.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.isValid">
            <summary>
            Returns the value of the <see cref="P:EQTG.General.BasicTypes.Date.IsValid"/> property.
            </summary>
            <returns>The value of the <see cref="P:EQTG.General.BasicTypes.Date.IsValid"/> property.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.ToDateTime">
            <summary>
            Converts the date to an equivalent <see cref="T:System.DateTime"/>.
            </summary>
            <returns>A <see cref="T:System.DateTime"/> instance equivalent to the value of this instance.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_LessThan(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Determines whether one specified <see cref="T:EQTG.General.BasicTypes.Date"/> is less than another specified <see cref="T:EQTG.General.BasicTypes.Date"/>.
            </summary>
            <param name="l">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <param name="r">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns><see langword="true"/> if <paramref name="l"/> is less than <paramref name="r"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_GreaterThan(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Determines whether one specified <see cref="T:EQTG.General.BasicTypes.Date"/> is greater than another specified <see cref="T:EQTG.General.BasicTypes.Date"/>.
            </summary>
            <param name="l">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <param name="r">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns><see langword="true"/> if <paramref name="l"/> is greater than <paramref name="r"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_LessThanOrEqual(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Determines whether one specified <see cref="T:EQTG.General.BasicTypes.Date"/> is less than or equal to another specified <see cref="T:EQTG.General.BasicTypes.Date"/>.
            </summary>
            <param name="l">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <param name="r">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns><see langword="true"/> if <paramref name="l"/> is less then or equal to <paramref name="r"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_GreaterThanOrEqual(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Determines whether one specified <see cref="T:EQTG.General.BasicTypes.Date"/> is greater than or equal to another specified <see cref="T:EQTG.General.BasicTypes.Date"/>.
            </summary>
            <param name="l">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <param name="r">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns><see langword="true"/> if <paramref name="l"/> is greater than or equal to <paramref name="r"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_Equality(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Determines whether two specified instances of <see cref="T:EQTG.General.BasicTypes.Date"/> are equal.
            </summary>
            <param name="l">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <param name="r">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns><see langword="true"/> if <paramref name="l"/> and <paramref name="r"/> represent the same date; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_Inequality(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Determines whether two specified instances of <see cref="T:EQTG.General.BasicTypes.Date"/> are equal.
            </summary>
            <param name="l">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <param name="r">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns><see langword="true"/> if <paramref name="l"/> and <paramref name="r"/> do not represent the same date; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_Addition(EQTG.General.BasicTypes.Date,System.Int32)">
            <summary>
            Adds a number of days from the date.
            </summary>
            <param name="date">Date to add to.</param>
            <param name="days">Number of days to add.</param>
            <returns>The new date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_Subtraction(EQTG.General.BasicTypes.Date,System.Int32)">
            <summary>
            Subtracts a number of days from the date.
            </summary>
            <param name="date">Date to subtract from.</param>
            <param name="days">Number of days to subtract.</param>
            <returns>The new date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.op_Subtraction(EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Subtracts a specified date from another date, yielding a time interval.
            </summary>
            <param name="date1">A <see cref="T:EQTG.General.BasicTypes.Date"/> (the minuend).</param>
            <param name="date2">A <see cref="T:EQTG.General.BasicTypes.Date"/> (the subtrahend).</param>
            <returns>A <see cref="T:System.TimeSpan"/> that is the time interval between <paramref name="date1"/> and
            <paramref name="date2"/>; that is, <paramref name="date1"/> minus <paramref name="date2"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.AddWeekdays(System.Int32)">
            <summary>
            Move forwards (or backwards if negative) by the given number of days, skipping weekends.
            </summary>
            <param name="days">Number of days to offset.</param>
            <returns>The new date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.StepWeekday(System.Boolean)">
            <summary>
            Move forward or backward one day, skipping weekends (but not other holidays).
            </summary>
            <param name="forwards">Move forward or not.</param>
            <returns>The new date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.StepWeekday">
            <summary>
            Move forward one day, skipping weekends (but not other holidays).
            </summary>
            <returns>The new date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.IsWeekend">
            <summary>
            Returns boolean indicating if this is a weekend or not
            </summary>
            <returns>Returns true if this is a weekend</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.AvoidWeekends(System.Boolean)">
            <summary>
            If this is a weekend, get moved to either Friday or the Monday.
            </summary>
            <param name="forwards">true -> Monday, false -> Friday.</param>
            <returns>The new date.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.AvoidWeekends">
            <summary>
            If this is a weekend, get moved to Monday.
            </summary>
            <returns>The new Date</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.GotoLastDayOfMonth(EQTG.General.BasicTypes.Date)">
            <summary>
            Returns the value of the <see cref="P:EQTG.General.BasicTypes.Date.LastDayOfMonth"/> property.
            </summary>
            <param name="date">A <see cref="T:EQTG.General.BasicTypes.Date"/>.</param>
            <returns>The value of the <see cref="P:EQTG.General.BasicTypes.Date.LastDayOfMonth"/> property.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.Date.NthWeekDayOfMonth(System.Int32,System.DayOfWeek,System.Int32,System.Int32)">
            <summary>
            Gets the <paramref name="n"/>th weekday of a specified month.
            </summary>
            <param name="n">The week number within <paramref name="month"/> (1 through 5).</param>
            <param name="dayNo">The day of the week.</param>
            <param name="month">The month</param>
            <param name="year">The year.</param>
            <returns>A <see cref="T:EQTG.General.BasicTypes.Date"/> representing the <paramref name="n"/>th weekday of <paramref name="month"/>.</returns>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.Today">
            <summary>
            Gets today's date.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.Rover8String">
            <summary>
            Gets the date as a string in rover8 format.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.Rover8">
            <summary>
            Gets the date as a number in rover8 format.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.IsValid">
            <summary>
            Gets a value indicating whether this instance represents a valid date.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.Year">
            <summary>
            Gets the year component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.Month">
            <summary>
            Gets the month component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.Day">
            <summary>
            Gets the day component of the date represented by this instance.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.FirstDayOfMonth">
            <summary>
            Gets the first day of the same month as the date represented by this instance.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.FirstWeekDayOfMonth">
            <summary>
            Gets the first weekday of the same month as the date represented by this instance.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.LastDayOfMonth">
            <summary>
            Gets the last day of the same month as the date represented by this instance.
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.Date.LastWeekDayOfMonth">
            <summary>
            Gets the last weekday of the same month as the date represented by this instance.
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.DateConverter">
            <summary>
            Provides a type converter to convert <see cref="T:EQTG.General.BasicTypes.Date"/> objects to and from various other representations.
            </summary>
            <remarks>
            One place this class is used is by the PropertyGrid control, to convert <see cref="T:EQTG.General.BasicTypes.Date"/>
            objects to and from <see cref="T:System.String"/>s.
            </remarks>
        </member>
        <member name="M:EQTG.General.BasicTypes.DateConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to a <see cref="T:EQTG.General.BasicTypes.Date"/>, 
            using the specified context.
            </summary>
            <remarks>
            As implemented in this class, this method returns <see langword="true"/> only if <paramref name="sourceType"/>
            equals <see cref="T:System.String"/>.
            </remarks>
            <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="sourceType">A <see cref="T:System.Type"/> that represents the type you want to convert from.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.DateConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to a <see cref="T:EQTG.General.BasicTypes.Date"/>, using the specified context and culture information.
            </summary>
            <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="culture">The <see cref="T:System.Globalization.CultureInfo"/> to use as the current culture.</param>
            <param name="value">The <see cref="T:System.String"/> to convert.</param>
            <returns>A <see cref="T:EQTG.General.BasicTypes.Date"/> that represents the converted value.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.DateConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the <see cref="T:EQTG.General.BasicTypes.Date"/> to the specified type,
            using the specified context.
            </summary>
            <remarks>
            As implemented in this class, this method returns <see langword="true"/> only if <paramref name="destinationType"/>
            equals <see cref="T:System.String"/> or <see cref="T:System.ComponentModel.Design.Serialization.InstanceDescriptor"/>. <see cref="T:System.ComponentModel.Design.Serialization.InstanceDescriptor"/> is used
            by the Windows Forms designer to generate code that calls the <see cref="T:EQTG.General.BasicTypes.Date"/> constructor.
            </remarks>
            <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="destinationType">A <see cref="T:System.Type"/> that represents the type you want to convert to.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.DateConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given <see cref="T:EQTG.General.BasicTypes.Date"/> to the specified type, using the specified context and culture information.
            </summary>
            <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo"/> object. If <see langword="null"/> is passed,
            the current culture is asumed.</param>
            <param name="value">The <see cref="T:EQTG.General.BasicTypes.Date"/> to convert.</param>
            <param name="destinationType">The <see cref="T:System.Type"/> to convert the <paramref name="value"/> 
            parameter to.</param>
            <returns>An <see cref="T:System.Object"/> that represents the converted value.</returns>
        </member>
        <member name="T:EQTG.General.BasicTypes.DBConvert">
            <summary>
            Class used for converting objects to strings for embedding in SQL statements
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.DBConvert.ToString(System.Object)">
            <summary>
            Converts the specified object into a string suitable for embedding into an SQL statement
            </summary>
            <param name="obj">Object to convert</param>
            <remarks>
            	NB: the list below doesn't show in either Code Comments or the Object Browser.
            	I don't know why I even bothered.
            	<list type="bullet">
            		<item>
            			<term>char</term>
            			<description>Character surrounded by single quotes</description>
            		</item>
            		<item>
            			<term>DateTime</term>
            			<description>Date/time string in Sybase format (see TimeUtils.ToDatabase)</description>
            		</item>
            		<item>
            			<term>string</term>
            			<description>String, with any single quotes replaced by two single quotes, surrounded
            				by single quotes</description>
            			</item>
            		<item>
            			<term>DBLiteral</term>
            			<description>Value of DBLiteral.Text</description>
            		</item>
            		<item>
            			<term>DBNull</term>
            			<description>null</description>
            		</item>
            		<item>
            			<term>All other types</term>
            			<description>Result of obj.ToString()</description>
            		</item>
            	</list>
            </remarks>
        </member>
        <member name="T:EQTG.General.BasicTypes.DBLiteral">
            <summary>
            Use this class to send text through DBConvert.ToString without having it converted to a quoted string
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.DBLiteral.#ctor">
            <summary>
            Constructs an empty DBLiteral
            </summary>
            <remarks>
            Set the Text property to control the text
            </remarks>
        </member>
        <member name="M:EQTG.General.BasicTypes.DBLiteral.#ctor(System.String)">
            <summary>
            Constructs a DBLiteral with the specified text
            </summary>
            <param name="text">Text for this DBLiteral</param>
        </member>
        <member name="P:EQTG.General.BasicTypes.DBLiteral.Text">
            <summary>
            Gets or sets the text
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TenorExpressionMatcher">
            <Summary>
            Base Class for matching a Tenor using regular expressions. This class uses RegEx to parse
            the passed in string to check for matches. If matches are found it will call the abstract method
            Process so the derived class can process the matches
            </Summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TenorExpressionMatcher.#ctor(System.String)">
            <summary>
            Constructor for the class. Creates a new RegEx object
            </summary>
            <param name="regExp">The string that contains the regular expression to use
            </param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TenorExpressionMatcher.Match(EQTG.General.BasicTypes.IRTenor)">
            <summary>
            Tries to match the Tenor string against the regular expression. If the whole of the tenor can
            be matched by the regular expression, then it was a successful match and the tenor can be parsed
            using the matches in the MatchCollection
            </summary>
            <param name="tenor"> pointer to IRTenor instance which contains Tenor string to parse</param>
            <returns> bool - true if matches were found and Tenor successfully parsed. False otherwise
            </returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TenorExpressionMatcher.Process(System.Text.RegularExpressions.MatchCollection,EQTG.General.BasicTypes.IRTenor)">
            <summary>
            abstract method. This is where each of the matches are parsed to work out what the final date is.
            </summary>
            <param name="expMatches">a collection containing the matches that were found using the regular expression</param>
            <param name="tenor">pointer to IRTenor instance which contains Tenor string to parse</param>
        </member>
        <member name="T:EQTG.General.BasicTypes.TenorYearMonthWeekDayFormat">
            <summary>
            This class implements the regular expression for Tenors in Day, Week,Month, or Year format
            Valid Examples are
            3Y              3 Years
            3Y2D            3 Years 2 Days
            5W              5 Weeks
            1M              1 Month
            3Y10M20D2W      3 Years 10 Months 20 Days 2 Weeks
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TenorYearMonthWeekDayFormat.Process(System.Text.RegularExpressions.MatchCollection,EQTG.General.BasicTypes.IRTenor)">
            <summary>
            Parses the Tenor for each match in the collection. Each match will be in the format
            (number)(code) where code is Y,M,D or W. For each match we will add that number of years, days
            etc on to todays date
            </summary>
            <param name="expMatches">A collection holding the Matches</param>
            <param name="tenor">pointer to IRTenor instance which contains Tenor string to parse</param>
        </member>
        <member name="T:EQTG.General.BasicTypes.TenorFutureMonthCodeFormat">
            <summary>
            This class implements the regular expression for Tenors in month codes
            Valid Examples are
            Z7              December 2007
            U07             September 2007
            F2007           Janurary 2007
            
            This class only expect 1 Tenor code, i.e if you put in Z7U8 it will only process the Z7 as the Tenor
            with both month codes makes no sense
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TenorFutureMonthCodeFormat.Process(System.Text.RegularExpressions.MatchCollection,EQTG.General.BasicTypes.IRTenor)">
            <summary>
            Parses the Tenor match. The match will be in the format of
            (Month code)(Year). The method then finds out how many days are between now and the 
            (Month code)(Year) so we can add that many days onto todays date
            </summary>
            <param name="expMatches">A collection holding the matches</param>
            <param name="tenor">pointer to IRTenor instance which contains Tenor string to parse</param>
        </member>
        <member name="T:EQTG.General.BasicTypes.TenorFloatYearMonthWeekDayFormat">
            <summary>
            This class implements the regular expression for Tenors in Day, Week,Month, or Year format, but the
            number can actually be a float
            Valid Examples are
            3.5Y              3.6 Years
            3Y2D              3 Years 2 Days
            5.6W              5.6 Weeks
            1.7M              1.7 Month
            3Y5.3M20D2.5W      3 Years 5.3 Months 20 Days 2.5 Weeks
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TenorFloatYearMonthWeekDayFormat.Process(System.Text.RegularExpressions.MatchCollection,EQTG.General.BasicTypes.IRTenor)">
            <summary>
            Parses the Tenor for each match in the collection. Each match will be in the format
            (double)(code) where code is Y,M,D or W. For each match we will add that number of years, days
            etc on to todays date
            </summary>
            <param name="expMatches">A collection holding the Matches</param>
            <param name="tenor">pointer to IRTenor instance which contains Tenor string to parse</param>
        </member>
        <member name="T:EQTG.General.BasicTypes.IRTenor">
            <summary>
            This class accepts a Tenor string and will try and parse it to work out what the expiry date will be
            given the start date. I.e. a tenor like 5Y will add 5 years onto the start date
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.#ctor(System.String)">
            <summary>
            Alternative constructor which takes the tenor string to be parsed. Assumes the start date is
            todays date
            </summary>
            <param name="strTenor">Tenor string to be parsed</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.#ctor(System.String,EQTG.General.BasicTypes.Date)">
            <summary>
            Alternative constructor which takes tenor string to be parsed and start date.
            </summary>
            <param name="strTenor">Tenor string to be parsed</param>
            <param name="today">The start date</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.setTenor(System.String)">
            <summary>
            This method tries to parse the tenor and will set the end date given what the Tenor string has 
            been set to
            </summary>
            <param name="strTnr">The tenor string</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.getTenor">
            <summary>
            Gets the Tenor string represented by the instance. If the string is "1Y6M" it will return "18M"
            for convention purposes
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.getTenorRover8">
            <summary>
            Gets the Tenor end date in Rover8 format for this instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.isValid">
            <summary>
            Checks to see if the Tenor end date is a valid date
            </summary>
            <returns>bool - true if end date is valid</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.constructExpressionMatcher">
            <summary>
            This is a static method which sets up all the regular expressions the IRTenor class knows about.
            As the regular expressions won't change they are put into a static List. We use a object for 
            multithreaded safety purposes
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.IRTenor.parseString(System.String)">
            <summary>
            This method will go through each regular expression that it knows about and will try and match
            the tenor to the regular expression. If a match occurs, the Tenor is parsed by the regular
            expression to work out the end date. If no matches were found, the method will try to match against
            some known special case Tenors. If it still can't find a match, then it will throw an error
            </summary>
            <param name="tenor">The tenor to parse</param>
        </member>
        <member name="P:EQTG.General.BasicTypes.IRTenor.tenorInDateFormat">
            <summary>
            Gets the Tenor in string format for this instance
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.IRTenor.maturityDate">
            <summary>
            Gets the end date for the Tenor of this instance
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.IRTenor.startDate">
            <summary>
            Gets the start date of the tenor for this instance
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.NumericUtils">
            <summary>
            Utility functions for numbers
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.#ctor">
            <summary>
            C'tor (to prevent instantiation) on static member class
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.RoundWithDenominator(System.Double,System.Int32)">
            <summary>
            Round a number using supplied denominator
            </summary>
            <param name="input">Number to round</param>
            <param name="denominator">Denominator to use</param>
            <returns>Number rounded using denominator</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.RoundUpWithDenominator(System.Double,System.Int32)">
            <summary>
            Round a number up using supplied denominator
            </summary>
            <param name="input">Number to round</param>
            <param name="denominator">Denominator to use</param>
            <returns>Number rounded using denominator</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.RoundDownWithDenominator(System.Double,System.Int32)">
            <summary>
            Round a number down using supplied denominator
            </summary>
            <param name="input">Number to round</param>
            <param name="denominator">Denominator to use</param>
            <returns>Number rounded using denominator</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.AllNonZeroAndFinite(System.Double[])">
            <summary>
            Check whether an array of doubles are all non-zero and finite
            </summary>
            <param name="doubles">Array of doubles</param>
            <returns>True if all non-zero and finite</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.NonZeroAndFinite(System.Double)">
            <summary>
            Check whether a single double is non-zero and finite
            </summary>
            <param name="d">Double to check</param>
            <returns>True if number is non-zero and finite</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.BiasedRound(System.Double,System.Int32)">
            <summary>
            Returns the number with the specified precision nearest the specified value.
            If two numbers with the specified precision are equidistant from the input,
            the greater of the two is chosen (cf. Math.Round which will round to the number which
            is 'even' i.e. it has zero in in its lowest n bits for more bits than the other)
            </summary>
            <param name="input"></param>
            <param name="decimalPlaces"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.NumericUtils.SigFigures2(System.Double,System.Int32,System.Boolean)">
            <summary>
            Chop the supplied double to the specified number of significant figures, rounding
            if required.
            </summary>
            <remarks>
            The original SigFigures() function does not work accurately - this version does. When
            we are sure that nothing is relying on the results of the old version, we can replace
            it.
            </remarks>
            <param name="d">The number we are chopping</param>
            <param name="sf">Number of significant figures to retain</param>
            <param name="round">Should we round the result or not</param>
            <returns>The chopped number</returns>
        </member>
        <member name="T:EQTG.General.BasicTypes.Period">
            <summary>
            Summary description for Period.
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.RelativeUri">
            <summary>
            Extends the Uri class to try to handle relative paths. 
            If the specified URI isn't found as a file, then try it as a relative path.
            e.g. for file://../Models/myModel.xml 
            LocalPath2 would return ..\Models\myModel.xml
            rather than \\..\Models\myModel.xml, which is what System.Uri would return. 
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.RelativeUri.IntelliPath">
            <summary>
            Add ability to use relative paths, 
            useful if Uris are being used to identify local files.
            If standard Uri local path file does not exist then
            this assume the path is relative and return that path instead.
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.RollingConvention">
            <summary>
            Specifies the method used to roll dates past weekends and holidays.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.NONE">
            <summary>
            No rolling is performed; weekends and holidays are left as is.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.FWD">
            <summary>
            Roll forward to the next business day.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.FIM">
            <summary>
            Roll forward if the next business day is within the same month; otherwise, backward.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.BWD">
            <summary>
            Roll backward to the previous business day.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.BIM">
            <summary>
            Roll backward if the previous business day is within the same month; otherwise, forward.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.EOM">
            <summary>
            Roll to the last day of this month.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.EOMp">
            <summary>
            Roll to the last business day of this month.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.RollingConvention.EOMn">
            <summary>
            Roll to the first business day of next month.
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.StringUtils">
            <summary>
            Simple string utilities that aren't supplied out of the box by the .NET framework
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.Contains(System.String,System.Char)">
            <summary>
            Utility function - can do equivalent by IndexOf - use this internally - but this type uses char explicitly
            </summary>
            <param name="s">String to search</param>
            <param name="c">Char to search for</param>
            <returns>True if string contains the char, false otherwise</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.ToStringArray(System.Collections.ICollection)">
            <summary>
            Converts an ArrayList containing only strings to a string []. With throw if the ArrayList has non-strings
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.Tokenise(System.String,System.Char)">
            <summary>
            Tokenize a string into an array of string tokens
            </summary>
            <param name="str">String to split</param>
            <param name="separator">Separator character</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.Tokenise(System.String,System.Char,System.Boolean)">
            <summary>
            Tokenize a string into an array of string tokens
            </summary>
            <param name="str">String to split</param>
            <param name="separator">Separator character</param>
            <param name="ignoreMultipleSeparators">Ignore tokens if there are two successive separators</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.Tokenise2(System.String,System.Char)">
            <summary>
            Tokenize a string into an array of string tokens
            </summary>
            <param name="str">String to split</param>
            <param name="separator">Separator character</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.Tokenise2(System.String,System.Char,System.Boolean)">
            <summary>
            Tokenize a string into an array of string tokens
            </summary>
            <param name="str">String to split</param>
            <param name="separator">Separator character</param>
            <param name="multipleSeparatorsEscape ">Two successive separators escape the separator</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.TokeniseCommandLine(System.String)">
            <summary>
            Separates a command line flag into its components, using default parameters.
            </summary>
            <param name="commandLineFlag">One flag on the command line.</param>
            <returns>An array of components making up the commandline flag.</returns>
            <remarks>
            The version of the method calls its overloaded member with the following parameters:
            separator = ' ', openQuote = '"', closeQuote = '"', escape = '\\'.  See the overload
            for more details.
            </remarks>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.TokeniseCommandLine(System.String,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Separates a command line flag into its components, using specific parameters.
            </summary>
            <param name="commandLineFlag">One flag on the command line.</param>
            <param name="separator">The character to split the commandLine string on.</param>
            <param name="openQuote">The opening quote character for blocks of text to be skipped.</param>
            <param name="closeQuote">The closing quote character for blocks of text to be skipped.</param>
            <param name="escape">Character that signals ignore next character.</param>
            <returns>An array of components making up the commandline flag.</returns>
            <remarks>
            This method splits a string, commandLineFlag, on the separator character into an array of strings.
            Any parts of the string that include the separator, escape or quote characters should be preceeded 
            by the escape character.  For blocks of text that contain multiple separators, place them inside 
            the quotation characters.
            </remarks>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.ToDatabase(System.String)">
            <summary>
            Converts a string into a format suitable for embedding into a SQL statement
            </summary>
            <param name="inString">string</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.ToBool(System.String,System.Boolean,System.Boolean)">
            <summary>
            Converts a string to a bool. More flexible COnvert.ToBoolean in that it cope with yes/no etc.
            Either throws or returns defautlValue if it can't convert
            Private, som only caleld by other, easy-to-use methods
            </summary>
            <param name="asString">The string form</param>
            <param name="shouldThrow">Should we throw or default</param>
            <param name="defaultValue">Default in case of failure</param>
            <returns>The boolean</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.ToBool(System.String,System.Boolean)">
            <summary>
            Converts a string to a bool. More flexible COnvert.ToBoolean in that it cope with yes/no etc.
            Returns defaultValue if it can't cope
            </summary>
            <param name="asString">The string form</param>
            <param name="defaultValue">Default in case of failure</param>
            <returns>The boolean</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.ToBool(System.String)">
            <summary>
            Converts a string to a bool. More flexible Convert.ToBoolean in that it cope with yes/no etc.
            Throws if it can't cope
            </summary>
            <param name="asString">The string form</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.BoolToChar(System.Boolean)">
            <summary>
            Converts a bool to a char 'Y' or 'N'.
            </summary>
            <param name="val">The boolean</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.BoolToYNString(System.Boolean)">
            <summary>
            Converts a bool to a string "Y" or "N".
            </summary>
            <param name="val">The boolean</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.ByteQuantityToString(System.Int64,System.Int32)">
            <summary>
            Converts a number, representing a quantity of bytes, into a human-readable
            string in bytes, kilobytes, megabytes etc...
            </summary>
            <param name="quantity">Quantity of bytes to convert</param>
            <param name="precision">Max precision of rendered string</param>
            <returns>Human readable byte quantity</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.CapitalizeFirst(System.String)">
            <summary>
            Cpaitalizes the first letter of the string
            </summary>
            <param name="text">Uncapitalized text</param>
            <returns>Capitalized text</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.RemoveCharacters(System.String,System.Char[])">
            <summary>
            Removes all of the given characters from the string
            </summary>
            <param name="text">Text to process</param>
            <param name="characters">Characters to remove</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.Join(System.String[],System.String)">
            <summary>
            Join the elements in the array into a single string, delimited by the connector
            </summary>
            <param name="fragments">The individual tokens</param>
            <param name="connector">The string that separates them</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.PadLeft(System.String,System.Char,System.Int32)">
            <summary>
             Pad the string up to a specified length, by prepending desired character
            </summary>
            <param name="text">The original string</param>
            <param name="padChar">Character which is to be used for padding</param>
            <param name="totalLength">The desired length of the padded string</param>
            <returns>The padded string</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.PadRight(System.String,System.Char,System.Int32)">
            <summary>
            Pad the string up to a specified length, by appending desired character
            </summary>
            <param name="text">The original string</param>
            <param name="padChar">Character which is to be used for padding</param>
            <param name="totalLength">The desired length of the padded string</param>
            <returns>The padded string</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.EmptyIfNull(System.String)">
            <summary>
            Given a null string reference return string.empty otherwise return the string that
            was passed in
            </summary>
            <param name="text">String reference</param>
            <returns>String.Empty if passed a null reference otherwise returns text</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.StringUtils.CombinePath(System.String[])">
            <summary>
            Combines two or more path strings.
            </summary>
            <param name="parts">An array of directory or file names to combine.</param>
            <returns>The strings in <paramref name="parts"/> joined using 
            <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.</returns>
        </member>
        <member name="T:EQTG.General.BasicTypes.TokeniserState">
            <summary>
            Enum for state machine within <see cref="M:EQTG.General.BasicTypes.StringUtils.TokeniseCommandLine(System.String)"/>.
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimeUtils">
            <summary>
            Simple useful time based functions not supplied by the .NET framework or EQTG specific in usefulness
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimeUtils.SecondsPerHour">
            <summary>
            Constant defining the number of seconds in an hour
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimeUtils.SecondsPerDay">
            <summary>
            Constant defining the number of seconds in a day
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimeUtils.MinutesPerDay">
            <summary>
            Constant defining the number of minutes in a day
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimeUtils.TicksPerSecond">
            <summary>
            DateTime objects have a notional granuality of Ticks. 1 Tick = 100 nanoseconds. TicksPerSecond Ticks = 1 second
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimeUtils.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.TimeAsInteger(System.DateTime)">
            <summary>
            Turn a datetime into a time int that is used for instance on the TIC
            </summary>
            <param name="dt">System.DateTime to be turned into integer</param>
            <returns>Int representing the time</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.TodayTimeFromInteger(System.Int32)">
            <summary>
            Turn a time int (that is used for instance on the TIC) into a DateTime during the current day
            </summary>
            <param name="timeAsInteger"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.YearDotTimeFromInteger(System.Int32)">
            <summary>
            Turn a time int (that is used for instance on the TIC) into a DateTime on 1 Jan 1900
            </summary>
            <param name="timeAsInteger"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.TimeFromIntegerAndBaseDate(System.Int32,System.DateTime)">
            <summary>
            Turn a time int (that is used for instance on the TIC) into a DateTime in the same day as baseDate
            </summary>
            <param name="timeAsInteger"></param>
            <param name="baseDate"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.Rover8FromDateTime(System.DateTime)">
            <summary>
            Turn a system date time into a rover8 date (useful for database queries etc)
            </summary>
            <param name="dt">System.DateTime to be converted</param>
            <returns>Int of form 20020330</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.DateTimeFromRover8String(System.DateTime@,System.String)">
            <summary>
            Datetime year month and date from rover8 string 
            </summary>
            <param name="s">Rover8 String</param>
            <param name="dt">DateTime to set</param>
            <returns>Whether conversion succeeded</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.ToDatabase(System.DateTime)">
            <summary>
            Converts a datetime into a format suitable for embedding into a sybase SQL statement
            A datetime value of DateTime.MinValue will reuslt in "NULL" being returned
            </summary>
            <param name="dateTime">the date to convert</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.BumpPastWeekend(System.DateTime)">
            <summary>
            Bump specified DateTime past a weekend.
            No timezone adjustments made - straight 24-hour chunks added.
            Doesn't do any timezone conversions
            </summary>
            <param name="dt">Date Time to bump</param>
            <returns>Bumped DateTime</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.MoveDateTimeBackToPrevDay(System.DateTime@)">
            <summary>
            Moves the passed DateTime back until we hit the previous day.
            Inputs and outputs are both local time. We have to be careful because in DST adjustment days, 
            the day can be longer or shorter than 24 hours.  We assume that the adjustment will not be more than 2 hours, and 
            that days are longer than 2 hours :)
            </summary>
            <param name="dt">time to move</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.MoveDateTimeForwardToNextDay(System.DateTime@)">
            <summary>
            Moves the passed DateTime forward until we hit the next day.
            Inputs and outputs are both local time. We have to be careful because in DST adjustment days, 
            the day can be longer or shorter than 24 hours.  We assume that the adjustment will not be more than 2 hours, and 
            that days are longer than 2 hours :)
            </summary>
            <param name="dt">time to move</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.PreviousWeekdayInTimeZone(System.DateTime,System.String,System.Int32,System.Int32)">
            <summary>
            Gets the UTC <see cref="T:System.DateTime"/> (moves specified DateTime back) at which the local time in 
            the specified time zone was the time specified.
            </summary>
            <remarks>
            Inputs and outputs are UTC.  Converts to local time, gets the previous 
            occurrence of specified local hour and minute, returns as UTC
            </remarks>
            <param name="utcStart">Test time</param>
            <param name="timezone">Timezone of test time</param>
            <param name="hour">Hour of prev occurrence</param>
            <param name="minute">Minute of prev occurrence</param>
            <returns>Previous Weekday UTC DateTime to test date</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.NextWeekdayInTimeZone(System.DateTime,System.String,System.Int32,System.Int32)">
            <summary>
            Gets the UTC <see cref="T:System.DateTime"/> (moves specified DateTime back) at which the local 
            time in the specified time zone will next be the time specified.
            </summary>
            <remarks>
            Inputs and outputs are UTC.  Converts to local time, gets the next occurrence of specified 
            local hour and minute, returns as UTC
            </remarks>
            <param name="utcStart">Test time</param>
            <param name="timezone">Timezone of test time</param>
            <param name="hour">Hour of prev occurrence</param>
            <param name="minute">Minute of prev occurrence</param>
            <returns>Previous Weekday UTC DateTime to test date</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.ConvertLocalDbTimeToUTC(System.DateTime,System.String)">
            <summary>
            Converts a datetime loaded from the database to the UTC time zone
            </summary>
            <param name="duration">The time span</param>
            <returns>A human readable string</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.FormatHumanReadableMs(System.Int64)">
            <summary>
            outputs a time span in human readable format
            </summary>
            <param name="ms">The number of milliseconds</param>
            <returns>A human readable string</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.FormatHumanReadableSec(System.Double)">
            <summary>
            outputs a time span in human readable format
            </summary>
            <param name="seconds">The number of seconds</param>
            <returns>A human readable string</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimeUtils.FormatHumanReadableSec(System.TimeSpan)">
            <summary>
            outputs a time span in human readable format
            </summary>
            <param name="duration">The time span</param>
            <returns>A human readable string</returns>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimezoneInformationCache">
            <summary>
            TimezoneInformationCache. List of timezones recognised by EQTG conversion.
            Used when converting from UTC times to local timezones.
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimezoneInformationCache.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.#ctor">
            <summary>
            C'tor
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.Initialise">
            <summary>
            One off call to the TimeZone cache
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.UTCToTimeZone(System.DateTime,System.String)">
            <summary>
            Convert a UTC Time into a specific timezone
            </summary>
            <param name="utcDateTime">UTC Time</param>
            <param name="zoneName">Name of zone to convert to</param>
            <returns>DateTime in specified timezone</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.TimezoneTimeToUTCDateTime(System.DateTime,System.String)">
            <summary>
            Convert a Timezone Time to a UTC Time
            </summary>
            <param name="tzDateTime">Timezone based DateTime</param>
            <param name="zoneName">Name of zone this comes from</param>
            <returns>UTC DateTime</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.AddTimezoneInfo(System.String,System.String,System.String,System.Single,System.Boolean)">
            <summary>
            Add a Timezone to the list of recognised timezones
            </summary>
            <param name="zone">Short name of the zone</param>
            <param name="zoneName">Full zone description</param>
            <param name="windowsSystemZone">Name of this zone in the Windows system registry</param>
            <param name="windowsSystemOffset">Offset from the Windows timezone for this timezone</param>
            <param name="useSystemDaylightSaving">Whether we should use daylight saving when converting from the system timezone</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.Instance">
            <summary>
            Instance access. You can declare 
            </summary>
            <returns></returns>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimezoneInformationCache.OurCache">
            <summary>
            Static Member cache
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.SystemTimeFromDateTime(EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME@,System.DateTime)">
            <summary>
            Helper conversion utility
            </summary>
            <param name="dt">DateTime to convert</param>
            <returns>SYSTEMTIME</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.DateTimeFromSystemTime(EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME)">
            <summary>
            Helper Conversion utility
            </summary>
            <param name="tm">WIN32 SYSTEMTIME structure</param>
            <returns>Corresponding DateTime</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.GetTimeZoneInfoEntry(System.String)">
            <summary>
            Helper lookup function to find stored timezone information for a given time zone
            </summary>
            <param name="zoneName">Name of the timezone</param>
            <returns>Information Entry for the timezone name</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.SetTestTimeZoneInformation(EQTG.General.BasicTypes.TimezoneInformationCache.TIME_ZONE_INFORMATION@,System.String)">
            <summary>
            Helper to build up a test time zone information required for conversion
            </summary>
            <param name="tzi">TIME_ZONE_INFORMATION to populate</param>
            <param name="zone">Zone to set this info for</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.FindGMTWindowsTimeZoneName">
            <summary>
            Retrieve the appropriate London/GMT timezone name
            Sadly, because the key name keeps changing, the best way to do this is to 
            find the Display entry that contains 'London' in it.
            </summary>
            <returns>The name of the GMT Windows TimeZone Key</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.ReadTimezoneInfoFromRegistry(EQTG.General.BasicTypes.TimezoneInformationCache.TIME_ZONE_INFORMATION@,System.String)">
            <summary>
            Helper to load information from the registry.
            </summary>
            <param name="tzi">TIME_ZONE_INFORMATION to populate</param>
            <param name="windowsZoneName">Name of the zone to read</param>
            <returns>True if the zone information was populated</returns>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.ReadSystemTimeFromBinaryReader(EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME@,System.IO.BinaryReader)">
            <summary>
            Helper to convert bytes into SYSTEMTIME
            </summary>
            <param name="st">SystemTime</param>
            <param name="br">Reader to read from</param>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.GetSystemTime(EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME@)">
            <summary>
            Import the GetSystemTime API Call
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.SystemTimeToTzSpecificLocalTime(EQTG.General.BasicTypes.TimezoneInformationCache.TIME_ZONE_INFORMATION@,EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME@,EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME@)">
            <summary>
            SystemTime to Timezone based time conversion functions
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.GetTimeZoneInformation(EQTG.General.BasicTypes.TimezoneInformationCache.TIME_ZONE_INFORMATION@)">
            <summary>
            TimeZone info access (for current timezone)
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationCache.GetLastError">
            <summary>
            Standard Win32 API Error code function
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimezoneInformationCache.myTimezoneEntries">
            <summary>
            Internal storage of TimezoneInfoEntry, the raw information for conversions
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimezoneInformationCache.myGMTTimeZoneInformation">
            <summary>
            Store the GMT TimeZone Information
            </summary>
        </member>
        <member name="P:EQTG.General.BasicTypes.TimezoneInformationCache.Count">
            <summary>
            Count of timezone entries
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimezoneInformationCache.TimezoneInfoEntry">
            <summary>
            Private store for Timezone information, that allows conversion from Windows system timezones
            to EQTG timezones.
            Includes the raw information as read from the database and the TIMEZONE info as read from WIN32
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimezoneInformationCache.TimezoneInfoEntry.myTimeZoneInfo">
            <summary>
            For timezones that have a valid windows system zone name we will populate the TIME_ZONE_INFORMATION
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimezoneInformationCache.SYSTEMTIME">
            <summary>
            Declare Win32 API Struct TIME_ZONE_INFORMATION
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimezoneInformationCache.TIME_ZONE_INFORMATION">
            <summary>
            Declare Win32 API Struct TIME_ZONE_INFORMATION
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimezoneInformationCache.TIME_ZONE_ID">
            <summary>
            Return type from GetTimeZoneInformation
            </summary>
        </member>
        <member name="T:EQTG.General.BasicTypes.TimezoneInformationReader">
            <summary>
            TimezoneInformationReader - load the EQTG Timezone names and store the corresponding 
            WindowsTimeZone names, the offsets, and whether to use the daylight saving for
            the 'EQTG' timezone
            </summary>
        </member>
        <member name="F:EQTG.General.BasicTypes.TimezoneInformationReader.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.BasicTypes.TimezoneInformationReader.LoadTimezoneInformation(EQTG.General.BasicTypes.TimezoneInformationCache,System.Data.IDbConnection)">
            <summary>
            Load the timezone inf
            </summary>
            <param name="cache">Cache of Timezone information to populate</param>
            <param name="dbConnection">Open Database conenction to execute the queries with</param>
        </member>
        <member name="T:EQTG.General.BasicTypes.TriState">
            <summary>
            Class to hanlde tri-state logic
            </summary>
        </member>
        <member name="T:EQTG.General.BatchPerformanceMonitor">
            <summary>
            Class that gathers performance information about batch processing.
            </summary>
            <remarks>
            The information can then be written out to a CSV file periodically. If done over time this lets you
            build up a picture of how batches are performing within a process.
            </remarks>
            <example><code>
            BatchPerformanceMonitor bpm = new BatchPerformanceMonitor("events");
            ...
            while (myKeepProcessing)
            {
            	bpm.StartBatch();
            	while (thingsToDoInBatch)
            	{
            		...
            		bpm.OneItemProcessed();
            	}
            	bpm.EndBatch();
            }</code></example>
        </member>
        <member name="F:EQTG.General.BatchPerformanceMonitor.myNumberProcessed">
            <summary>
            Total number of items processed in all batches
            </summary>
        </member>
        <member name="F:EQTG.General.BatchPerformanceMonitor.myBatchCount">
            <summary>
            The number of batches processes
            </summary>
        </member>
        <member name="F:EQTG.General.BatchPerformanceMonitor.myName">
            <summary>
            The name of this batch
            </summary>
        </member>
        <member name="F:EQTG.General.BatchPerformanceMonitor.OurPerformanceMonitors">
            <summary>
            All our instances
            </summary>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="Name"></param>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.Finalize">
            <summary>
            Dtor
            </summary>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.StartBatch">
            <summary>
            Indicates the start of a new batch processing sequence
            </summary>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.EndBatch">
            <summary>
            Indicate the end of a batch
            </summary>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.OneItemProcessed">
            <summary>
            Indicates that one Item in the batch has been processed
            </summary>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.NItemsProcessed(System.Int32)">
            <summary>
            Indicates that n items in a batch have been processed
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.GetCSVTableHeader">
            <summary>
            Results can be written as a csv file - this generates the header line
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BatchPerformanceMonitor.GetCSVTableRows">
            <summary>
            Returns a row for the CSV file showing the current statistics
            </summary>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.BucketCount">
            <summary>
            Take observations (doubles) and produce:
            . count of observations within each bucket
            . count of observations prior to first bucket
            . count of observations after last bucket
            </summary>
        </member>
        <member name="F:EQTG.General.BucketCount.myNumBuckets">
            <summary>
            Number of buckets
            </summary>
        </member>
        <member name="F:EQTG.General.BucketCount.myBucketStart">
            <summary>
            Where first bucket starts
            </summary>
        </member>
        <member name="F:EQTG.General.BucketCount.myBucketSize">
            <summary>
            Size of buckets
            </summary>
        </member>
        <member name="F:EQTG.General.BucketCount.myBucketCounts">
            <summary>
            buckets - int for each which is count of observations falling in that bucket
            </summary>
        </member>
        <member name="F:EQTG.General.BucketCount.myBucketCountNegative">
            <summary>
            how many observations are before first bucket
            </summary>
        </member>
        <member name="F:EQTG.General.BucketCount.myBucketCountExcess">
            <summary>
            how many observations are after the last bucket
            </summary>
        </member>
        <member name="M:EQTG.General.BucketCount.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            C'tor
            </summary>
            <param name="bucketStart"></param>
            <param name="bucketSize"></param>
            <param name="numBuckets"></param>
        </member>
        <member name="M:EQTG.General.BucketCount.AddObservation(System.Double)">
            <summary>
            Add an entry to one of the buckets
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:EQTG.General.BucketCount.ToString">
            <summary>
            Returns a string describing the bucket counts
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.BucketCount.GetBucketSize">
            <summary>
            Access the size of the buckets
            </summary>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.BucketCountWithStats">
            <summary>
            A BucketCount with min/max/mean
            </summary>
        </member>
        <member name="M:EQTG.General.BucketCountWithStats.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Take observations (doubles) and produce:
            . count of observations within each bucket
            . count of observations prior to first bucket
            . count of observations after last bucket
            </summary>
            <param name="bucketStart">First bucket</param>
            <param name="bucketSize">bucket width</param>
            <param name="numBuckets">Count of buckets</param>
        </member>
        <member name="M:EQTG.General.BucketCountWithStats.AddObservation(System.Double)">
            <summary>
            Add an entry into the collection
            </summary>
            <param name="n">Entry</param>
        </member>
        <member name="M:EQTG.General.BucketCountWithStats.Clear">
            <summary>
            Reset all statistics
            </summary>
        </member>
        <member name="M:EQTG.General.BucketCountWithStats.ToString">
            <summary>
            Convert to summary string
            </summary>
            <returns>Summary</returns>
        </member>
        <member name="P:EQTG.General.BucketCountWithStats.Min">
            <summary>
            Smallest recorded observation
            </summary>
        </member>
        <member name="P:EQTG.General.BucketCountWithStats.Max">
            <summary>
            Greatest recorded observation
            </summary>
        </member>
        <member name="P:EQTG.General.BucketCountWithStats.Sum">
            <summary>
            Total of all observations
            </summary>
        </member>
        <member name="P:EQTG.General.BucketCountWithStats.Count">
            <summary>
            Number of observations
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.Arrays">
            <summary>
            Array utilities
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Arrays.Unique``1(``0[],System.Int32@,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sort and remove all duplicate elements in an array
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="array">The array to process</param>
            <param name="size">The final size of the array (non used cells will be set to null)</param>
            <param name="comparer">The object used for comparing elements</param>
            <param name="sort">if false, the array is already sorted</param>
            <param name="throwOnNull">if true and one of the element is null, throw an exception</param>
            <param name="throwOnDuplicate">if true and we find duplicates, throw an exception</param>
        </member>
        <member name="M:EQTG.General.Collections.Arrays.UniqueCopy``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0},``0[],System.Int32)">
            <summary>
            Copy the element of a sorted array into another removing all duplicates
            </summary>
            <typeparam name="T">The array element type</typeparam>
            <param name="array">The original array. It m</param>
            <param name="size">the number of elements to copy</param>
            <param name="startIndex">the index to start copying from</param>
            <param name="comparer">The object used for comparing elements</param>
            <param name="result">The resulting array</param>
            <param name="destIndex">the index to start copying to</param>
            <return>The number of elements copied</return>
        </member>
        <member name="M:EQTG.General.Collections.Arrays.MergeSorted``1(``0[],System.Int32,``0[],System.Int32,System.Collections.Generic.IComparer{``0},``0[]@,System.Int32@)">
            <summary>
            Merge 2 sorted arrays
            </summary>
            <typeparam name="T">The array element type</typeparam>
            <param name="array1">The first sorted array</param>
            <param name="size1">The size of The first sorted array</param>
            <param name="array2">The second array</param>
            <param name="size2">The size of the second array</param>
            <param name="comparer">The object used for comparing elements</param>
            <param name="result">The resulting array</param>
            <param name="size">The size of the resulting array</param>
        </member>
        <member name="M:EQTG.General.Collections.Arrays.MergeUnique``1(``0[],System.Int32,``0[],System.Int32,System.Collections.Generic.IComparer{``0},``0[]@,System.Int32@)">
            <summary>
            Merge 2 sorted arrays and remove any duplicate
            </summary>
            <typeparam name="T">The array element type</typeparam>
            <param name="array1">The first sorted array</param>
            <param name="size1">The size of The first sorted array</param>
            <param name="array2">The second array</param>
            <param name="size2">The size of the second array</param>
            <param name="comparer">The object used for comparing elements</param>
            <param name="result">The resulting array</param>
            <param name="size">The size of the resulting array</param>
        </member>
        <member name="T:EQTG.General.Collections.CollectionUtils">
            <summary>
            Summary description for CollectionUtils.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.HashFOCArrayList(System.Collections.Hashtable,System.Object)">
            <summary>
            Given a Hashtable, this method will find or create an ArrayList for the given key
            //TODO: share some implementation with HashFOCHash and HashFOCHashset
            //TODO: Decide whether it is worth using Contains and [key] (two look ups) - benefit is that null entries are distinguished from no entry at all
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.ToString(System.Data.IDataReader)">
            <summary>
            Does a dbResultsAsThoughIsql style ToString
            </summary>
            <param name="dataReader"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.AppendOneToArray(System.Array,System.Object)">
            <summary>
            Array appending method
            </summary>
            <param name="arr"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.AppendArrayToArray(System.Array,System.Array)">
            <summary>
            Array appending method
            </summary>
            <param name="arr"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.Filter(System.Collections.ICollection,EQTG.General.Collections.CollectionUtils.UnaryPredicate)">
            <summary>
            Return a collection which only contains those objects that pass the test
            </summary>
            <param name="collection">Initial collectio</param>
            <param name="predicate">The test</param>
            <returns>Filtered collection</returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.Copy(System.Collections.IDictionary,System.Collections.IDictionary)">
            <summary>
            Copy the contents of the source to the destination
            </summary>
            <param name="dest">destination</param>
            <param name="source">source</param>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.First(System.Collections.IEnumerable)">
            <summary>
            Returns the first element in the collection
            </summary>
            <param name="collection">The collection</param>
            <returns>The first element (or null if empty)</returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.QuickSort(System.Collections.IList,System.Collections.IComparer)">
            <summary>
            Do an inplace quicksort on given list
            </summary>
            <param name="list">list to sort</param>
            <param name="comparer">This object defines an increasing order on elements of list</param>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.QuickSortInternal(System.Collections.IList,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Used by QuickSort
            </summary>
            <param name="list"></param>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.PivotInternal(System.Collections.IList,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Used by QuickSort
            </summary>
            <param name="list"></param>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.SelectionSort(System.Collections.IList,System.Collections.IComparer)">
            <summary>
            Perform an in-place selection sort on list
            </summary>
            <param name="list">The list to sort</param>
            <param name="comparer">Defines an increasing order on items in list</param>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.SelectionSortInternal(System.Collections.IList,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Used by SelectionSort
            </summary>
            <param name="list"></param>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.HeapSort(System.Collections.IList,System.Collections.IComparer)">
            <summary>
            Performs an inplace sort using the HeapSort algorihm on the given list. The sorted
            item will be in order as determined by the comparer
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:EQTG.General.Collections.CollectionUtils.HeapSortDescending(System.Collections.IList,System.Collections.IComparer)">
            <summary>
            Performs an inplace sort using the HeapSort algorihm on the given list. The order or elements will be the
            reverse of the order specified by the comparer
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="T:EQTG.General.Collections.Deque">
            <summary>
            Represents a collection of objects that can be accessed from either end.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Deque.Clear">
            <summary>
            Removes all objects from the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Deque.Contains(System.Object)">
            <summary>
            Determines whether an element is in the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:EQTG.General.Collections.Deque"/>.</param>
        </member>
        <member name="M:EQTG.General.Collections.Deque.PushFront(System.Object)">
            <summary>
            Adds an object to the beginning of the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:EQTG.General.Collections.Deque"/>.</param>
        </member>
        <member name="M:EQTG.General.Collections.Deque.PushBack(System.Object)">
            <summary>
            Adds an object to the end of the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:EQTG.General.Collections.Deque"/>.</param>
        </member>
        <member name="M:EQTG.General.Collections.Deque.PopFront">
            <summary>
            Removes and returns the object at the beginning of the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
            <returns>The object that is removed from the beginning of the <see cref="T:EQTG.General.Collections.Deque"/>.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:EQTG.General.Collections.Deque"/> is empty.</exception>
        </member>
        <member name="M:EQTG.General.Collections.Deque.PopBack">
            <summary>
            Removes and returns the object at the end of the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
            <returns>The object that is removed from the end of the <see cref="T:EQTG.General.Collections.Deque"/>.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:EQTG.General.Collections.Deque"/> is empty.</exception>
        </member>
        <member name="M:EQTG.General.Collections.Deque.PeekFront">
            <summary>
            Returns the object at the beginning of the <see cref="T:EQTG.General.Collections.Deque"/> without removing it.
            </summary>
            <returns>The object at the beginning of the <see cref="T:EQTG.General.Collections.Deque"/>.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:EQTG.General.Collections.Deque"/> is empty.</exception>
        </member>
        <member name="M:EQTG.General.Collections.Deque.PeekBack">
            <summary>
            Returns the object at the end of the <see cref="T:EQTG.General.Collections.Deque"/> without removing it.
            </summary>
            <returns>The object at the end of the <see cref="T:EQTG.General.Collections.Deque"/>.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:EQTG.General.Collections.Deque"/> is empty.</exception>
        </member>
        <member name="M:EQTG.General.Collections.Deque.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the <see cref="T:EQTG.General.Collections.Deque"/> elements to an existing one-dimensional <see cref="T:System.Array"/>, 
            starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements 
            copied from <see cref="T:EQTG.General.Collections.Deque"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <i>array</i> at which copying begins. </param>
        </member>
        <member name="M:EQTG.General.Collections.Deque.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the <see cref="T:EQTG.General.Collections.Deque"/>.</returns>
        </member>
        <member name="P:EQTG.General.Collections.Deque.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:EQTG.General.Collections.Deque"/> is synchronized
            (thread-safe).
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.Deque.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.Deque.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:EQTG.General.Collections.Deque"/>.
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.DoublyLinkedList">
            <summary>
            Summary description for DoublyLinkedList.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.DoublyLinkedList.Insert(System.Int32,System.Object)">
            <summary>
            Inserts a new chain in the list, BEFORE the index given. So Insert(0, x) puts x at the head of the list.
            To insert at the very end of the list use Add.
            </summary>
            <param name="index"></param>
            <param name="datum"></param>
        </member>
        <member name="T:EQTG.General.Collections.DynamicPriorityQueue">
            <summary>
            Summary description for DynamicPriorityQueue.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.Clear">
            <summary>
             Empties the set
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.Add(`0)">
            <summary>
            Adds an item to the set. Duplicates are ignored.
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds an enumeration of items to the set. Duplicates are ignored.
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.Contains(`0)">
            <summary>
            Tests for set membership
            </summary>
            <param name="item">Item to check for set membership</param>
            <returns>True if item is in this set</returns>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.Remove(`0)">
            <summary>
            Removes at item from the set
            </summary>
            <param name="item">Item to remove</param>
            <returns>True if the item was removed, false if not found</returns>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.GetEnumerator">
            <summary>
            Returns an enumerator to iterate through all items in the set
            </summary>
            <returns>Returns an enumerator to iterate through all items in the set</returns>
        </member>
        <member name="M:EQTG.General.Collections.BaseSet`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator to iterate through all items in the set
            </summary>
            <returns>Returns an enumerator to iterate through all items in the set</returns>
        </member>
        <member name="F:EQTG.General.Collections.BaseSet`2.myDict">
            <summary>
            Use a SortedList
            We don't care about values, only keys, so use 'byte' values, which are the smallest possible, to save mem
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.BaseSet`2.Count">
            <summary>
            Number of items in the set
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.BaseSet`2.Items">
            <summary>
            Returns a flattened list of items in the set
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.Set`1">
            <summary>
            A double arrays based generic set
            </summary>
            <typeparam name="T">Type of objects to hold in the set</typeparam>
            <remarks>T must implement IComparable</remarks>
        </member>
        <member name="M:EQTG.General.Collections.Set`1.#ctor">
            <summary>
            Creates an empty set
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Set`1.#ctor(System.Int32)">
            <summary>
            Creates an empty set that can store initialCapacity items without reallocation
            </summary>
            <param name="initialCapacity">Number of objects capacity required</param>
        </member>
        <member name="M:EQTG.General.Collections.Set`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates an empty set that can store initialCapacity items without reallocation
            and that orders items according to the supplied comparer
            </summary>
            <param name="initialCapacity">Initial capacity</param>
            <param name="comparer">Orders items in the set</param>
        </member>
        <member name="P:EQTG.General.Collections.Set`1.Items">
            <summary>
            Returns a flattened list of items in the set
            </summary>
            <remarks>This function hides the base class method because a lot of code depends on Set returning an IList</remarks>
        </member>
        <member name="T:EQTG.General.Collections.Hashset`1">
            <summary>
            A hash-table based generic set
            </summary>
            <typeparam name="T">Type of objects to hold in the set</typeparam>
            <remarks>T does not have to implement IComparable</remarks>
        </member>
        <member name="M:EQTG.General.Collections.Hashset`1.#ctor">
            <summary>
            Creates an empty set
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Hashset`1.#ctor(System.Int32)">
            <summary>
            Creates an empty set that can store initialCapacity items without reallocation
            </summary>
            <param name="initialCapacity">Number of objects capacity required</param>
        </member>
        <member name="T:EQTG.General.Collections.HashedQueue">
            <summary>
            Queue with an associated hashtable, which ensures that items inserted 
            into the queue are unique.
            </summary>
            <remarks>
            Objects on a key already in the queue are overwritten when another one is added.
            </remarks>
        </member>
        <member name="F:EQTG.General.Collections.HashedQueue.myHashtable">
            <summary>
            Hash of keys to objects
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.HashedQueue.myQueue">
            <summary>
            Queue of objects
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.HashedQueue.ValuePointer">
            <summary>
            Object that allows queue item values to be replaced
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.HashMapSortedMap`3">
            <summary>
            Hash of sorted maps e.g. securityManager[secId][validUntilDate]
            </summary>
            <remarks>
            Null values are ignored - should really throw an exception
            </remarks>
        </member>
        <member name="M:EQTG.General.Collections.HashMapSortedMap`3.putOrUpdate(`0,`1,`2)">
            <summary>
            add item to the collection, or update it if it already exists
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="val"></param>
        </member>
        <member name="T:EQTG.General.Collections.HashMapSortedMapPS">
            <summary>
            Hash of sorted maps e.g. securityManager[secId][validUntilDate]
            </summary>
            <remarks>
            Null values are ignored - should really throw an exception
            </remarks>
        </member>
        <member name="M:EQTG.General.Collections.HashMapSortedMapPS.putOrUpdate(System.Object,System.Object,System.Object)">
            <summary>
            add item to the collection, or update it if it already exists
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="val"></param>
        </member>
        <member name="T:EQTG.General.Collections.Hashset">
            <summary>
            Immitates the Java HashSet. Based on a hashmap, just using the keys.
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.Heap">
            <summary>
            Highway101.DataStructures.Heap class.
            Heap Structure.[1]
            </summary>
            <remarks>
            1. Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, 
            <I>Introduction to Algorithms</I>, (McGraw-Hill/MIT Press, Cambridge, MA, 1990), pp. 140-149.
            
            Stolen from Heap class downloaded from Jeff Penrod
            http://www.geocities.com/jeffreydpenrod/freeware.html#heap
            
            (al10694)
            I added the ICollection interface implementation and got it all working.
            I added the heapSemantic concept so that we can have a Min or Max heap (Can be changed dynamically)
            I made Heapify non-recursive
            I added Add and Remove Methods
            
            Just to make things clearer here is a picture:
            		 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
            myArray | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|
                     -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
            
            looks like the following tree:
            
            								0
            							/		\
            						/				\
            					/						\
            				1								2 
            			  /	  \							  /	   \
            			/		\						/		 \
            		3				 4				 5			    6
            	  /   \			  /	   \		  /	   \		  /	   \
            	7		8		9		10		11		12		13		14
               /
              15
            
            </remarks>
        </member>
        <member name="F:EQTG.General.Collections.Heap.myValidEnumerators">
            <summary>
            Used to ensure we can invalidate enumerators if we change
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Heap.myArray">
             <summary>
             Array for containing heap values.
             </summary>
             <remarks>
             NOTE:  .NET arrays are zero-based, so some of the 
            indexes have been adjusted from the one-based
            arrays used in <I>Introduction to Algorithms</I>.
            </remarks>
        </member>
        <member name="F:EQTG.General.Collections.Heap.myComparer">
            <summary>
            This object orders the objects in our heap
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Heap.mySemantic">
            <summary>
            determine if we are a min or max heap
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Heap.myHeapSize">
            <summary>
            Index in myArray of the last element in the heap or -1 if the heap is empty
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Heap.#ctor(System.Collections.IList,System.Collections.IComparer,EQTG.General.Collections.Heap.HeapSemantic)">
            <summary>
            Create instance of heap from an IList e.g an array. The heap
            is created inplace in the list passed in
            </summary>
            <value>Array of objects that implement the IComparable interface.</value> 
            <param name="a"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.#ctor(EQTG.General.Collections.Heap,System.Boolean)">
            <summary>
            Creates a copy of a heap and applies BuildHeap so that we ensure
            the heap property is maintained (useful for restorting an entire heap)
            
            Only use deepCopy = false if you are then going to throw away the original heap
            or you are not going to use iterators on either of the two heaps.
            </summary>
            <param name="h"></param>
            <param name="deepCopy">true if you don't want the new heap to refer to the underlying array in h</param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.#ctor(System.Collections.IComparer,EQTG.General.Collections.Heap.HeapSemantic)">
            <summary>
            Ctor for an empty heap
            </summary>
            <param name="comparer"></param>
            <param name="semantic"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Add(System.Object)">
            <summary>
            Adds an object in the correct place in the heap
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Remove">
            <summary>
            Remove an object from the heap
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Sort">
            <summary>
            The Sort method performs an inplace sort on the underlying array and is thread safe.
            </summary>
            <remarks>
            Assumes that the Heap has already been built.
            </remarks>
        </member>
        <member name="M:EQTG.General.Collections.Heap.BuildHeap">
            <summary>
            (protected) Contruct Heap by enforcing the heap property on Array.
            </summary>
            <remarks>
            Since each element in an array is a small 
            heap, we can use Heapify to contruct the heap.
            The Heap architecture results in all elements of 
            Length / 2 + 1 being leaves of the tree.
            
            The order in which the elements are processed guarantees
            that the subtrees rooted at chidlren of an element i are
            heaps before Heapify is run on that element.
            
            We assume that heapSize is set to the index of the last element of the heap in myArray
            </remarks>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Heapify(System.Int32)">
            <summary>
            (protected) The Heapify method method mantains the heap property.
            
            Throws exception if i is not in the heap
            </summary>
            <remarks>
            At each step, the largest of the elements myArray[i], 
            myArray[Left(i)], and myArray[Right(i)] is determined, and its
            index is stored in Largest.  If myArray[i] is largest, then
            the subtree rooted at element i is a heap and the 
            procedure terminates.  Otherwise, one of the two
            children has the largest element, and myArray[i] is swapped
            with myArray[Largest], which causes element i and its children
            to satisfy the heap property.  The element Largest, 
            however, now has the original value of myArray[i], and thus 
            the subtree rooted Largest may violate the heap 
            property.  Consequently, Heapify must be called 
            recursively on that subtree. 
            (Cormen et al, pp. 143-144)
            </remarks>
            <param name="i"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Left(System.Int32)">
            <summary>
            (protected) Returns array index of "left" child.
            
            The result is undefined if index i is not in our Heap
            </summary>
            <param name="i"></param>
            <returns>Index of left child element.</returns>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Right(System.Int32)">
            <summary>
            (protected) Returns index of "right" child.
            
            The result is undefined if i is not in our Heap
            </summary>
            <param name="i"></param>
            <returns>Index of right child element,</returns>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Parent(System.Int32)">
            <summary>
            Returns the Parent of node i
            
            The result is undefined if i is not in out Heap
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.Heap.AssertInHeap(System.Int32)">
            <summary>
            Given an index into our myArray check it is in the heap through an exception if not
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.Exchange(System.Int32,System.Int32)">
            <summary>
            (protected) Swaps two elements in Array myArray.
            
            Throws an exception if either index is not in our heap
            </summary>
            <param name="idx1">Index of first element.</param>
            <param name="idx2">Index of second element.</param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.InValidateEnumerators">
            <summary>
            Used to ensure that when we change any enumerators becomes invalid
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Heap.AddEnumerator(EQTG.General.Collections.Heap.HeapEnumerator)">
            <summary>
            Add an enumeartor to our list
            </summary>
            <param name="enumeartor"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.CopyTo(System.Array,System.Int32)">
            <summary>
            Implements ICollection::CopyTo
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.GetEnumerator">
            <summary>
            Implement IEnumerable::GetEnumberator
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Collections.Heap.Count">
            <summary>
            Implement ICollection::Count
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.Heap.IsSynchronized">
            <summary>
            Implement ICollection::IsSynchronized
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.Heap.SyncRoot">
            <summary>
            Implement ICollection::SyncRoot
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.Heap.HeapSemantic">
            <summary>
            Used to determine if we are a min or max heap
            
            You could do this by specifing a different IComparable but giving the user this feature
            means they don't ahve to write two IComparers
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.Heap.HeapEnumerator">
            <summary>
            Class to enumerate over elements in a heap NOTE this is not done in any order since a
            heap is a partial ordering anyway. Maybe what you want to do is HeapSort your data
            but we don't do that here it's just an enumeration of objects in the heap from top
            to bottom
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Heap.HeapEnumerator.myHeap">
            <summary>
            Stores the heap we are enumertaing
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Heap.HeapEnumerator.myCurrentPosition">
            <summary>
            Stores the current location in the heap that we are enumerating over
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Heap.HeapEnumerator.myIsValid">
            <summary>
            Indicates if the iterator has become invalid
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Heap.HeapEnumerator.#ctor(EQTG.General.Collections.Heap)">
            <summary>
            Ctor
            </summary>
            <param name="Heap"></param>
        </member>
        <member name="M:EQTG.General.Collections.Heap.HeapEnumerator.MoveNext">
            <summary>
            Implement IEnumerator::MoveNext
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Heap.HeapEnumerator.Invalidate">
            <summary>
            Used to mark as invalid
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Heap.HeapEnumerator.Reset">
            <summary>
            Implement IEnumerator::Reset
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.IDynamicPriorityItem">
            <summary>
            Summary description for IDynamicPriorityItem.
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.ListUtils">
            <summary>
            Miscellaneous utilities for lists (List, arrays, sorted lists, ...)
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.lower_bound``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Returns the index of the first element in the sorted IList sequence which does not compare less than value.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="val">The value to search</param>
            <returns>The index of the lower bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.lower_bound``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
            <summary>
            Returns the index of the first element in the sorted IList sequence which does not compare less than value.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <returns>The index of the lower bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.lower_bound``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the index of the first element in the sorted IList sequence which does not compare less than value.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <param name="comparer">The IComparer used for comparisons</param>
            <returns>The index of the lower bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.upper_bound``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Returns the index of the first element in the sorted IList sequence which compares greater than than value.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="val">The value to search</param>
            <returns>The index of the upper bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.upper_bound``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the index of the first element in the sorted IList sequence which compares greater than than value.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <param name="comparer">The IComparer used for comparisons</param>
            <returns>The index of the upper bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.upper_bound``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
            <summary>
            Returns the index of the first element in the sorted IList sequence which compares greater than than value.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <returns>The index of the upper bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.equal_range``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Returns the bounds of the largest subrange that includes all the elements of the [first,last[ with values equivalent to val.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="val">The value to search</param>
            <returns>The pair (lower bound, upper bound)</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.equal_range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
            <summary>
            Returns the bounds of the largest subrange that includes all the elements of the [first,last[ with values equivalent to val.
            In order to do comparisons the contained type must define IComparator
            </summary>
            <typeparam name="TKey">The type we look for</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <returns>The pair (lower bound, upper bound)</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.lower_bound``2(System.Collections.Generic.SortedList{``0,``1},``0)">
            <summary>
            Returns the index of the first element in the SortedList sequence which key does not compare less than value.
            In order to do comparisons the key type must define IComparator
            </summary>
            <typeparam name="TKey">The SortedList value type</typeparam>
            <typeparam name="TValue">The SortedList key type</typeparam>
            <param name="seq">The IList instance</param>
            <param name="val">The value to search</param>
            <returns>The index of the lower bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.lower_bound``2(System.Collections.Generic.SortedList{``0,``1},System.Int32,System.Int32,``0)">
            <summary>
            Returns the index of the first element in the SortedList sequence which key does not compare less than value.
            In order to do comparisons the key type must define IComparator
            </summary>
            <typeparam name="TKey">The SortedList value type</typeparam>
            <typeparam name="TValue">The SortedList key type</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <returns>The index of the lower bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.upper_bound``2(System.Collections.Generic.SortedList{``0,``1},``0)">
            <summary>
            Returns the index of the first element in the SortedList sequence which key compares greater than than value.
            In order to do comparisons the key type must define IComparator
            </summary>
            <typeparam name="TKey">The SortedList value type</typeparam>
            <typeparam name="TValue">The SortedList key type</typeparam>
            <param name="seq">The IList instance</param>
            <param name="val">The value to search</param>
            <returns>The index of the upper bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.upper_bound``2(System.Collections.Generic.SortedList{``0,``1},System.Int32,System.Int32,``0)">
            <summary>
            Returns the index of the first element in the SortedList sequence which key compares greater than than value.
            In order to do comparisons the key type must define IComparator
            </summary>
            <typeparam name="TKey">The SortedList value type</typeparam>
            <typeparam name="TValue">The SortedList key type</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <returns>The index of the upper bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.equal_range``2(System.Collections.Generic.SortedList{``0,``1},``0)">
            <summary>
            Returns the bounds of the largest subrange that includes all the elements of the [first,last[ with keys equivalent to val.
            In order to do comparisons the key type must define IComparator
            </summary>
            <typeparam name="TKey">The SortedList value type</typeparam>
            <typeparam name="TValue">The SortedList key type</typeparam>
            <param name="seq">The IList instance</param>
            <param name="val">The value to search</param>
            <returns>The pair (lower bound, upper bound)</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.equal_range``2(System.Collections.Generic.SortedList{``0,``1},System.Int32,System.Int32,``0)">
            <summary>
            Returns the bounds of the largest subrange that includes all the elements of the [first,last[ with keys equivalent to val.
            In order to do comparisons the key type must define IComparator
            </summary>
            <typeparam name="TKey">The SortedList value type</typeparam>
            <typeparam name="TValue">The SortedList key type</typeparam>
            <param name="seq">The IList instance</param>
            <param name="first">The index of the first element to search</param>
            <param name="last">The index of the last element to search (not included)</param>
            <param name="val">The value to search</param>
            <returns>The pair (lower bound, upper bound)</returns>
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.genListPermutations``1(System.Collections.Generic.List{``0},System.Collections.Generic.IList{System.Collections.Generic.IList{``0}},System.Int32)">
            <summary>
            Generate all the possible permutations going from start the to the end of a List of Lists
            and for each element from start to end
            </summary>
            <typeparam name="T">The type of the list elements</typeparam>
            <param name="res">A temporary array used for holding reluts</param>
            <param name="src">The List of List</param>
            <param name="index">The current index in src</param>
            <returns>An iterator which allows to loop through all permutations</returns>
            <seealso cref="M:EQTG.General.Collections.ListUtils.genListPermutations``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}})"/>&gt;
        </member>
        <member name="M:EQTG.General.Collections.ListUtils.genListPermutations``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}})">
            <summary>
            Generate all the possible permutations going from start the to the end of a List of Lists
            and for each element from start to end
            </summary>
            <typeparam name="T">The type of the list elements</typeparam>
            <param name="src">The List of List</param>
            <returns>An iterator which allows to loop through all permutations</returns>
            <example>
            int[][] src = {
                new int[] { 1 }, 
                new int[] { 20, 21, 22 }, 
                new int[] { 3 }, 
                new int[] { 4 }, 
                new int[] { 50, 51 },
                };
            foreach (List&lt;int&gt; i in genListPermutations(src))
            {
                Console.Write("[");
                foreach (int i1 in i)
                {
                    Console.Write("{0},", i1);
                }
                Console.WriteLine("]");
            }
            
            generates:
            
            [1,20,3,4,50,]
            [1,20,3,4,51,]
            [1,21,3,4,50,]
            [1,21,3,4,51,]
            [1,22,3,4,50,]
            [1,22,3,4,51,]
            </example>
        </member>
        <member name="T:EQTG.General.Collections.MultiCollectionEnumerator">
            <summary>
            A MultiCollectionEnumerator accepts a list of collections. It will enumerate each one in sequence
            making them look like one long sequence. For example:
            	Hashtable collection1;
            	Hashtable collection2;
            	ArrayList collection3;
            	
            	MultiCollectionEnumerator moreThanOneCollection = new MultiCollectionEnumerator(collection1, collection2, collection3);
            	foreach(object o in moreThanOneCollection)
            	{
            		System.Console.Out.Write(o.ToString + " ");
            	}
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.MultiCollectionEnumerator.myCollections">
            <summary>
            Reference the collections to enumerate elements from
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.MultiCollectionEnumerator.myCollectionIndex">
            <summary>
            Index of myCollections currently being iterated.
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.MultiCollectionEnumerator.myCollectionEnumerator">
            <summary>
            Enumerator of the currently selected collection.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.MultiCollectionEnumerator.#ctor(System.Collections.ICollection[])">
            <summary>
            Constructor takes a list of collections over which we'll iterate.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:EQTG.General.Collections.MultiCollectionEnumerator.GetEnumerator">
            <summary>
            Helper to so MultiCollectionEnumerator may be used directly with the foreach statement.
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.MultiCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.MultiCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Collections.MultiCollectionEnumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.MultiDictionaryIndexer">
            <summary>
            A MultiDictionaryIndexer accepts a list of dictionaries. It will index each one in sequence
            making them look like one long dictionary. It does not provide a set indexer howerver.
            
            For example:
            	Hashtable collection1;
            	Hashtable collection2;
            	Hashtable collection3;
            	
            	MultiDictionaryIndexer moreThanOneCollection = new MultiDictionaryIndexer(collection1, collection2, collection3);
            	object obj = moreThanOneCollection["lookThisUp"];
            	
            	// INVLALID: moreThanOneCollection["lookThisUp"] = this;
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.MultiDictionaryIndexer.myDictionaries">
            <summary>
            Reference the collections to enumerate elements from
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.MultiDictionaryIndexer.#ctor(System.Collections.IDictionary[])">
            <summary>
            Constructor takes a list of collections over which we'll iterate.
            </summary>
            <param name="args"></param>
        </member>
        <member name="T:EQTG.General.Collections.Generics.Pair`2">
            <summary>
            A simple pair
            </summary>
            <typeparam name="F">The type of the first member</typeparam>
            <typeparam name="S">The type of the second member</typeparam>
        </member>
        <member name="T:EQTG.General.Collections.Generics.ComparablePair`2">
            <summary>
            A comaparable pair. Lexicographic ordering is used for comparing pairs
            </summary>
            <typeparam name="F">The type of the first member. It must implement IComparable</typeparam>
            <typeparam name="S">The type of the second member It must implement IComparable</typeparam>
        </member>
        <member name="F:EQTG.General.Collections.Generics.ComparablePair`2.First">
            <summary>The pair first member</summary>
        </member>
        <member name="F:EQTG.General.Collections.Generics.ComparablePair`2.Second">
            <summary>The pair second member</summary>
        </member>
        <member name="M:EQTG.General.Collections.Generics.ComparablePair`2.#ctor(`0,`1)">
            <summary>
            Constructor
            </summary>
            <param name="fst">The pair first member</param>
            <param name="snd">The pair second member</param>
        </member>
        <member name="M:EQTG.General.Collections.Generics.ComparablePair`2.CompareTo(EQTG.General.Collections.Generics.ComparablePair{`0,`1})">
            <see cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:EQTG.General.Collections.Generics.ComparablePair`2.Equals(EQTG.General.Collections.Generics.ComparablePair{`0,`1})">
            <see cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:EQTG.General.Collections.Generics.ComparablePair`2.Equals(System.Object)">
            <see cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:EQTG.General.Collections.Generics.ComparablePair`2.ToString">
            <see cref="M:System.Object.ToString"/>
        </member>
        <member name="M:EQTG.General.Collections.Generics.ComparablePair`2.GetHashCode">
            <see cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:EQTG.General.Collections.Set">
            <summary>
            Implements the abstract data type Set
            
            A Set is an unordered collection where each value occurs at most once. Objects may be contained by
            a none negative number of sets
            
            TODO: Make this an ICollection
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Set.OurEmptySet">
            <summary>
            The one true empty set
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Set.myElements">
            <summary>
            Stores all the objects in this set
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.Set.myName">
            <summary>
            The name of this set
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.Set.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:EQTG.General.Collections.Set.FindSetsContaining(System.Object)">
            <summary>
            Returns the collection of sets that the given object is in (the collection may be empty)
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.Set.FindASetContaining(System.Object)">
            <summary>
            Returns a set containing this element else returns null
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.Set.Contains(System.Object)">
            <summary>
            Checks if an object is in this set
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.Set.Add(System.Object)">
            <summary>
            Adds a SetElement to a set
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:EQTG.General.Collections.Set.Remove(System.Object)">
            <summary>
            Removes a SetElement from this set
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:EQTG.General.Collections.Set.ToString">
            <summary>
            Returns a string representing this object
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Collections.Set.Members">
            <summary>
            Returns an enumerator you can use to see the elements in this set
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.Set.Count">
            <summary>
            Returns the Cardinality of the Set
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.SetElement">
            <summary>
            Sets contain imuteable SetElement objects. A SetElement contains a value which is the actual object stored
            in the set. The Universe of objects can also be determined using this class static OurUniverse. This
            is a Hash of object to SetElement object.
            
            NOTE their must only ever be one SetElement object for each object. Hence the best way to create these
            objects is to use FindOrCreate.
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.SetElement.OurUniverse">
            <summary>
            This is the universe of all objects that we can place in a set.
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.SetElement.mySets">
            <summary>
            The sets we are a member of
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.SetElement.myValue">
            <summary>
            This is the value contained in this SetElement
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SetElement.#ctor(System.Object)">
            <summary>
            Ctor
            </summary>
            <param name="valueObject"></param>
        </member>
        <member name="M:EQTG.General.Collections.SetElement.FindOrCreate(System.Object)">
            <summary>
            Tries to find a SetElement object for the given object. If one can not be found then it is created
            and returned
            </summary>
            <param name="valueObject"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.SetElement.AddToSet(EQTG.General.Collections.Set)">
            <summary>
            Adds this object to a set.
            </summary>
            <param name="setObject"></param>
        </member>
        <member name="M:EQTG.General.Collections.SetElement.RemoveFromSet(EQTG.General.Collections.Set)">
            <summary>
            Removes an object from a set
            </summary>
            <param name="setObject"></param>
        </member>
        <member name="P:EQTG.General.Collections.SetElement.Value">
            <summary>
            Returns the value of this SetElement
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.LexicographicalCompare`2">
            <summary>
            Allow the comparison of 2 collections by doing a "lexicographical" comparison
            </summary>
            <typeparam name="TCollection"></typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="F:EQTG.General.Collections.LexicographicalCompare`2.myComparer">
            <summary>The object used for key comparisons</summary>
        </member>
        <member name="M:EQTG.General.Collections.LexicographicalCompare`2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.LexicographicalCompare`2.#ctor(System.Collections.Generic.IComparer{`1})">
            <summary>
            Constructor
            </summary>
            <param name="comparer">A comparer other than the default for TKey</param>
        </member>
        <member name="M:EQTG.General.Collections.LexicographicalCompare`2.Compare(`0,`0)">
            <summary>
            <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.SortedSet`1">
            <summary>
            A simple set implementation based on a sorted array
            </summary>
            <typeparam name="TKey">The type of the set elements</typeparam>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.ourDefaultCapacity">
            <summary>The initial default capacity</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.ourEmptyKeys">
            <summary>the array to use when there is no elements</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.ourSetCmp">
            <summary>The comparer used for comparing instances of this class</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.mySyncRoot">
            <summary>The object used  to synchronize access to the ICollection</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.myComparer">
            <summary>The object used for comparisons</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.mySize">
            <summary>The set size</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.myKeys">
            <summary>The real container</summary>
        </member>
        <member name="F:EQTG.General.Collections.SortedSet`1.myThrowOnDuplicate">
            <summary>When a key is added and already exists, do we throw an exception?</summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#cctor">
            <summary>
            Class constructor
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="comparer">The compare to use instead of Comparer{TKey}.Default</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Constructor
            </summary>
            <param name="collection">use the elements of this collection for populating the set</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">the initial capacity</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>capacity</c> is out of range.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="comparer">The compare to use instead of Comparer{TKey}.Default</param>
            <param name="collection">use the elements of this collection for populating the set</param>
            <exception cref="T:System.ArgumentNullException"><c>collection</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="capacity">the initial capacity</param>
            <param name="comparer">The compare to use instead of Comparer{TKey}.Default</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Add(`0)">
            <summary>
            <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Find(`0)">
            <summary>Find a value stored in the set</summary>
            <param name="key">The value to find</param>
            <returns>null if no match is found, a reference to the stored object otherwise</returns>
            <exception cref="T:System.ArgumentException">Unable to find the key</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.AddAndGetReference(`0)">
            <summary>
            Add an element to the set
            </summary>
            <param name="key">the element to add</param>
            <returns>the element as stored in the set (which may be a different instance than the key argument)</returns>
            <exception cref="T:System.ArgumentNullException"><c>key</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.AddUnique(`0)">
            <summary>
            Add an element to the set and return true if the element was not already there
            </summary>
            <param name="key">the element to add</param>
            <returns>true if the element was not already there</returns>
            <exception cref="T:System.ArgumentNullException"><c>key</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Add(EQTG.General.Collections.SortedSet{`0})">
            <summary>
            Merge this set with another set
            </summary>
            <param name="set">The set to add</param>
            <remarks>The comparer used by both sets should be the same</remarks>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Clear">
            <summary>
            <see cref="M:System.Collections.Generic.ICollection`1.Clear"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Contains(`0)">
            <summary>
            <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Contains(System.Object)">
            <summary>
            Determines whether the ICollection contains a specific value
            </summary>
            <param name="key">The value to search</param>
            <returns>true if such key is in the set</returns>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensure that the capacity of the internal array is sufficient
            </summary>
            <param name="min">the minimum capacity</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Index(`0)">
            <summary>
            The index of a given key in the internal array
            </summary>
            <param name="key">The key to search</param>
            <returns>-1 if the key has not be found, the internal array index otherwise</returns>
            <exception cref="T:System.ArgumentNullException"><c>key</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Insert(System.Int32,`0)">
            <summary>
            Insert a new value at a given index in the internal array
            </summary>
            <param name="index">The index where to insert</param>
            <param name="key">The key to insert</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.IsCompatibleType(System.Object)">
            <summary>
            Check that an object is of the right type for this type of set
            </summary>
            <param name="key">The object to check</param>
            <returns>true if the object is comaptible</returns>
            <exception cref="T:System.ArgumentNullException"><c>key</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Remove(System.Object)">
            <summary>
            Removes the occurrence of a specific object from the set
            </summary>
            <param name="key">The key to remove</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Remove(`0)">
            <summary>
            <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.RemoveAt(System.Int32)">
            <summary>
            Remove a given object at a given position in the internal array
            </summary>
            <param name="index">The object index</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>index</c> is out of range.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <exception cref="T:System.ArgumentException">Invalid array type</exception>
            <exception cref="T:System.ArgumentNullException"><c>array</c> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>arrayIndex</c> is out of range.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Add(System.Object)">
            <summary>
            Add an object to the set
            </summary>
            <param name="key">The object to add</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.System#Collections#Generic#IEnumerable{TKey}#GetEnumerator">
            <summary>
            <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the set, if that number is less than a threshold value.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.VerifyType(System.Object)">
            <summary>
            Throw an exception if an object is not compatible with this set
            </summary>
            <param name="key">the objectt to check</param>
            <exception cref="T:System.ArgumentNullException">Argument is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.ContainsAll(EQTG.General.Collections.SortedSet{`0})">
            <summary>
            Check if a set is included inside this one
            </summary>
            <param name="s">The set to check</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><c>s</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Equals(System.Object)">
            <summary><see cref="M:System.Object.Equals(System.Object)"/></summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.GetHashCode">
            <summary><see cref="M:System.Object.GetHashCode"/></summary>
            <remark>We must prevent the accidental use of this class by a HashTable as we have changed IsEqual</remark>
            <exception cref="T:System.NotImplementedException">GetHashCode is not implemented for SimpleSet&lt;T&gt;</exception>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.CompareTo(System.Object)">
            <summary><see cref="M:System.IComparable.CompareTo(System.Object)"/></summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.CompareTo(EQTG.General.Collections.SortedSet{`0})">
            <summary><see cref="M:System.IComparable`1.CompareTo(`0)"/></summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.IndexUpperBound(`0)">
            <summary>
            Returns the index of the upper bound of a given key 
            </summary>
            <param name="key">The key to look for</param>
            <returns>the index of the upper bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.IndexLowerBound(`0)">
            <summary>
            Returns the index of the lower bound of a given key 
            </summary>
            <param name="key">The key to look for</param>
            <returns>the index of the lower bound</returns>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.Clone">
            <summary>
            <see cref="M:System.ICloneable.Clone"/>
            <remarks>This implementation does a shallow copy</remarks>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.CloneImpl``1">
            <summary>
            Generic version of Clone which can be used by derived class as the base for their clone method
            </summary>
            <typeparam name="SetDerivedType"></typeparam>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.Capacity">
            <summary>
            Gets or sets the number of elements that the set can contain
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>value</c> is out of range.</exception>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.ThrowOnDuplicate">
            <summary>
            If true, an exception is thrown when we try to add a value already present in the set
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.Comparer">
            <summary>
            Get the comparer used for comparisons
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.Count">
            <summary>
            <see cref="P:System.Collections.Generic.ICollection`1.Count"/>
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.IsReadOnly">
            <summary>
            <see cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.First">
            <summary>
            Returns the first element of the set (the smallest as the collection is sorted)
            </summary>
            <exception cref="T:System.InvalidOperationException">First called on an empty set!</exception>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.Last">
            <summary>
            Returns the last element of the set (the largest as the collection is sorted)
            </summary>
            <exception cref="T:System.InvalidOperationException">First called on an empty set!</exception>
        </member>
        <member name="T:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1">
            <summary>
            Internal class used for enumerating over the key array
            </summary>
            <typeparam name="T">The enumerator type</typeparam>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1.#ctor(`1[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="array">The target</param>
            <param name="size">The real siez of the array</param>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1.MoveNext">
            <summary>
            <see cref="M:System.Collections.IEnumerator.MoveNext"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1.Reset">
            <summary>
            <see cref="M:System.Collections.IEnumerator.Reset"/>
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1.Dispose">
            <summary>
            <see cref="M:System.IDisposable.Dispose"/>
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            <see cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.SortedSet`1.ArrayEnumerator`1.Current">
            <summary>
            <see cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">Enum already ended</exception>
        </member>
        <member name="T:EQTG.General.Collections.TopList">
            <summary>
            Summary description for TopList.
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.Transforms">
            <summary> Title:        EQTG
            Description:
            Copyright:    Copyright (c) 2001
            Company:      Citigroup
            </summary>
            <author> 
            </author>
            <version> 1.0
            
            </version>
        </member>
        <member name="T:EQTG.General.Collections.Tuple">
            <summary>
            Represents small ordered tuples of objects. This DOES NOT implement any of the Collection/Enumerable type interfaces. 
            The key properties are that .Equals and .GetHashCode are defined in terms of the entries so that, e.g.  a Tuple can be 
            used as the key to a Hashtable.
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.TwoDimensionalTable">
            <summary>
            Class to handle a two dimensional table
            works by combining the two keys into a single key for a regular hashtable
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.TwoDimensionalTable.Add(System.Object,System.Object,System.Object)">
            <summary>
            Insert a new entry
            </summary>
            <param name="keyX">One key</param>
            <param name="keyY">other key</param>
            <param name="val">Value</param>
        </member>
        <member name="M:EQTG.General.Collections.TwoDimensionalTable.Lookup(System.Object,System.Object)">
            <summary>
            Look up an entry
            </summary>
            <param name="keyX">One key</param>
            <param name="keyY">Other key</param>
            <returns>value</returns>
        </member>
        <member name="P:EQTG.General.Collections.TwoDimensionalTable.Item(System.Object)">
            <summary>
            Gets hold of a colum, which can the be indexed again. Thus list[a][b] will work
            </summary>
        </member>
        <member name="T:EQTG.General.Collections.ValidUntiledMap`2">
            <summary>
            Implements  map[key1][validUntilDate].....get function finds best validUntil'ed Object
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.ValidUntiledMap`2.getLatest(`0)">
            <exception cref="T:System.ArgumentNullException"><c>key1</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.ValidUntiledMap`2.getAll(`0)">
            <exception cref="T:System.ArgumentNullException"><c>key1</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.ValidUntiledMap`2.get(`0,EQTG.General.BasicTypes.Date,System.Boolean)">
            <exception cref="T:System.ArgumentNullException"><c>key1</c> is null.</exception>
        </member>
        <member name="M:EQTG.General.Collections.ValidUntiledMap`2.getRange(`0,EQTG.General.BasicTypes.Date,EQTG.General.BasicTypes.Date)">
            <summary>
            Returns the list of values for the date interval ]from, to]
            </summary>
            <param name="key1">The key</param>
            <param name="from">The start of the date interval (excluded). If null, the start is the minimum date for this key</param>
            <param name="to">The end of the date interval (included). If null, the end will include the maximum date for this key</param>
            <returns>A list of values</returns>
        </member>
        <member name="T:EQTG.General.Collections.ValidUntiledMapPS">
            <summary>
            Implements  map[key1][validUntilDate].....get function finds best validUntil'ed Object
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.ValidUntiledMapPS.putOrUpdate(System.Object,EQTG.General.BasicTypes.Date,System.Object)">
            <summary>
            add a new value or overwrite if it already exists in map
            </summary>
            <param name="key1">main key</param>
            <param name="key2">validUntil data</param>
            <param name="val">value</param>
        </member>
        <member name="T:EQTG.General.Collections.WorkerThreadQueue">
            <summary>
            A worker thread Deques work objects from a WorkerThreadQueue and then processes the work object accordingly
            
            The WorkerThreadQueue has a blocking Deque when empty so that we don't have to write an inefficient
            loop that checks if the queue is empty and if it is either spins or goes to sleep. Thus a typical worker
            thread might have:
            
            public void ThreadMain()
            {
            	while(myKeepProcessing)
            	{
            		// Will block until there is work to do
            		WorkItem workItem = (WorkItem)myWorkerThreadQueue.Deque();
            		workItem.Process();
            	}
            }
            
            NOTE: 1. ThreadPool does something similar but you may then only have one work queue per process
                  2. The object is threadSafe - there is no single threaded version
            
            20080617: a new Dequeue function and stop queue idea. Improvements are:
            	- can release the blocking state and let the application shutdown gracefully.
            	- new Deqeue function avoid get item from empty queue
            NOTE: Not affect current logic!!!
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.WorkerThreadQueue.myHaveWorkToDo">
            <summary>
            The object used to block and signal the Dequeuing thread
            </summary>
        </member>
        <member name="F:EQTG.General.Collections.WorkerThreadQueue.myIsStopping">
            <summary>
            The thread is in stop state
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.#ctor">
            <summary>
            Initializes a new instance of the Queue class that is empty, has the default initial capacity and uses the default growth factor.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.#ctor(System.Collections.ICollection)">
            <summary>
            Initializes a new instance of the Queue class that contains elements copied from the specified collection, has the same initial capacity as the number of elements copied and uses the default growth factor.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the Queue class that is empty, has the specified initial capacity and uses the default growth factor.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.#ctor(System.Int32,System.Single)">
            <summary>
            Initializes a new instance of the Queue class that is empty, has the specified initial capacity and uses the specified growth factor.
            </summary>
            <param name="i"></param>
            <param name="f"></param>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Clear">
            <summary>
            Removes all objects from the Queue.
            </summary>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Clone">
            <summary>
            Creates a shallow copy of the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Contains(System.Object)">
            <summary>
            Determines whether an element is in the Queue
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the Queue elements to an existing one-dimensional Array, starting at the specified array index.
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Dequeue">
            <summary>
            Removes and returns the object at the beginning of the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Enqueue(System.Object)">
            <summary>
            Adds an object to the end of the Queue
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Dequeue(System.Object@)">
            <summary>
            Removes and returns the object at the beginning of the Queue if having.
            It will return to response the Stop function
            </summary>
            <param name="item"></param>
            <returns>true only if got the item</returns>
        </member>
        <member name="M:EQTG.General.Collections.WorkerThreadQueue.Stop">
            <summary>
            Set to stop state and release (signal) the blocking in Dequeue function
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.WorkerThreadQueue.Count">
            <summary>
            Gets the number of elements contained in the Queue
            </summary>
        </member>
        <member name="P:EQTG.General.Collections.WorkerThreadQueue.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the Queue is synchronized (thread-safe).
            </summary>
        </member>
        <member name="T:EQTG.General.CounterPerInterval">
            <summary>
            Summary description for CounterPerInterval.
            </summary>
        </member>
        <member name="F:EQTG.General.CounterPerInterval.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.BasicDiagnostics">
            <summary>
            Class to kick off basic diagnostics (doesn't support RV diagnostics or others)
            Supports Console, Event Log, File and Debug diagnostics
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.BasicDiagnostics.Initialise(EQTG.General.Application.CommandParameterList)">
            <summary>
            Function to kick off diagnostics
            </summary>
            <param name="commandParameters">Parameter list</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.BasicDiagnostics.DiagCmd(System.Object[])">
            <summary>
            Handler for the diag appcommand
            </summary>
            <param name="args">Appcommand parameters: a type name (including namespace) followed 
            by a diagnostics level.</param>
        </member>
        <member name="F:EQTG.General.Diagnostic.BasicDiagnostics.myViewList">
            <summary>
            View list storage
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.BasicDiagnostics.myCommandParameters">
            <summary>
            Storage of externally supplied command parameters
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.BasicDiagnostics.myInstaller">
            <summary>
            Installer instance
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.BasicDiagnostics.ViewList">
            <summary>
            View list property
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.BasicDiagnostics.Installer">
            <summary>
            Installer instance property
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.BasicDiagnostics.DefaultInstance">
            <summary>
            Default instance for convenience
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.ClassBehaviourDiagnostics">
            <summary>
                Behaviour Diagnostics add granularity to ClassDiagnostics. The ClassDiagnostics namespace is subdivided by the Behaviour names
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsMethodsBase">
            <summary>
            Common implementation for different diagnostics types that suuply their Namespaces in different ways.
            Used for ClassDiagnostics, ClassBehaviourDiagnostics and Diagnostics itself
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.HookInExternalLogger(EQTG.General.Diagnostic.DiagnosticsMethodsBase.Log)">
            <summary>
            
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogFatalError(System.String)">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="text">Text describing fatal error</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogFatalError(System.String,System.Object[])">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="format">Text describing fatal error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogError(System.String)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogError(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogAndThrowError(System.String)">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogAndThrowError(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogWarning(System.String)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the warning condition</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogWarning(System.String,System.Object[])">
            <summary>
            Log an error to diagnostics system and then throw it
            </summary>
            <param name="format">Text describing the error</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogInfo(System.String)">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="text">Text describing the informational event</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogInfo(System.String,System.Object[])">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="format">Text describing the informational event</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogDebug(System.String)">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="text">Debug text</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogDebug(System.String,System.Object[])">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="format">Debug text</param>
            <param name="p">Parameters to insert into the message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogFatalErrorOccurrence(System.String,System.Int32)">
            <summary>
            Log a fatal error to diagnostics system
            </summary>
            <param name="text">Text describing fatal error</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogErrorOccurrence(System.String,System.Int32)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the error</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogWarningOccurrence(System.String,System.Int32)">
            <summary>
            Log an error to diagnostics system
            </summary>
            <param name="text">Text describing the warning condition</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogInfoOccurrence(System.String,System.Int32)">
            <summary>
            Log a warning to diagnostics system
            </summary>
            <param name="text">Text describing the informational event</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.LogDebugOccurrence(System.String,System.Int32)">
            <summary>
            Log debug to diagnostics system
            </summary>
            <param name="text">Debug text</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Write information to all registered views with no line-feed, including namespace
            </summary>
            <param name="text">Text to write</param>
            <param name="level">Severity of this diagnostics information</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.IsAnyoneListening(EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Function to check if anyone is interested in the subject we are reading.
            </summary>
            <param name="level">Diagnostics level</param>
            <returns>True if any diagnostics view is interested in our output</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Write information to all registered views, including line-feed, including namespace
            </summary>
            <param name="text">Text to write</param>
            <param name="level">Severity of this diagnostics information</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.WriteLineToInterestedViews(System.String,EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Directly write to views rather than go via the Diagnostics class
            </summary>
            <param name="text">Message to log</param>
            <param name="level">Level of message</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.VerifyViewsAndLevelsConfig">
            <summary>
            Verify that our list of interested diagnostics views is correct
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsMethodsBase.ReestablishInterestedViewsAndLevels">
            <summary>
            Check and which views (if any) are interested in the diagnostic.
            This is necesary to speed up performance
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsMethodsBase.myLastDiagnosticsVersionId">
            <summary>
            Counter for version of diagnostics we currently have
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsMethodsBase.myMinimumLevel">
            <summary>
            We can cut out the need to iterate through the interested views on each occasion by
            keeping a minimum level as well. 
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsMethodsBase.myInterestedViews">
            <summary>
            We cut down the load in making diagnostics calls by storing pointers to all the views that are 
            interested in the diagnostics we are producing. 
            Changes to the views configuration will mean that we have reestablish the interested views.
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsMethodsBase.DiagnosticsNamespace">
            <summary>
            Retrieve the diagnostics namespace
            </summary>
            <returns>Diagnostics namespace as string</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsMethodsBase.minLogLevel">
            <summary>
            Return the  minimum diagnostics value that  we currently have
            Client can use this info to check if log message should be passed to Log. This will reduce 
            string copy numbers.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.ClassBehaviourDiagnostics.#ctor(EQTG.General.Diagnostic.ClassDiagnostics,System.String)">
            <summary>
            Constructor takes a ClassDiagnostics instance, to supply the full diagnostics namespace.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.ClassBehaviourDiagnostics.BehaviourName">
            <summary>
            Get the diagnostics behaviour name
            </summary>
            <returns>Behaviour name</returns>
        </member>
        <member name="F:EQTG.General.Diagnostic.ClassBehaviourDiagnostics.myBehaviourName">
            <summary>
            namespace for this class diagnostics instance
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.ClassBehaviourDiagnostics.myOwnerClassDiagnostics">
            <summary>
            ClassDiagnostics owner to supply namespace within which to embed behaviour name
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.ClassBehaviourDiagnostics.DiagnosticsNamespace">
            <summary>
            Full diagnostics namespace of this behaviour
            </summary>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.ClassDiagnostics">
            <summary>
            	Per Class Diagnostics, that allow namespaced diagnostics.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.ClassDiagnostics.#ctor">
            <summary>
            Constructor is smart, in that it finds the class namespace
            </summary>
            <remarks>
            Use this when you  can guarantee that your code has ReflectionPermission 
            (e.g. it's installed on the machine, or if the network location where it runs is fully
            trusted)
            </remarks>
        </member>
        <member name="M:EQTG.General.Diagnostic.ClassDiagnostics.#ctor(System.Type)">
            <summary>
            Constructs a ClassDiagnostics to wrap the given type
            </summary>
            <remarks>
            Call this if you can't guarantee whether your code has ReflectionPermission 
            (e.g. if you may be running on an untrusted network location)
            </remarks>
            <param name="callerType">Type that owns this ClassDiagnostics</param>
        </member>
        <member name="F:EQTG.General.Diagnostic.ClassDiagnostics.myNamespace">
            <summary>
            namespace for this class diagnostics instance
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.ClassDiagnostics.DiagnosticsNamespace">
            <summary>
            Retrieve the diagnostics namespace
            </summary>
            <returns>Diagnostics namespace as string</returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsSettings">
            <summary>
            Base class for diagnostics settings taken from app.config.
            </summary>
            <remarks>
            <para>
            This class is the base class for objects created from a diagnostics section in app.config. Diagnostics 
            sections should be structured like one of the following examples:
            </para>
            <code escaped="true">
            <!-- Take diagnostics settings from DiagnosticsConfig.xml in the application's directory -->
            <consoleDiagnostics href="local://DiagnosticConfigs.xml"/>
            </code>
            <code escaped="true">
            <!-- Take diagnostics settings from DiagnosticsConfig.xml in the current directory -->
            <consoleDiagnostics href="file://DiagnosticConfigs.xml"/>
            </code>
            <code escaped="true">
            <!-- Show warnings, errors and fatal errors -->
            <consoleDiagnostics href="+&gt;:wef"/>
            </code>
            <code escaped="true">
            <!-- Show warnings, errors and fatal errors -->
            <consoleDiagnostics href="eqtgapp://&lt;EQTG level=&quot;warning&quot; /&gt;"/>
            </code>
            <code escaped="true">
            <!-- Use diagnostics settings specified in app.config -->
            <consoleDiagnostics>
            	<EQTG level="warning">
            		<Database level="error"/>
            	</EQTG>
            </consoleDiagnostics>
            </code>
            <para>For examples of configurations for each of the types of diagnostic, see the examples
            linked to below.</para>
            </remarks>
            <seealso cref="T:EQTG.General.Diagnostic.ConsoleDiagnosticsSectionHandler"/>
            <seealso cref="T:EQTG.General.Diagnostic.DebugDiagnosticsSectionHandler"/>
            <seealso cref="T:EQTG.General.Diagnostic.EventLogDiagnosticsSectionHandler"/>
            <seealso cref="T:EQTG.General.Diagnostic.FileDiagnosticsSectionHandler"/>
            <seealso cref="T:EQTG.General.Diagnostic.MailDiagnosticsSectionHandler"/>
            <seealso cref="T:EQTG.General.Diagnostic.TelnetDiagnosticsSectionHandler"/>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsSettings.#ctor(System.Xml.XmlElement)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Diagnostic.DiagnosticsSettings"/> class.
            </summary>
            <param name="settings"><see cref="T:System.Xml.XmlElement"/> taken from app.config.</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsSettings.CreateView">
            <summary>
            Creates an appropriately configured <see cref="T:EQTG.General.Diagnostic.DiagnosticsView"/>.
            </summary>
            <returns><see cref="T:EQTG.General.Diagnostic.DiagnosticsView"/></returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsSettings.LevelConfig">
            <summary>
            Gets the diagnostics levels configuration.
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.ConsoleDiagnostics">
            <summary>
            Console diagnostics implementation. Writes diagnostics to a Win32 Console
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsView">
            <summary>
            Base implementation for diagnostic views.
            Includes a filter for which diagnostics levels should be written for this view.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.#ctor(System.Xml.XmlElement)">
            <summary>
            DiagnosticsView instantiation. Sets the minimum severity for which diagnostics must be reported by this view.
            </summary>
            <param name="diagnosticsLevel">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.#ctor(System.Xml.XmlDocument)">
            <summary>
            DiagnosticsView instantiation. Sets the minimum severity for which diagnostics must be reported by this view.
            </summary>
            <param name="diagnosticsLevel">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.SettingsFromString(System.String)">
            <summary>
            Diagnostics level from string, typically from Registry of Command Line. Determined by character after ':'
            </summary>
            <param name="levelString">String representation of diagnostics setting</param>
            <returns>Diagnostics level</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.LoadDefaultErrorLevels(System.Xml.XmlDocument)">
            <summary>
            If no configuration settings (file or direct XML) have been assigned, 
            provide a default configuration to ensure correct behaviour.
            By default, warnings and higher will be reported.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.StopProcessingThreads">
            <summary>
            Chance to shut down views cleanly
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.ShutdownView">
            <summary>
            Close the view down cleanly
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.RemoveEventHandlers">
            <summary>
            Remove this handler from the Write and WriteLine
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.AmIListening(System.Object,EQTG.General.Diagnostic.AnyoneListeningEventArgs)">
            <summary>
            Indicate if we are listening to the subject specified in the args
            </summary>
            <param name="args">IsAnyoneListening args</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.AddWriteLineHandler(EQTG.General.Diagnostic.Diagnostics.DoWriteLine)">
            <summary>
            Add handler for WriteLine event
            </summary>
            <param name="writeLineHandler">Handler</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.AddWriteHandler(EQTG.General.Diagnostic.Diagnostics.DoWrite)">
            <summary>
            Add handler for Write event
            </summary>
            <param name="writeHandler">Write handler</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostics to console - implementation of DoWriteLineEvent
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostic to console with no line-feed. Implementation of DoWrite Event
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.ShouldWrite(EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Determine if a given write should be done given the view's diagnostics threshold level
            </summary>
            <param name="level">Level at or above which diagnostics should be given.</param>
            <returns>Whether the diagnostic text should be logged</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.LevelFromSubject(System.String)">
            <summary>
            Maintain a hash of level from namespace for efficiency
            </summary>
            <param name="diagnosticsNamespace">Diagnostics namespace of this item</param>
            <returns>Level for this item</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.GetSinkTag(System.Xml.XmlElement,System.String)">
            <summary>
            Find mathcing node with name corresponding to tag
            </summary>
            <param name="sink">Element to search</param>
            <param name="tag">Find single tag element of name tag</param>
            <returns>Node matching tag</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.BuildLine(EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Find mathcing node with name corresponding to tag
            </summary>
            <param name="sink">Element to search</param>
            <param name="tag">Find single tag element of name tag</param>
            <returns>Node matching tag</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsView.AddAnyoneListeningHandler">
            <summary>
            Internal utility to add handler for 'AnhyoneListening' functionaltiy
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsView.myWriteLineDelegate">
            <summary>
            Handler for WriteLine Events
            We need to keep a reference to it so we can remove it if requested
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsView.myWriteDelegate">
            <summary>
            Handler for Write events
            We need to keep a reference to it so we can remove it if requested
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsView.myAnyoneListeningHandler">
            <summary>
            Handler for AnyoneListening calls.
            We need to keep a reference to it so we can remove it if requested
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsView.myLevelsBySubject">
            <summary>
            Maintain a hash of level from namespace for efficiency
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsView.myDisabledFlag">
            <summary>
            Flag to tell if this view is disabled
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsView.mySettings">
            <summary>
            Diagnostics view filtering - XML tree representing diagnostics levels
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsView.Disabled">
            <summary>
            The disabled property is used to turn view output off in the disabled = true state and on when
            in the disabled = false state.
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsView.Settings">
            <summary>
            Gets or sets the diagnostics settings
            </summary>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsView.Name">
            <summary>
            Name of this view
            </summary>
            <returns>View Name</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.ConsoleDiagnostics.#ctor(System.Xml.XmlElement)">
            <summary>
            Construction of ConsoleDiagnostics view
            </summary>
            <param name="level">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.ConsoleDiagnostics.GetConsoleColours">
            <summary>
            Gets the console Colours as they currently are
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.ConsoleDiagnostics.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostics to console - implementation of DoWriteLineEvent
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.ConsoleDiagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostic to console with no line-feed. Implementation of DoWrite Event
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.ConsoleDiagnostics.Install(EQTG.General.Application.CommandParameterList,EQTG.General.Application.CommandParameter,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Diagnostics installation event implementation
            </summary>
            <param name="cmdLine">CommandParameterList instance</param>
            <param name="arg">Single argument being dealt with</param>
            <param name="diagnosticsViews">List of views to which any new instantiation must be added</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.ConsoleDiagnostics.InstallXml(System.Xml.XmlElement,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Configure diagnostics type from XML
            </summary>
            <param name="configDoc">XML Source document</param>
            <param name="diagnosticsViews">List of views to add new view to</param>
        </member>
        <member name="P:EQTG.General.Diagnostic.ConsoleDiagnostics.DefaultName">
            <summary>
            Name for this diagnostics view. Useful for command line specification of diagnostics views.
            </summary>
            <returns>Diagnostics view name</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.ConsoleDiagnostics.Name">
            <summary>
            Name of this view
            </summary>
            <returns>View Name</returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.ConsoleDiagnosticsSectionHandler">
            <summary>
            Handler for the consoleDiagnostics section in app.config.
            </summary>
            <example>
            <para>To use this class, add the following to your app.config:</para>
            <code escaped="true">
            <configuration>
            	<configSections>
            		<section name="consoleDiagnostics" type="EQTG.General.Diagnostic.ConsoleDiagnosticsSectionHandler, EQTG" />
            	</configSections>
            	<appSettings>
            		<add key="diagnostics" value="consoleDiagnostics" />
            	</appSettings>
            	<consoleDiagnostics>
            		<EQTG level="info">
            			<Database>
            				<LoggedDatabase>
            					<LoggedCommand level="debug" />
            				</LoggedDatabase>
            			</Database>
            		</EQTG>
            	</consoleDiagnostics>
            </configuration>
            </code>
            </example>
        </member>
        <member name="T:EQTG.General.Diagnostic.DebugDiagnostics">
            <summary>
            Debug diagnostics implementation. Writes diagnostics to System.Diagnostics.Debug
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DebugDiagnostics.#ctor(System.Xml.XmlElement)">
            <summary>
            Construction of DebugDiagnostics view
            </summary>
            <param name="level">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DebugDiagnostics.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostics to debug window - implementation of DoWriteLineEvent
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DebugDiagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostic to System.Diagnostics.Debug with no line-feed. Implementation of DoWrite Event
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DebugDiagnostics.Install(EQTG.General.Application.CommandParameterList,EQTG.General.Application.CommandParameter,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Diagnostics installation event implementation
            </summary>
            <param name="cmdLine">CommandParameterList instance</param>
            <param name="arg">Single argument being dealt with</param>
            <param name="diagnosticsViews">List of views to which any new instantiation must be added</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DebugDiagnostics.InstallXml(System.Xml.XmlElement,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Configure diagnostics type from XML
            </summary>
            <param name="configDoc">XML Source document</param>
            <param name="diagnosticsViews">List of views to add new view to</param>
        </member>
        <member name="P:EQTG.General.Diagnostic.DebugDiagnostics.DefaultName">
            <summary>
            Name for this diagnostics view. Useful for command line specification of diagnostics views.
            </summary>
            <returns>Diagnostics view name</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.DebugDiagnostics.Name">
            <summary>
            Name of this view
            </summary>
            <returns>View Name</returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.DebugDiagnosticsSectionHandler">
            <summary>
            Handler for the debugDiagnostics section in app.config.
            </summary>
            <example>
            <para>To use this class, add the following to your app.config:</para>
            <code escaped="true">
            <configuration>
            	<configSections>
            		<section name="debugDiagnostics" type="EQTG.General.Diagnostic.DebugDiagnosticsSectionHandler, EQTG" />
            	</configSections>
            	<appSettings>
            		<add key="diagnostics" value="debugDiagnostics" />
            	</appSettings>
            	<debugDiagnostics>
            		<EQTG level="info">
            			<Database>
            				<LoggedDatabase>
            					<LoggedCommand level="debug" />
            				</LoggedDatabase>
            			</Database>
            		</EQTG>
            	</debugDiagnostics>
            </configuration>
            </code>
            </example>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticManager">
            <summary>
            Generally applicable specialisation of BasicDiagnostics that reads configuration from an
            XML config file.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticManager.GetEventLog">
            <summary>
            Access to event log. Used as delegate
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticManager.SetConfigDoc(System.Xml.XmlElement)">
            <summary>
            Sets a new configuration document and refreshes the diagnostic views
            </summary>
            <param name="configDoc">Configuration XML</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticManager.GetNamespaceFromXML(System.Xml.XmlElement)">
            <summary>
            Retrieve the namespace from XML
            </summary>
            <param name="xml">XML Element contain ing namespace</param>
            <returns>Namespace for diagnostics</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticManager.StartDiagnostics(System.String,System.Reflection.Assembly,System.Diagnostics.EventLog,System.Xml.XmlElement)">
            <summary>
            <param name="namespaceRoot">Root for where the diagnostics will be listed</param>
            <param name="assembly">The assembly where we should look for logging sources</param>
            <param name="eventLog">Event log to which event log messages will be sent. May be null if event log messages are no wanted</param>
            <param name="configDoc">Configuration rules in XML format</param>
            Set up the diagnostics now
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticManager.InstallViews(EQTG.General.Diagnostic.DiagnosticsInstaller)">
            <summary>
            Method to install all possible views prior to actually creating them from XML
            </summary>
            <param name="installer">Installer that will be used</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticManager.CreateViews(EQTG.General.Diagnostic.DiagnosticsInstaller)">
            <summary>
            Method to actually create the views from the supplied XML
            </summary>
            <param name="installer"></param>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticManager.myEventLog">
            <summary>
            Member diagnostics of last resort
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticManager.myConfigDoc">
            <summary>
            Configuration document
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticManager.myNamespaceRoot">
            <summary>
            Namespace root storage
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticManager.myAssembly">
            <summary>
            Assembly storage, to work out the namespace root
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticManager.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.Diagnostics">
            <summary>
            Distribution point for diagnostics from an application.
            </summary>
            <remarks>
            Uses a delegate for diagnostics to capture the output.
            </remarks>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.IncrementVersion">
            <summary>
            Increment the version number
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.Diagnostics.OurInstanceCountedDiagnostics">
            <summary>
            Hash of instance counted log methods
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Generic WriteLine routine to be called by client code. Passes on to all registered views by Event
            </summary>
            <param name="text">Text to be written on new line</param>
            <param name="level">Severity of this diagnostic</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.IsAnyoneListening(System.String,EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Function to check if anyone is interested in the subject we are reading.
            </summary>
            <param name="subject">Subject to check</param>
            <param name="level">Severity of this diagnostic</param>
            <returns>True if any diagnostics view is interested in our output</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.IsAnyoneListening(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.Collections.IList)">
            <summary>
            Function to check if anyone is interested in the subject we are reading.
            </summary>
            <remarks>
            This version requires a SortedList to find out which views are actually listening.
            Used by e.g. <see cref="T:EQTG.General.Diagnostic.ClassDiagnostics"/>.
            </remarks>
            <param name="subject">Subject to check</param>
            <param name="level">Level of diagnostic to test</param>
            <param name="interestedViews">Optional ArrayList list of views and levels. 
            Will contain <see cref="T:EQTG.General.Diagnostic.DiagnosticsViewAndLevel"/> instances</param>
            <returns>True if any diagnostics view is interested in our output</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.WriteLineOccurrence(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String,System.Int32)">
            <summary>
            Generic WriteLine routine to be called by client code. Passes on to all registered views by Event
            </summary>
            <param name="text">Text to be written on new line</param>
            <param name="level">Severity of this diagnostic</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
            <param name="instanceCount">Number of occurrences of this message text before it should be 
            flushed through diagnostics. A value of zero indicates that some external agent will 
            exclusively be used to flush instance counted messages.</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogFatalError(System.String)">
            <summary>
            Log a fatal error to all registered views (using global namespace)
            </summary>
            <param name="text">Text describing fatal error</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogFatalError(System.String,System.String)">
            <summary>
            Log a fatal error to all registered views with supplied namespace
            </summary>
            <param name="text">Text describing fatal error</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogFatalErrorOccurrence(System.String,System.String,System.Int32)">
            <summary>
            Log an occurrence counted fatal error to all registered views with supplied namespace
            </summary>
            <param name="text">Text describing fatal error</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogError(System.String)">
            <summary>
            Log an error to all registered views
            </summary>
            <param name="text">Text describing the error</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogError(System.String,System.String)">
            <summary>
            Log an error to all registered views
            </summary>
            <param name="text">Text describing the error</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogErrorOccurrence(System.String,System.String,System.Int32)">
            <summary>
            Log an occurrence counted error to all registered views
            </summary>
            <param name="text">Text describing the error</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogWarning(System.String)">
            <summary>
            Log a warning to all registered views
            </summary>
            <param name="text">Text describing the warning condition</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogWarning(System.String,System.String)">
            <summary>
            Log a warning to all registered views
            </summary>
            <param name="text">Text describing the warning condition</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogWarningOccurrence(System.String,System.String,System.Int32)">
            <summary>
            Log an occurrence counted warning to all registered views
            </summary>
            <param name="text">Text describing the warning condition</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogInfo(System.String)">
            <summary>
            Log information to all registered views
            </summary>
            <param name="text">Text describing the informational event</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogInfo(System.String,System.String)">
            <summary>
            Log information to all registered views
            </summary>
            <param name="text">Text describing the informational event</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogInfoOccurrence(System.String,System.String,System.Int32)">
            <summary>
            Log occurrence counted information to all registered views
            </summary>
            <param name="text">Text describing the informational event</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogDebug(System.String)">
            <summary>
            Log debug information to all registered views
            </summary>
            <param name="text">Debug text</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogDebug(System.String,System.String)">
            <summary>
            Log debug information to all registered views
            </summary>
            <param name="text">Debug text</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LogDebugOccurrence(System.String,System.String,System.Int32)">
            <summary>
            Log occurrence of debug information to all registered views
            </summary>
            <param name="text">Debug text</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
            <param name="flushCount">Number of occurrences of this message text before it should be flushed through diagnostics</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Write information to all registered views with no line-feed
            </summary>
            <param name="text">Text to write</param>
            <param name="level">Severity of this diagnostics information</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write information to all registered views with no line-feed
            </summary>
            <param name="text">Text to write</param>
            <param name="level">Severity of this diagnostics information</param>
            <param name="diagnosticsNamespace">Namespace where this diagnostic originated</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.RemoveEventHandlers">
            <summary>
            Removes any handlers added to the <see cref="E:EQTG.General.Diagnostic.Diagnostics.WriteEvent"/>, <see cref="E:EQTG.General.Diagnostic.Diagnostics.WriteLineEvent"/>,
            <see cref="E:EQTG.General.Diagnostic.Diagnostics.AnyoneListening"/> and <see cref="E:EQTG.General.Diagnostic.Diagnostics.EmergencyWriteLine"/> events.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.ToString(EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Turn diagnostics level to a readable string
            </summary>
            <param name="level">Diagnostics level</param>
            <returns>Text representation of diagnostics level</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.ToChar(EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Turn diagnostics level to a single character.
            </summary>
            <remarks>
            Implemented to return chars for performance reasons.
            </remarks>
            <param name="level">Diagnostics level</param>
            <returns>Character representation of diagnostics level</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.Diagnostics.LevelFromChar(System.Char)">
            <summary>
            Convert a char to a DiagnosticsLevel
            </summary>
            <param name="levelChar">Character to convert</param>
            <returns>Diagnostics level corresponding to this level</returns>
        </member>
        <member name="F:EQTG.General.Diagnostic.Diagnostics.OurDiagnosticsVersion">
            <summary>
            Storage of diagnostics 'version'
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.Diagnostics.OurSuppressDiagnostics">
            <summary>
            Storage of global flag to temporarily supress diagnostics output.
            See property as to when top use this. 
            </summary>
        </member>
        <member name="E:EQTG.General.Diagnostic.Diagnostics.WriteLineEvent">
            <summary>
            Event to push WriteLine to all implementing views 
            </summary>
        </member>
        <member name="E:EQTG.General.Diagnostic.Diagnostics.WriteEvent">
            <summary>
            Event to push Write to all implementing views
            </summary>
        </member>
        <member name="E:EQTG.General.Diagnostic.Diagnostics.AnyoneListening">
            <summary>
            Event to push Write to all implementing views
            </summary>
        </member>
        <member name="E:EQTG.General.Diagnostic.Diagnostics.EmergencyWriteLine">
            <summary>
            Client provided message sink in case logging fails or is not yet set up
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.Diagnostics.DiagnosticsVersion">
            <summary>
            Version control, to allow people to check whether diagnostics config has changed
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.Diagnostics.GlobalNamespace">
            <summary>
            Get the global namspace string
            </summary>
            <returns>Global Namespace string</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.Diagnostics.SuppressDiagnostics">
            <summary>
            Gets or sets a flag that indicates whether all diagnostics logging is suppressed.
            </summary>
            <remarks>
            <para>The example case this was introduced for was in the
            User Administrator, which provides a good case of when to use this.
            Not very nice in multithreaded apps!</para>
            
            <para>The suppression is done before broadcasting to views to make sure that
            any delayed write views (e.g. Rendezvous) don't let the output come out.</para>
            
            <para>Typically in the User Administrator you want to see each and every 
            database query in diagnostics.  However, when the password of a user 
            is set this would get dumped out in plain text in the log file, thereby
            breaking the security model. So suppressing diagnostics altogether
            when setting the password is a sensible method of preventing this 
            happening.</para>
            </remarks>
        </member>
        <member name="T:EQTG.General.Diagnostic.Diagnostics.DoWriteLine">
            <summary>
            Method to call to write a line to all instantiated diagnostics views. Includes linefeed
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.Diagnostics.DoWrite">
            <summary>
            Write string to all instantiated diagnostics views.Use when building up e.g. Table of diagnostics statistics
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsLevel">
            <summary>
            Diagnostic severity based upon Win32 Event log levels
            Probably to be reimplemented in terms of System.Diagnostics.TraceLevel
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsLevel.Unknown">
            <summary>
            Unknown diagnostics level
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsLevel.Fatal">
            <summary>
            Fatal error. Program execution cannot continue
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsLevel.Error">
            <summary>
            Error condition. Current request can procede no further
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsLevel.Warning">
            <summary>
            Warning - unexpected condition, but current request can still procede
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsLevel.Info">
            <summary>
            Information about an occasional event
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsLevel.Debug">
            <summary>
            Information that can only be of use on an on-demand fashion, with user interaction
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.AnyoneListeningEventArgs">
            <summary>
            Arguments to check if anyone is listening 
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.AnyoneListeningEventArgs.#ctor(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.Collections.IList)">
            <summary>
            Constructs an AnyoneListeningEventArgs
            </summary>
            <param name="subject">Diagnostics subject name</param>
            <param name="level">Diagnostics level</param>
            <param name="interestedViews">List of interested views</param>
        </member>
        <member name="P:EQTG.General.Diagnostic.AnyoneListeningEventArgs.AnyoneListening">
            <summary>
            Gets or sets an indicator for if someone is listening
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.AnyoneListeningEventArgs.Subject">
            <summary>
            Gets the subject to check
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.AnyoneListeningEventArgs.Level">
            <summary>
            Gets the level to check for listeners
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.AnyoneListeningEventArgs.InterestedViews">
            <summary>
            Gets the list of views who are interested
            </summary>
            <remarks>
            Each item is a <see cref="T:EQTG.General.Diagnostic.DiagnosticsViewAndLevel"/>
            </remarks>
        </member>
        <member name="T:EQTG.General.Diagnostic.AnyoneListeningEventHandler">
            <summary>
            Delegate to indicate if anyone is listening to the specified subject
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.WriteLineOccurrenceResult">
            <summary>
            Indicates the action taken by <see cref="M:EQTG.General.Diagnostic.Diagnostics.WriteLineOccurrence(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String,System.Int32)"/> and related
            methods.
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.WriteLineOccurrenceResult.Flushed">
            <summary>
            Message was written to output
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.WriteLineOccurrenceResult.Accumulated">
            <summary>
            This occurrence of the message was counted to be written later
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsInstaller">
            <summary>
            Sets up diagnostics views according from a <see cref="T:EQTG.General.Application.CommandParameterList"/>, an XML document,
            or app.config.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsInstaller.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Diagnostic.DiagnosticsInstaller"/> class.
            </summary>
            <remarks>
            <para>
            tr67689 23 November 2005: <see cref="T:EQTG.General.Diagnostic.DiagnosticsInstaller"/> seems to be half-static, half 
            instance-based. It has no instance data and no virtual methods so it looks like all its methods should 
            be static and its constructor made private. However there's a fair amount of code that uses 
            <see cref="T:EQTG.General.Diagnostic.DiagnosticsInstaller"/> instances (e.g. <see cref="T:EQTG.General.Diagnostic.BasicDiagnostics"/> itself) so this 
            change is a TODO for now.
            </para>
            <para>
            This should have <see cref="T:System.ObsoleteAttribute"/> but it was too annoying.
            </para>
            </remarks>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsInstaller.CreateDiagnosticsFromCommandLine(EQTG.General.Application.CommandParameterList,EQTG.General.Diagnostic.DiagnosticsViewList,System.Collections.ArrayList)">
            <summary>
            Raises the <see cref="E:EQTG.General.Diagnostic.DiagnosticsInstaller.Install"/> event for each command line option with 'diagnostics' in it.
            </summary>
            <param name="cmdLine">Command Line parameters</param>
            <param name="diagnosticsViews">List to attach new views to</param>
            <param name="viewsToCreate">List of views to create</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsInstaller.CreateDiagnosticsFromXml(System.Xml.XmlElement,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Raises the <see cref="E:EQTG.General.Diagnostic.DiagnosticsInstaller.XmlInstall"/> event.
            </summary>
            <param name="configDoc">XML source document</param>
            <param name="diagnosticsViews">List to attach new views to</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsInstaller.CreateDiagnosticsFromAppConfig(EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Create diagnostics views as specified in app.config.
            </summary>
            <param name="diagnosticsViews">List to attach new views to</param>
            <seealso cref="T:EQTG.General.Diagnostic.FileDiagnosticsSectionHandler"/>
            <seealso cref="T:EQTG.General.Diagnostic.MailDiagnosticsSectionHandler"/>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsInstaller.InstallStandardViews">
            <summary>
            Add <see cref="E:EQTG.General.Diagnostic.DiagnosticsInstaller.Install"/> and <see cref="E:EQTG.General.Diagnostic.DiagnosticsInstaller.XmlInstall"/> event handlers for the standard diagnostics classes.
            </summary>
            <remarks>
            Standard diagnostics classes are:
            <list type="bullet">
            	<item>
            		<description><see cref="T:EQTG.General.Diagnostic.FileDiagnostics"/></description>
            	</item>
            	<item>
            		<description><see cref="T:EQTG.General.Diagnostic.ConsoleDiagnostics"/></description>
            	</item>
            	<item>
            		<description><see cref="T:EQTG.General.Diagnostic.DebugDiagnostics"/></description>
            	</item>
            	<item>
            		<description><see cref="T:EQTG.General.Diagnostic.EventLogDiagnostics"/></description>
            	</item>
            	<item>
            		<description><see cref="T:EQTG.General.Diagnostic.TelnetDiagnostics"/></description>
            	</item>
            	<item>
            		<description><see cref="T:EQTG.General.Diagnostic.MailDiagnostics"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsInstaller.RemoveEventHandlers">
            <summary>
            Removes any handlers added to the <see cref="E:EQTG.General.Diagnostic.DiagnosticsInstaller.Install"/> and <see cref="E:EQTG.General.Diagnostic.DiagnosticsInstaller.XmlInstall"/> events.
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsInstaller.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsTreeBuilder">
            <summary>
                Build up full diagnostics namespace tree
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsTreeBuilder.#ctor(System.Reflection.Assembly)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsTreeBuilder.FullTree">
            <summary>
            Build full diagnostics namespace tree and return as XML Document
            </summary>
            <returns>XmlDocument with diagnostics namespace</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsTreeBuilder.OutputAssemblyTree(System.Reflection.Assembly,System.Xml.XmlDocument)">
            <summary>
            Scan the supplied assembly for OurDiagnostics or ClassBehaviourDiagnostics members
            </summary>
            <param name="assembly">Assembly to scan</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsTreeBuilder.CreateXmlTreeFromNamespaceString(System.String,System.Xml.XmlElement)">
            <summary>
            Split the supplied namespace string into tokens and build the elements within the supplied XmlDoc
            </summary>
            <param name="namespaceString"></param>
            <param name="xmlDoc"></param>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsTreeBuilder.myAssembly">
            <summary>
            Assembly for which want to extract the error namespace tree
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsTreeBuilder.OurDiagnostics">
            <summary>
            Class diagnostics instantiation
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsViewAndLevel">
            <summary>
            Simple combination of view and level
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewAndLevel.#ctor">
            <summary>
            Blank C'tor
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewAndLevel.#ctor(EQTG.General.Diagnostic.DiagnosticsView,EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            C'tor
            </summary>
            <param name="view">View</param>
            <param name="level">Level</param>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsViewAndLevel.myView">
            <summary>
            View storage
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.DiagnosticsViewAndLevel.myLevel">
            <summary>
            Level
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsViewAndLevel.View">
            <summary>
            View property
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.DiagnosticsViewAndLevel.Level">
            <summary>
            Level property
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.DiagnosticsViewList">
            <summary>
            Collection of diagnostics views
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewList.AllDiagnosticsViewSettings">
            <summary>
            Xml representation of all diagnostics view settings
            </summary>
            <returns>Document with all view settings</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewList.RemoveAllViews">
            <summary>
            Disconnect the view and chuck them
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewList.GetView(System.String)">
            <summary>
            Find view of the given name
            </summary>
            <param name="viewName">Name of the view required</param>
            <returns>DiagnosticsView</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewList.Add(EQTG.General.Diagnostic.DiagnosticsMethodsBase)">
            <summary>
            Adds the specified view to the list
            </summary>
            <param name="item">View to add</param>
            <returns>The index of the view within the list</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.DiagnosticsViewList.Remove(EQTG.General.Diagnostic.DiagnosticsMethodsBase)">
            <summary>
            Removes the specified view from the list
            </summary>
            <param name="item">View to remove</param>
        </member>
        <member name="T:EQTG.General.Diagnostic.EventLogDiagnostics">
            <summary>
            Win32 EventLog diagnostics implementation. Writes diagnostics to the Win32 Event Log
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.EventLogDiagnostics.#ctor(System.Xml.XmlElement)">
            <summary>
            Construction of EventLogDiagnostics view
            </summary>
            <param name="level">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.EventLogDiagnostics.EventLogTypeFromDiagnosticsType(EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            EventLog / EQTG DiagnosticsLevel conversion function
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.EventLogDiagnostics.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostics to Event Log - implementation of DoWriteLineEvent
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.EventLogDiagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            DOES NOTHING. Write diagnostic to event log. Cannot do this sensibly so does nothing. Implementation of DoWrite Event
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.EventLogDiagnostics.Install(EQTG.General.Application.CommandParameterList,EQTG.General.Application.CommandParameter,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Diagnostics installation event implementation
            </summary>
            <param name="cmdLine">CommandParameterList instance</param>
            <param name="arg">Single argument being dealt with</param>
            <param name="diagnosticsViews">List of views to which any new instantiation must be added</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.EventLogDiagnostics.InstallXml(System.Xml.XmlElement,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Configure diagnostics type from XML
            </summary>
            <param name="configDoc">XML Source document</param>
            <param name="diagnosticsViews">List of views to add new view to</param>
        </member>
        <member name="F:EQTG.General.Diagnostic.EventLogDiagnostics.myEventLog">
            <summary>
            Event log access storage
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.EventLogDiagnostics.DefaultName">
            <summary>
            Name for this diagnostics view. Useful for command line specification of diagnostics views.
            </summary>
            <returns>Diagnostics view name</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.EventLogDiagnostics.Name">
            <summary>
            Name of this view
            </summary>
            <returns>View Name</returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.EventLogDiagnosticsSectionHandler">
            <summary>
            Handler for the eventLogDiagnostics section in app.config.
            </summary>
            <example>
            <para>To use this class, add the following to your app.config:</para>
            <code escaped="true">
            <configuration>
            	<configSections>
            		<section name="eventLogDiagnostics" type="EQTG.General.Diagnostic.EventLogDiagnosticsSectionHandler, EQTG" />
            	</configSections>
            	<appSettings>
            		<add key="diagnostics" value="eventLogDiagnostics" />
            	</appSettings>
            	<eventLogDiagnostics>
            		<EQTG level="info">
            			<Database>
            				<LoggedDatabase>
            					<LoggedCommand level="debug" />
            				</LoggedDatabase>
            			</Database>
            		</EQTG>
            	</eventLogDiagnostics>
            </configuration>
            </code>
            </example>
        </member>
        <member name="T:EQTG.General.Diagnostic.FileDiagnostics">
            <summary>
            File diagnostics implementation. Writes diagnostics to a file
            </summary>
            <remarks>
            <para>The file name is synthesized from the -app-logname and -fileDiagnosticsDirectory parameters
            supplied on the command line.</para>
            <list type="bullet">
              <item>
                <description>If no -app-logname specified a synthetic one is created</description>
              </item>
              <item>
                <description>If -app-logname specified and includes a path, use as supplied.</description>
              </item>
              <item>
            	<description>If -app-logname specified and does not include a path then use the -fileDiagnosticsDirectory 
            and add the -app-logname at the end.</description>
              </item>
            </list>
            <para>You can use the following variables in the -app-logname and -fileDiagnosticsDirectory
            parameters:</para>
            <list type="table">
              <listheader>
                <term>Variable</term>
                <description>Expands To</description>
              </listheader>
              <item>
                <term>$d</term>
                <description>Today's date in rover8 format (see <see cref="M:EQTG.General.BasicTypes.TimeUtils.Rover8FromDateTime(System.DateTime)"/>)</description>
              </item>
              <item>
                <term>$t</term>
                <description>Current time as a number (see <see cref="M:EQTG.General.BasicTypes.TimeUtils.TimeAsInteger(System.DateTime)"/>)</description>
              </item>
              <item>
            	<term>$u</term>
            	<description>Name of the current user's account (see <see cref="P:System.Environment.UserName"/>)</description>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.#ctor(System.String,System.Xml.XmlElement)">
            <summary>
            Construction of FileDiagnostics view
            </summary>
            <param name="fileName">Log file location</param>
            <param name="level">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostics to log file - implementation of DoWriteLineEvent
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostic to file with no line-feed. Implementation of DoWrite Event
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.ShutdownView">
            <summary>
            Close the view down cleanly
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.Install(EQTG.General.Application.CommandParameterList,EQTG.General.Application.CommandParameter,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Diagnostics installation event implementation.
            </summary>
            <param name="cmdLine">CommandParameterList instance</param>
            <param name="arg">Single argument being dealt with</param>
            <param name="diagnosticsViews">List of views to which any new instantiation must be added</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.GetFilename(System.String,System.String)">
            <summary>
            Synthesizes a suitable log file name from the supplied -app-logname and -fileDiagnosticsDirectory.
            </summary>
            <remarks>
            If no -app-logname specified a synthetic one is created. If -app-logname specified and includes a path, 
            use as supplied. If -app-logname specified and does not include a path then use the 
            -fileDiagnosticsDirectory and add the -app-logname at the end.
            </remarks>
            <param name="logDirectory">Directory into which the log file will be placed. Ignored if appLogname includes path.</param>
            <param name="appLogname">File name. Can include $d, $t and $u which will be replaced. If includes full path then logDirectory is ignored.</param>
            <returns>Log file name</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.GenerateFilename(System.String)">
            <summary>
            Helper to generate file for diagnostics - replaces $d and $t
            </summary>
            <param name="fileTemplateName">Template name before substitution</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.InstallXml(System.Xml.XmlElement,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Configure diagnostics type from XML
            </summary>
            <param name="configDoc">XML Source document</param>
            <param name="diagnosticsViews">List of views to add new view to</param>
        </member>
        <member name="F:EQTG.General.Diagnostic.FileDiagnostics.myWriter">
            <summary>
            Writer for file logging
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.FileDiagnostics.myFileName">
            <summary>
            Filename storage for convenience
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.FileDiagnostics.currentState">
            <summary>
            variable representing the current failover state (if active)
            </summary>
        </member>
        <member name="F:EQTG.General.Diagnostic.FileDiagnostics.isUsingStateInformation">
            <summary>
            variable representing the usage status of the failover hook.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.FileDiagnostics.BuildLine(EQTG.General.Diagnostic.DiagnosticsLevel)">
            <summary>
            Override of the parent method to add the failover status. By default 
            	(flag value = false) the method simply returns the superclass's implementation.
            </summary>
            <param name="level">
            	The diagnostic level of the text to add to the log. It will be part of the log entry.
            		I was going to say same as the superclass, but the comment does not 
            		reflect the usage: it talks about "tag" and "sink", which are not parameters
            		(quick copy and paste job in the superclass???).
            </param>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.FileDiagnostics.FileName">
            <summary>
            FileName property 
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.FileDiagnostics.CurrentState">
            <summary>
            Field allowing external objects to set the string to use to represent the failover status.
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.FileDiagnostics.IsUsingStateInformation">
            <summary>
            Property allowing external objects to set the flag determining the usage of the hook.
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.FileDiagnostics.DefaultName">
            <summary>
            Name for this diagnostics view. Useful for command line specification of diagnostics views.
            </summary>
            <returns>Diagnostics view name</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.FileDiagnostics.Name">
            <summary>
            Name of this view
            </summary>
            <returns>View Name</returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.FileDiagnosticsSectionHandler">
            <summary>
            Handler for the fileDiagnostics section in app.config.
            </summary>
            <example>
            <para>To use this class, add the following to your app.config:</para>
            <code escaped="true">
            <configuration>
            	<configSections>
            		<section name="fileDiagnostics" type="EQTG.General.Diagnostic.FileDiagnosticsSectionHandler, EQTG" />
            	</configSections>
            	<appSettings>
            		<add key="diagnostics" value="fileDiagnostics" />
            	</appSettings>
            	<fileDiagnostics directory="c:\EQTG\log\$u" app-logname="AppName.$d.$t.log">
            		<EQTG level="info">
            			<Database>
            				<LoggedDatabase>
            					<LoggedCommand level="debug" />
            				</LoggedDatabase>
            			</Database>
            		</EQTG>
            	</fileDiagnostics>
            </configuration>
            </code>
            </example>
        </member>
        <member name="T:EQTG.General.Diagnostic.LoggingAdapter">
            <summary>
            Use this class to route EQTG.General.Diagnostic logging through to log4net.
            Example usage:
            
                ILog logger;	//log4Net logging object
            ...
            	LoggingAdapter log4NetAdapter = new LoggingAdapter(logger); // create adapter
            	DiagnosticsMethodsBase.Log loggerHook = new DiagnosticsMethodsBase.Log(log4NetAdapter.log); // create delegate
            	DiagnosticsMethodsBase.HookInExternalLogger(loggerHook); // pass the delegate through to EQTG.General style logging
            
            20080613: add static method AddDefaultLogger
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.LoggingAdapter.AddDefaultLogger">
            <summary>
            Create log4net logger for adapter
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.MailDiagnostics">
            <summary>
            Diagnostics view that saves its messages into a buffer and sends them by mail on request.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.#ctor(System.Xml.XmlElement)">
            <summary>
            Constructs a MailDiagnostics instance
            </summary>
            <remarks>
            You shouldn't need to construct an instance directly. The application framework gives you 
            a MailDiagnostics by default. Otherwise, <see cref="M:EQTG.General.Diagnostic.MailDiagnostics.Install(EQTG.General.Application.CommandParameterList,EQTG.General.Application.CommandParameter,EQTG.General.Diagnostic.DiagnosticsViewList)"/> is a convenient method.
            </remarks>
            <param name="settings">Minimum level of diagnostics to report</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.WriteLine(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostics to console - implementation of DoWriteLineEvent
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.Write(System.String,EQTG.General.Diagnostic.DiagnosticsLevel,System.String)">
            <summary>
            Write diagnostic to console with no line-feed. Implementation of DoWrite Event
            </summary>
            <param name="text">Text to write to the console</param>
            <param name="level">Severity of this diagnostic</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.Send(System.String)">
            <summary>
            Sends a mail consisting of any text logged since the last call to Send.
            </summary>
            <remarks>
            If no text has been logged then no mail is sent
            </remarks>
            <param name="subject">Subject line for the mail</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.Clear">
            <summary>
            Clears any messages logged
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.SendAll(System.String)">
            <summary>
            Sends any messages logged by MailDiagnostics instances within 
            BasicDiagnostics.DefaultInstance.ViewList.
            </summary>
            <remarks>
            Each MailDiagnostics instance sends a separate mail
            </remarks>
            <param name="subject">Subject line for the mails</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.SendAll(System.String,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Sends any messages logged by MailDiagnostics instances within 
            the specified <see cref="T:EQTG.General.Diagnostic.DiagnosticsViewList"/>.
            </summary>
            <remarks>
            Each MailDiagnostics instance sends a separate mail
            </remarks>
            <param name="subject">Subject line for the mails</param>
            <param name="viewList">List of diagnostics views</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.ClearAll">
            <summary>
            Clears any messages logged by MailDiagnostics instances within 
            BasicDiagnostics.DefaultInstance.ViewList.
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.ClearAll(EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Clears any messages logged by MailDiagnostics instances within 
            the specified <see cref="T:EQTG.General.Diagnostic.DiagnosticsViewList"/>.
            </summary>
            <param name="viewList">List of diagnostics views</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.Install(EQTG.General.Application.CommandParameterList,EQTG.General.Application.CommandParameter,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Diagnostics installation event implementation
            </summary>
            <param name="cmdLine">CommandParameterList instance</param>
            <param name="arg">Single argument being dealt with</param>
            <param name="diagnosticsViews">List of views to which any new instantiation must be added</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailDiagnostics.InstallXml(System.Xml.XmlElement,EQTG.General.Diagnostic.DiagnosticsViewList)">
            <summary>
            Configure diagnostics type from XML
            </summary>
            <param name="configDoc">XML Source document</param>
            <param name="diagnosticsViews">List of views to add new view to</param>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailDiagnostics.Template">
            <summary>
            Settings for mails sent by this instance.
            </summary>
            <remarks>
            This <see cref="T:EQTG.General.Diagnostic.MailTemplate"/> inherits its settings from <see cref="P:EQTG.General.Diagnostic.MailDiagnostics.DefaultTemplate"/>.
            </remarks>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailDiagnostics.DefaultTemplate">
            <summary>
            Default settings for mails sent by all instances
            </summary>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailDiagnostics.DefaultName">
            <summary>
            Name for this diagnostics view. Useful for command line specification of diagnostics views.
            </summary>
            <returns>Diagnostics view name</returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailDiagnostics.Name">
            <summary>
            Name of this view
            </summary>
            <returns>View Name</returns>
        </member>
        <member name="T:EQTG.General.Diagnostic.MailDiagnosticsSectionHandler">
            <summary>
            Handler for the mailDiagnostics section in app.config.
            </summary>
            <example>
            <para>To use this class, add the following to your app.config:</para>
            <code escaped="true">
            <configuration>
            	<configSections>
            		<section name="mailDiagnostics" type="EQTG.General.Diagnostic.MailDiagnosticsSectionHandler, EQTG" />
            	</configSections>
            	<appSettings>
            		<add key="diagnostics" value="mailDiagnostics" />
            	</appSettings>
            	<mailDiagnostics>
            		<EQTG level="info">
            			<Database>
            				<LoggedDatabase>
            					<LoggedCommand level="debug" />
            				</LoggedDatabase>
            			</Database>
            		</EQTG>
            	</mailDiagnostics>
            </configuration>
            </code>
            </example>
        </member>
        <member name="T:EQTG.General.Diagnostic.MailTemplate">
            <summary>
            Defines a template for mails sent by the MailDiagnostics class
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailTemplate.#ctor">
            <summary>
            Constructs an empty MailTemplate
            </summary>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailTemplate.#ctor(EQTG.General.Diagnostic.MailTemplate)">
            <summary>
            Constructs a MailTemplate that inherits its settings from the specified parent.
            </summary>
            <remarks>
            This instance will inherit its settings from the parent, unless you explicitly specify them.
            If you update a setting on this instance, the change is not applied to the parent.
            </remarks>
            <param name="parent">MailTemplate from which to inherit settings</param>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailTemplate.BuildBody(System.String)">
            <summary>
            Builds the body section of an email by putting together the header, the specified text,
            and the footer
            </summary>
            <param name="text">Main part of the body text</param>
            <returns>Text with header and footer attached</returns>
        </member>
        <member name="M:EQTG.General.Diagnostic.MailTemplate.CreateMessage(System.String,System.String)">
            <summary>
            Creates a <see cref="T:System.Web.Mail.MailMessage"/> from the MailTemplate, using the subject line
            and message body provided
            </summary>
            <param name="subject">Subject line</param>
            <param name="body">Body text</param>
            <returns>A <see cref="T:System.Web.Mail.MailMessage"/></returns>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailTemplate.ToAddress">
            <summary>
            Gets or sets the address in the To: line of mails
            </summary>
            <remarks>
            The value is selected as follows:
            <list type="number">
              <item>
                <description>Any value previously assigned to ToAddress</description>
              </item>
              <item>
                <description>The parent's ToAddress, if any</description>
              </item>
              <item>
                <description>The value of the environment variable NOTIFY_ADDRESS</description>
              </item>
              <item>
                <description>The address ukeqeodlog@imceu.eu.ssmb.com</description>
              </item>
            </list>
            </remarks>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailTemplate.FromAddress">
            <summary>
            Gets or sets the address in the From: line of mails
            </summary>
            <remarks>
            The value is selected as follows:
            <list type="number">
              <item>
                <description>Any value previously assigned to FromAddress</description>
              </item>
              <item>
                <description>The parent's FromAddress, if any</description>
              </item>
              <item>
                <description>The name of the process, followed by @, followed by the machine name</description>
              </item>
            </list>
            </remarks>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailTemplate.CcAddress">
            <summary>
            Gets or sets the address in the CC: line of mails
            </summary>
            <remarks>
            The value is selected as follows:
            <list type="number">
              <item>
                <description>Any value previously assigned to CcAddress</description>
              </item>
              <item>
                <description>The parent's CcAddress, if any</description>
              </item>
              <item>
                <description>An empty string</description>
              </item>
            </list>
            </remarks>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailTemplate.Header">
            <summary>
            Gets or sets the header text used in emails
            </summary>
            <remarks>
            The value is selected as follows:
            <list type="number">
              <item>
                <description>Any value previously assigned to Header</description>
              </item>
              <item>
                <description>The parent's Header, if any</description>
              </item>
              <item>
                <description>An empty string</description>
              </item>
            </list>
            </remarks>
        </member>
        <member name="P:EQTG.General.Diagnostic.MailTemplate.Footer">
            <summary>
            Gets or sets the footer text used in emails
            </summary>
            <remarks>
            The value is selected as follows:
            <list type="number">
              <item>
                <description>Any value previously assigned to Footer</description>
              </item>
              <item>
                <description>The parent's Footer, if any</description>
              </item>
              <item>
                <description>An empty string</description>
              </item>
            </list>
            </remarks>
        </member>
        <member name="T:EQTG.General.Diagnostic.NamespaceDoc">
            <summary>
            <h1>Turning on Diagnostics</h1>
            <para>The diagnostics system is configured by the use of either command parameters or through 
            app.config or web.config.</para>
            <para>For most applications the command parameters will be 
            		supplied through the command line. For services the parameters will be 
            		specified through registry entries under HKEY_LOCAL_MACHINE]Software\Salomon\EQ 
            		Services\[App Name]_[namespace]\cmdLine. Command line parameters/keys and suitable values 
            		are explained below. 
            </para>
            <para>For stand-alone applications, diagnostics can be configured by adding to the application's
            config file, which is in the same directory as the application executable and has a name like
            AppName.exe.config. For web applications, the configuration is taken from web.config in the
            application's virtual directory.</para>
            <h1>Available Diagnostics Views</h1>
            <para>There are several 'views' which allow for logging 
            		of different levels of diagnostics to different destinations. These are the 
            		standard ones:</para>
            <list type="definition">
            	<item>
            		<term><see cref="T:EQTG.General.Diagnostic.ConsoleDiagnostics">consoleDiagnostics</see></term>
            		<description>Echoes trace messages synchronously onto a console should you be 
            			running a console application</description>
            	</item>
            	<item>
            		<term><see cref="T:EQTG.General.Diagnostic.DebugDiagnostics">debugDiagnostics</see></term>
            		<description>Trace 
            			messages are recorded synchronously to the debug window (works in Visual 
            			Studio)</description>
            	</item>
            	<item>
            		<term><see cref="T:EQTG.General.Diagnostic.EventLogDiagnostics">win32EventLogDiagnostics</see></term>
            		<description>Trace 
            			messages are recorded synchronously to the Windows Event Log</description>
            	</item>
            	<item>
            		<term><see cref="T:EQTG.General.Diagnostic.FileDiagnostics">fileDiagnostics</see></term>
            		<description>Trace 
            			messages are recorded synchronously into an automatically generated and 
            			named log file. Use in combination with -fileDiagnosticsDirectory to 
            			create the diagnostics files in an alternative location.</description>
            	</item>
            	<item>
            		<term><see cref="T:EQTG.General.Diagnostic.MailDiagnostics">mailDiagnostics</see></term>
            		<description>Trace messages are buffered, and sent by email on a call to 
            		<see cref="M:EQTG.General.Diagnostic.MailDiagnostics.SendAll(System.String)"/></description>
            	</item>
            	<item>
            		<term>messageLogDiagnostics (in EQTG.Forms.dll)</term>
            		<description>Trace messages are recorded asynchronously in a MessageLogForm</description>
            	</item>
            	<item>
            		<term>rvDiagnostics (in EQTG.Rendezvous.dll)</term>
            		<description>Trace 
            			messages are broadcast asynchronously over Rendezvous using a subject e.g. 
            			EQTG.DAEMON.[app name].[namespace].OUT.DIAGNOSTICS.ITEM.[diagnostics namespace]</description>
            	</item>
            	<item>
            		<term><see cref="T:EQTG.General.Diagnostic.TelnetDiagnostics">telnetDiagnostics</see></term>
            		<description>Trace messages are sent synchronously to clients connecting to the 
            		application's Telnet server</description>
            	</item>
            </list>
            <h1>Configuration</h1>
            <list type="definition">
            	<item>
            		<term>From the command line</term>
            		<description>
            			<para>Each of the diagnostics views are turned on by 
            		specifying a command line parameter (either on the command line, the registry 
            		or maybe from database) e.g. to turn on console diagnostics and file 
            		diagnostics you could specify:</para>
            			<para>myapp.exe -consoleDiagnostics [diagnosticsConfig] -fileDiagnostics [diagnosticsConfig2]</para>
            		</description>
            	</item>
            	<item>
            		<term>App.config/Web.config Configuration</term>
            		<description>
            			<para>Each of the diagnostics views are configured directly in the config file. You need
            				to add to the configSections element and the appSettings element, as well
            				a new element containing the diagnostics settings themselves:</para>
            			<code escaped="true">
            				<configuration>
            					<configSections>
            						<!-- Add one section element for each diagnostics view, with the corresponding SectionHandler class -->
            						<section name="consoleDiagnostics" type="EQTG.General.Diagnostic.ConsoleDiagnosticsSectionHandler, EQTG"/>
            					</configSections>
            					<appSettings>
            						<!-- Add a comma-separted list of the diagnostics views to use -->
            						<add key="diagnostics" value="consoleDiagnostics"/>
            					</appSettings>
            					<!-- Add one element for each diagnostics view -->
            					<consoleDiagnostics href="local://DiagnosticConfig.xml"/>
            				</configuration>
            			</code>
            			<para>You can configure each diagnostics view directly inside its element in app.config,
            			or you can use the href= attribute to refer to a separate XML file.</para>
            		</description>
            	</item>
            </list>
            <para>There are several alternatives that can be used in 
            		the diagnosticsConfig sections on the command line and the href= attribute in app.config:</para>
            <list type="bullet">
            	<item>
            		<description>eqtgapp://[inline xml config]</description>
            	</item>
            	<item>
            		<description>
            		local://[xml config file name, in local exe 
            			directory]</description>
            	</item>
            	<item>
            		<description>
            		http://[xml file config URL]</description>
            	</item>
            	<item>
            		<description>file://[xml config file name, in working directory]</description>
            	</item>
            </list>
            <para>Default config in the absence of any 
            		diagnosticConfig is to report warnings and above only.</para>
            <para>The XML config in each of the preceding cases is a 
            		simple representation of the diagnostics namespace of the diagnostics trace 
            		messages. You specify a level at which you want the diagnostics to appear, for 
            		a given namespace. Child subjects will inherit the same level of diagnostics 
            		unless otherwise configured. When you specify a diagnostics level, you get all 
            		trace messages at that level or above.</para>
            <para><see cref="T:EQTG.General.Diagnostic.DiagnosticsLevel">Levels</see> are:</para>
            <list type="bullet">
            	<item>
            		<description>Debug</description>
            	</item>
            	<item>
            		<description>Info</description>
            	</item>
            	<item>
            		<description>Warnings</description>
            	</item>
            	<item>
            		<description>Errors</description>
            	</item>
            	<item>
            		<description>Fatal Errors</description>
            	</item>
            </list>
            <para>So if you specify "Warnings" then you will receive 
            		all traces at warning, error and fatal error level.</para>
            <para>
            	Example config:
            </para>
            <code escaped="true">
            <EQTG level="info">
            	<Database>
            		<LoggedDatabase>
            			<LoggedCommand level="debug"/>
            		</LoggedDatabase>
            	</Database>
            </EQTG>
            </code>
            <para>This configuration will provide information level 
            		diagnostics or above for all subjects beginning "EQTG.*" except for messages on 
            		subject "EQTG.Database.LoggedDatabase.*" which will appear at debug level or 
            		above. This is a suitable config if you require database command tracing.</para>
            <para>This provides equivalent to the "debug_db 1" 
            		command on the C++ applications. While this seems like overkill for this 
            		particular usage, there is a large benefit in the flexibility provided. Any 
            		message which is appearing too frequently in a log trace can be suppressed 
            		using this mechanism with no further development required.</para>
            <h1>Remote Monitor</h1>
            <para>For applications that support Rendezvous 
            		diagnostics the Remote Monitor can be a very useful tool. It allows you to 
            		connect to a running process by application name and namespace, examine the 
            		existing level of diagnostics and view the messages produced, andd to modify 
            		the configuration of the rendezvous diagnostics remotely.</para>
            <para>Once you have set the level of diagnostics to a 
            		suitable level and suppressed the irrelevant diagnostics you can save the XML 
            		configuration back to a file and point the process to use that when it 
            		starts up for its file, console or event log diagnostics.</para>
            </summary>
        </member>
        <member name="T:EQTG.General.Diagnostic.TelnetDiagnosticsSectionHandler">
            <summary>
            Handler for the telnetDiagnostics section in app.config.
            </summary>
            <example>
            <para>To use this class, add the following to your app.config:</para>
            <code escaped="true">
            <configuration>
            	<configSections>
            		<section name="telnetDiagnostics" type="EQTG.General.Diagnostic.TelnetDiagnosticsSectionHandler, EQTG" />
            	</configSections>
            	<appSettings>
            		<add key="diagnostics" value="telnetDiagnostics" />
            	</appSettings>
            	<telnetDiagnostics>
            		<EQTG level="info">
            			<Database>
            				<LoggedDatabase>
            					<LoggedCommand level="debug" />
            				</LoggedDatabase>
            			</Database>
            		</EQTG>
            	</telnetDiagnostics>
            </configuration>
            </code>
            </example>
        </member>
        <member name="T:EQTG.General.Diagnostic.Watermark">
            <summary>
            Summary description for Watermark.
            </summary>
        </member>
        <member name="T:EQTG.General.DummyProgressMeter">
            <summary>
            Progress meter with no output
            </summary>
        </member>
        <member name="T:EQTG.General.IProgressMeter">
            <summary>
            Represents a status bar or other control that can display status messages.
            </summary>
        </member>
        <member name="M:EQTG.General.IProgressMeter.BeginOperation">
            <summary>
            Called to mark the beginning of an operation.
            </summary>
            <returns>An object that implements IProgressOperation.</returns>
        </member>
        <member name="P:EQTG.General.IProgressMeter.Text">
            <summary>
            Gets or sets the text displayed in the progress meter's status bar when no operation is running.
            </summary>
        </member>
        <member name="M:EQTG.General.DummyProgressMeter.BeginOperation">
            <summary>
            Called to mark the beginning of an operation.
            </summary>
            <returns>An object that implements IProgressOperation.</returns>
        </member>
        <member name="P:EQTG.General.DummyProgressMeter.Text">
            <summary>
            Gets or sets the text displayed in the progress meter's status bar when no operation is running.
            </summary>
        </member>
        <member name="T:EQTG.General.ProgressOperationBase">
            <summary>
            Standard IProgressOperation implementation
            </summary>
        </member>
        <member name="T:EQTG.General.IProgressOperation">
            <summary>
            Tracks the progress of a program's operation.
            </summary>
        </member>
        <member name="P:EQTG.General.IProgressOperation.Minimum">
            <summary>
            Gets or sets the minimum value of Current.
            </summary>
        </member>
        <member name="P:EQTG.General.IProgressOperation.Current">
            <summary>
            Gets or sets the operation's progress.
            </summary>
        </member>
        <member name="P:EQTG.General.IProgressOperation.Maximum">
            <summary>
            Gets or sets the maximum value of Current.
            </summary>
        </member>
        <member name="P:EQTG.General.IProgressOperation.Name">
            <summary>
            Gets or sets the operation's name.
            </summary>
        </member>
        <member name="M:EQTG.General.ProgressOperationBase.#ctor">
            <summary>
            Constructs a ProgressOperationBase
            </summary>
        </member>
        <member name="M:EQTG.General.ProgressOperationBase.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting 
            unmanaged resources.
            </summary>
        </member>
        <member name="M:EQTG.General.ProgressOperationBase.Update">
            <summary>
            Called to update the status display
            </summary>
        </member>
        <member name="P:EQTG.General.ProgressOperationBase.Minimum">
            <summary>
            Gets or sets the minimum value of Current.
            </summary>
        </member>
        <member name="P:EQTG.General.ProgressOperationBase.Current">
            <summary>
            Gets or sets the operation's progress.
            </summary>
        </member>
        <member name="P:EQTG.General.ProgressOperationBase.Maximum">
            <summary>
            Gets or sets the maximum value of Current.
            </summary>
        </member>
        <member name="P:EQTG.General.ProgressOperationBase.Name">
            <summary>
            Gets or sets the operation's name.
            </summary>
        </member>
        <member name="E:EQTG.General.ProgressOperationBase.Disposed">
            <summary>
            Occurs when the operation finishes.
            </summary>
        </member>
        <member name="T:EQTG.General.EnumNameAttribute">
            <summary>
            Specifies a description for an enum member
            </summary>
            <remarks>
            Use <see cref="M:EQTG.General.EnumNameAttribute.GetEnumName(System.Object)"/> to retrieve the description at run time.
            </remarks>
            <example><code>
            enum DatabaseType
            {
            	[EnumName("Sybase ASE")] Sybase,
            	[EnumName("Microsoft SQL Server")] SqlServer,
            	Oracle
            }
            
            // EnumNameAttribute.GetName(DatabaseType.Sybase) == "Sybase ASE"
            // EnumNameAttribute.GetName(DatabaseType.SqlServer) == "Microsoft SQL Server"
            // EnumNameAttribute.GetName(DatabaseType.Oracle) == "Oracle"
            </code></example>
        </member>
        <member name="M:EQTG.General.EnumNameAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.EnumNameAttribute"/> class with the specified name
            </summary>
            <param name="name">Name or description to apply to the enum member</param>
        </member>
        <member name="M:EQTG.General.EnumNameAttribute.GetEnumName(System.Object)">
            <summary>
            Retrieves the description of the specfied enum member
            </summary>
            <param name="enumValue">Enum member</param>
            <returns>The enum member's description assigned using [EnumName], or the member's literal
            name if there was no name assigned.</returns>
        </member>
        <member name="P:EQTG.General.EnumNameAttribute.Name">
            <summary>
            Gets the name, or description, from an <see cref="T:EQTG.General.EnumNameAttribute"/>
            </summary>
        </member>
        <member name="T:EQTG.General.Expressions">
            <summary>
            Summary description for Expressions.
            </summary>
        </member>
        <member name="M:EQTG.General.Expressions.Clear">
            <summary>
            Reset all functions in this instance
            </summary>
        </member>
        <member name="M:EQTG.General.Expressions.ValidFunctionNameFromSymbol(System.String)">
            <summary>
            Create a compilable function name from a symbol
            </summary>
            <param name="symbol">Possibly non-compilable symbol</param>
            <returns>Valid function name</returns>
        </member>
        <member name="M:EQTG.General.Expressions.LinesBeforeSuppliedFunctions">
            <summary>
            Number of lines before the functions supplied
            </summary>
            <returns>Number of lines before the functions supplied</returns>
        </member>
        <member name="M:EQTG.General.Expressions.BeginFunctions(System.Collections.ArrayList,System.Collections.ArrayList,System.String)">
            <summary>
            Put in the pre-amble before the externally supplied functions
            </summary>
            <param name="referencedAssembly">Particular referenced assembly</param>
            <param name="referenceNamespaces">List of referenced namespaces</param>
            <param name="buildNamespace">Namespace of the resultant class</param>
        </member>
        <member name="M:EQTG.General.Expressions.AddSource(System.String,System.String)">
            <summary>
            Add source for a given function
            Converts non-compilable symbols to valid compilable function names
            </summary>
            <param name="symbol">Symbol/Function name. </param>
            <param name="expression">Source code</param>
        </member>
        <member name="M:EQTG.General.Expressions.AddRawSource(System.String)">
            <summary>
            Add raw line(s) of source code. Appends new line to the end for convenience
            </summary>
            <param name="line">Line(s) of code</param>
        </member>
        <member name="M:EQTG.General.Expressions.AddFunctionNameAndSource(System.String,System.String)">
            <summary>
            Add function for compilation
            </summary>
            <param name="functionName">Name of the function</param>
            <param name="function">Function source</param>
        </member>
        <member name="M:EQTG.General.Expressions.BuildSource(System.Boolean,System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Byuild all source that has been supplied
            </summary>
            <param name="reportErrors">Whether to report errors through diagnostics</param>
            <param name="errorLines">Number of lines in error</param>
            <param name="buildErrors">List of build errors (filled in by this function)</param>
        </member>
        <member name="M:EQTG.General.Expressions.StoreFunctions">
            <summary>
            Extract and retain references to all functions that successfully compiled
            </summary>
        </member>
        <member name="M:EQTG.General.Expressions.HasFunction(System.String)">
            <summary>
            Check if this Expressions instance contains a specified function name
            </summary>
            <param name="functionName">Name of the function</param>
            <returns>True if the instance contains the named function</returns>
        </member>
        <member name="M:EQTG.General.Expressions.GetMethodInfo(System.String)">
            <summary>
            Extract the MethodInfo for the named method
            </summary>
            <param name="functionName">Name of function</param>
            <returns>MethodInfo if present</returns>
        </member>
        <member name="M:EQTG.General.Expressions.EvaluateFunction(System.String)">
            <summary>
            Evaluate a named function from our internal compiled code block
            </summary>
            <param name="functionName">Name of the function to invoke</param>
            <returns>Result as double</returns>
        </member>
        <member name="F:EQTG.General.Expressions.OurDiagnostics">
            <summary>
            Class diagnostics instance.
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myFunctions">
            <summary>
            Hash of functions to MethodInfo
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myProvider">
            <summary>
            CSharp compiler implementation
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myCompiler">
            <summary>
            Code compiler interface
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myCompilerParameters">
            <summary>
            Parameters to supply to the compiler
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myFunctionsBuildingNow">
            <summary>
            Functions being built atr this moment
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myCompilerResults">
            <summary>
            Result of the compilatiom
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myBuildNamespace">
            <summary>
            Namespace of the resultant class being built
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.myClassName">
            <summary>
            Storage for the class name of the dynamically compiled code
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.mySource">
            <summary>
            Raw source we are building
            </summary>
        </member>
        <member name="F:EQTG.General.Expressions.mySourceBuilder">
            <summary>
            StringBuilder to speed up concatenating source
            </summary>
        </member>
        <member name="P:EQTG.General.Expressions.ClassName">
            <summary>
            Class name property for the class that will be compiled
            </summary>
        </member>
        <member name="T:EQTG.General.Filename">
            <summary>
            Utilities for dealing with filenames
            </summary>
        </member>
        <member name="M:EQTG.General.Filename.GetStem(System.String)">
            <summary>
            Returns the filename without an extension
            </summary>
            <param name="fileName">Filename</param>
        </member>
        <member name="M:EQTG.General.Filename.GetExtension(System.String)">
            <summary>
            Returns the extension
            </summary>
            <param name="fileName">Filename</param>
        </member>
        <member name="M:EQTG.General.Filename.StripFileName(System.String)">
            <summary>
            Extracts just the filename from a filename which includes
            path information
            </summary>
            <param name="pathAndFilename">Path and filename</param>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.#ctor(System.Int32)">
            <summary>
            Creates a queue of the given capacity
            </summary>
            <param name="capacity">Max Queue capacity</param>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.push(`0)">
            <summary>
            Push new object to the queue
            </summary>
            <param name="o">Object to be pushed in the queue</param>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.canPush">
            <summary>
            Verifies that the max capacity of the queue is not reached
            </summary>
            <returns>true if max capacity is not reached, otherwise - false</returns>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.pop">
            <summary>
            Remove next object from the queue
            </summary>
            <returns>object</returns>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.canPop">
            <summary>
            Verifies that the queue is not empty
            </summary>
            <returns>true if there are objects in the queue, otherwise - false</returns>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.first">
            <summary>
            Returns next object in the queue without removing it
            </summary>
            <returns>object</returns>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.clear">
            <summary>
            Clear entire queue
            </summary>
        </member>
        <member name="M:EQTG.General.Generics.ProcessQueue`1.isEmpty">
            <summary>
            Verifies that the queue is empty
            </summary>
            <returns>true if empty, otherwise false</returns>
        </member>
        <member name="P:EQTG.General.Generics.ProcessQueue`1.Count">
            <summary>
            Number of objects in the queue
            </summary>
        </member>
        <member name="T:EQTG.General.IniFile">
            <summary>
            Represents a text file in INI or INF format.
            </summary>
            <remarks>
            Examples of INI files in common use are sql.ini and blueapps.inf.
            </remarks>
        </member>
        <member name="M:EQTG.General.IniFile.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.IniFile"/> class.
            </summary>
            <remarks>
            The new instance wraps %SystemRoot%\WIN.INI.
            </remarks>
        </member>
        <member name="M:EQTG.General.IniFile.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.IniFile"/> class.
            </summary>
            <param name="name">Name of the INI file to access.</param>
        </member>
        <member name="M:EQTG.General.IniFile.WriteValue(System.String,System.String,System.String)">
            <summary>
            Writes a value to the file.
            </summary>
            <param name="section">Name of the section.</param>
            <param name="key">Name of the key.</param>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:EQTG.General.IniFile.ReadValue(System.String,System.String)">
            <summary>
            Reads a value from the file.
            </summary>
            <param name="section">Name of the section.</param>
            <param name="key">Name of the key.</param>
            <returns>Value read from the INI file, or an empty string if either the section or the key does not exist.</returns>
        </member>
        <member name="M:EQTG.General.IniFile.ReadValue(System.String,System.String,System.String)">
            <summary>
            Reads a value from the file.
            </summary>
            <param name="section">Name of the section.</param>
            <param name="key">Name of the key.</param>
            <param name="defaultValue">Value to return if the section or the key does not exist.</param>
            <returns>Value read from the INI file, or <paramref name="defaultValue" /> if either the section or the key does not exist.</returns>
        </member>
        <member name="M:EQTG.General.IniFile.GetSectionNames">
            <summary>
            Gets the names of the sections in the file.
            </summary>
            <returns>Array of strings containing the section names.</returns>
        </member>
        <member name="M:EQTG.General.IniFile.GetValueNames(System.String)">
            <summary>
            Gets the names of the values in the specified section.
            </summary>
            <param name="section">Name of the section.</param>
            <returns>Array of strings containing value names.</returns>
        </member>
        <member name="M:EQTG.General.IniFile.Flush">
            <summary>
            Flushes the cached values to the file.
            </summary>
            <remarks>
            Windows caches the contents of INI files. This function requests Windows to write its cache to disk.
            </remarks>
        </member>
        <member name="P:EQTG.General.IniFile.Name">
            <summary>
            Gets or sets the name of the INI file.
            </summary>
        </member>
        <member name="P:EQTG.General.IniFile.Encoding">
            <summary>
            Gets or sets the <see cref="P:EQTG.General.IniFile.Encoding"/> used when reading and writing values.
            </summary>
            <remarks>
            Defaults to <see cref="P:System.Text.Encoding.Default"/>, which refers to the current ANSI code page.
            </remarks>
        </member>
        <member name="T:EQTG.General.Process.EventThrottle">
            <summary>
            Base algorithm for event throttling
            	o How many events to be processed 
            	o When
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.myParams">
            <summary>
            Params
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.#ctor(EQTG.General.Process.EventThrottleProcessor)">
            <summary>
            C'tor
            </summary>
            <param name="eventProcessor">Interface to thing that will actually do the processing</param>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.#ctor(EQTG.General.Process.EventThrottleProcessor,EQTG.General.Process.EventThrottleParams)">
            <summary>
            C'tor
            </summary>
            <param name="eventProcessor">Interface to thing that will actually do the processing</param>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.Start">
            <summary>
            Start the EventThrottle. Derived class will actually kick off its timers here.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.Stop">
            <summary>
            Stop this Throttle prcessing events
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.OnLongInterval">
            <summary>
            Long interval has passed. Makes sure that we bring the events processed back in line with the desired number
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.OnShortInterval">
            <summary>
            Short interval has passed. Process the appropriate number of events.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.OnDispatchedEvents(System.Int32)">
            <summary>
            Virtual debug method to allow recording of additional specialised information by derived EventThrottles
            </summary>
            <param name="processedCount">Number of events processed</param>
        </member>
        <member name="M:EQTG.General.Process.EventThrottle.CapMaxEventsToProcess(System.Int32)">
            <summary>
            Make sure we don't try to process too many events at one go
            </summary>
            <param name="maxToProcess">Maximum events to process</param>
            <returns>Capped maximum events to process</returns>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.myLastLongInterval">
            <summary>
            Last time we had a long interval
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.myLastShortInterval">
            <summary>
            Last time we had a short interval
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.myEventsProcessedInLongInterval">
            <summary>
            Events processed since the last long interval
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.myEventProcessor">
            <summary>
            External event processor
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottle.myActive">
            <summary>
            Flag to indicate whether this bakground executor is active or not
            </summary>
        </member>
        <member name="E:EQTG.General.Process.EventThrottle.OnEventThrottleLongInterval">
            <summary>
            Notification event 
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottle.EventsPerSecondLimit">
            <summary>
            Desried maximum events per second to be processed
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottle.ShortInterval">
            <summary>
            When the short interval timer will fire (with some inaccuracy assumed)
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottle.LongInterval">
            <summary>
            When the long interval timer will fire to allow corrections
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottle.Active">
            <summary>
            Active property. True when the throttle is active
            </summary>
        </member>
        <member name="T:EQTG.General.Process.EventThrottle.EventThrottleLongIntervalHandler">
            <summary>
            Notification function
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottleParams.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.Process.EventThrottleParams.#ctor">
            <summary>
            C'tor
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottleParams.myEventsPerSecondLimit">
            <summary>
            Desried maximum events per second to be processed
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottleParams.myShortInterval">
            <summary>
            When the short interval timer will fire (with some inaccuracy assumed) in seconds
            </summary>
        </member>
        <member name="F:EQTG.General.Process.EventThrottleParams.myLongInterval">
            <summary>
            When the long interval timer will fire to allow corrections in seconds
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottleParams.EventsPerSecondLimit">
            <summary>
            Desried maximum events per second to be processed
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottleParams.ShortInterval">
            <summary>
            When the short interval timer will fire (with some inaccuracy assumed)
            </summary>
        </member>
        <member name="P:EQTG.General.Process.EventThrottleParams.LongInterval">
            <summary>
            When the long interval timer will fire to allow corrections
            </summary>
        </member>
        <member name="T:EQTG.General.Process.GCWhip">
            <summary>
            Summary description for GCWhip.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.GCWhip.#ctor(System.Int64,System.Int64,EQTG.General.Diagnostic.DiagnosticsMethodsBase)">
            <summary>
            A GCWhip will periodically report GC stats and/or force a GC collection
            </summary>
            <param name="initialWait"></param>
            <param name="period"></param>
            <param name="diagnostics">A DiagnosticsMethodBase to log text output to. If none is provided
            the text is logged to the class Diagnostics of GCWhip</param>
        </member>
        <member name="T:EQTG.General.Process.ProcessHealth">
            <summary>
            Indicator and store of process health.
            Has minimal functionality and acts purely as a single point of reference
            for disparate code to determine what state the process is in.
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.myState">
            <summary>
            State storage
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.OurDiagnostics">
            <summary>
            Class diagnostics
            </summary>
        </member>
        <member name="E:EQTG.General.Process.ProcessHealth.GracefulShutdown">
            <summary>
            Event to invoke when process health/state has been set to Graceful Shutdown
            </summary>
        </member>
        <member name="E:EQTG.General.Process.ProcessHealth.ImmediateShutdown">
            <summary>
            Event to invoke when process health/state is changed to ImmediateShutdown
            </summary>
        </member>
        <member name="E:EQTG.General.Process.ProcessHealth.NormalRunning">
            <summary>
            Event to invoke when process health/state is changed to Normal Running
            </summary>
        </member>
        <member name="P:EQTG.General.Process.ProcessHealth.ProcessState">
            <summary>
            Process State. Setting the process to a shutdown state will initiatye shutdown
            assuming the appropriate handler is hooked in.
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ProcessHealth.GracefulShutdownHandler">
            <summary>
            Notification handler for when the process is asked to shutdown gracefully
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ProcessHealth.ImmediateShutdownHandler">
            <summary>
            Notification handler for when the process is asked to shutdown immediately
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ProcessHealth.NormalRunningHandler">
            <summary>
            Notification handler for when the process is indicated as running normally
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ProcessHealth.State">
            <summary>
            Indication of the state of the process
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.State.Startup">
            <summary>
            Process in startup state
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.State.NormalRunning">
            <summary>
            Process is running normally
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.State.GracefulShutdown">
            <summary>
            Process is shutting down gracefully
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ProcessHealth.State.ImmediateShutdown">
            <summary>
            Process is undergoing a forced shutdown
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ProcessUtils">
            <summary>
            Summary description for ProcessUtils.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.ProcessUtils.ShowProcessCmd(EQTG.General.Application.AppCommandLineProcessor,System.Object[])">
            <summary>
            Display some process information
            </summary>
            <param name="context"></param>
            <param name="args"></param>
        </member>
        <member name="T:EQTG.General.Process.SysTimerEventThrottle">
            <summary>
            System Timer based implementation of the event throttle
            Beware that the intervals will occur in a new thread each time
            </summary>
        </member>
        <member name="F:EQTG.General.Process.SysTimerEventThrottle.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.Process.SysTimerEventThrottle.#ctor(EQTG.General.Process.EventThrottleProcessor)">
            <summary>
            C'tor
            </summary>
            <param name="eventProcessor">Interface to thing that will actually do the processing</param>
        </member>
        <member name="M:EQTG.General.Process.SysTimerEventThrottle.#ctor(EQTG.General.Process.EventThrottleProcessor,EQTG.General.Process.EventThrottleParams)">
            <summary>
            C'tor
            </summary>
            <param name="eventProcessor">Interface to thing that will actually do the processing</param>
        </member>
        <member name="M:EQTG.General.Process.SysTimerEventThrottle.Start">
            <summary>
            Start the EventThrottle. Derived class will actually kick off its timers here.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.SysTimerEventThrottle.OnShortInterval(System.Object)">
            <summary>
            Short interval Timer callback
            </summary>
            <param name="o">Ignored</param>
        </member>
        <member name="M:EQTG.General.Process.SysTimerEventThrottle.OnLongInterval(System.Object)">
            <summary>
            Long interval Timer callback
            </summary>
            <param name="o">Ignored</param>
        </member>
        <member name="M:EQTG.General.Process.SysTimerEventThrottle.Stop">
            <summary>
            Stop processing events
            </summary>
        </member>
        <member name="F:EQTG.General.Process.SysTimerEventThrottle.myLongIntervalTimer">
            <summary>
            Threading Timer member (long)
            </summary>
        </member>
        <member name="F:EQTG.General.Process.SysTimerEventThrottle.myShortIntervalTimer">
            <summary>
            Threading timer member (short)
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ThreadShutdownController">
            <summary>
            Ensures that when a Daemon thread crashes and requests that the rest of the Daemon be 
            shutdown it does so.
            </summary>
            <note>
            The last thread to access the <see cref="P:EQTG.General.Process.ThreadShutdownController.KeepProcessing"/> property (which would in the example
            correctly be the thread whose event loop you wanted to terminate) will be interrupted if in a 
            sleeping state and the <see cref="M:EQTG.General.Process.ThreadShutdownController.ShutdownAllThreads"/> method is invoked. This would result 
            in the thread getting a <see cref="T:System.Threading.ThreadInterruptedException"/>.
            </note>
            <example>
            <code>
            public void ThreadMain()
            {
            	ThreadShutdownController myController = new ThreadShutdownController(); // Can also be a class member if you like
            	// Start thread event processing loop
            	while (myController.KeepProcessing)
            	{
            		try
            		{
            			... // Main work of the thread
            		}
            		catch (ThreadInterruptedException e)
            		{
            			if (myController.KeepProcessing)
            			{
            				// ... do whatever needs to be done if we are interrupted
            			}
            			else break;		// We are being shutdown gracefully
            	}
            	myController.Dispose();
            }
            </code>
            </example>
        </member>
        <member name="F:EQTG.General.Process.ThreadShutdownController.OurInstances">
            <summary>
            A list of all the instances of the <see cref="T:EQTG.General.Process.ThreadShutdownController"/> class.
            </summary>
            <remarks>
            These are weak references so collection should occur event when people do not explicitly 
            <see cref="M:EQTG.General.Process.ThreadShutdownController.Dispose"/> of their <see cref="T:EQTG.General.Process.ThreadShutdownController"/> instances.
            Object is thread safe since it is public static.
            </remarks>
        </member>
        <member name="F:EQTG.General.Process.ThreadShutdownController.mySemaphore">
            <summary>
            Flag to indicate if our event loop should continue to run we start as true and only change to stopped.
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ThreadShutdownController.OurDefaultSemaphore">
            <summary>
            We need to be able to ensure that once we have been asked to shutdown all threads we do not
            allow any further ones to start up.
            </summary>
        </member>
        <member name="F:EQTG.General.Process.ThreadShutdownController.myThread">
            <summary>
            Store which thread last checked to see if it should continue processing so that we can Intterupt it
            if we are asked to shutdown.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.ThreadShutdownController.ShutdownAllThreads">
            <summary>
            Causes all threads using this class as their event loop control to exit.
            </summary>
            <remarks>
            This method returns immediately rather than waiting for threads to exit, allowing 
            the main thread to continue work or just join on its child threads.
            </remarks>
        </member>
        <member name="M:EQTG.General.Process.ThreadShutdownController.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.General.Process.ThreadShutdownController"/> class.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.ThreadShutdownController.Dispose">
            <summary>
            Removes us from the list of instances right now
            </summary>
        </member>
        <member name="P:EQTG.General.Process.ThreadShutdownController.KeepProcessing">
            <summary>
            Gets or sets a flag indicating whether event processing loops that check this property
            should exit.
            </summary>
        </member>
        <member name="T:EQTG.General.Process.ThreadUtils">
            <summary>
            Thread utilities.
            </summary>
        </member>
        <member name="M:EQTG.General.Process.ThreadUtils.ShowWarehouseProcessCmd(EQTG.General.Application.AppCommandLineProcessor,System.Object[])">
            <summary>
            AppCommand list threads - use to display all .NET accessible threads
            </summary>
            <param name="context"></param>
            <param name="args"></param>
        </member>
        <member name="M:EQTG.General.Process.ThreadUtils.ExecuteTimeBoundedFunction(System.Threading.ThreadStart,EQTG.General.Process.ThreadUtils.TimeoutValue)">
            <summary>
            Syncronously executes a function, but bounds it's total execution time, 
            aborting the function if the timeout is exceeded
            </summary>
            <param name="func">The delegate to the function</param>
            <param name="timeout">The timeout value to use</param>
        </member>
        <member name="M:EQTG.General.Process.ThreadUtils.ExecuteTimeBoundedFunction(System.Threading.ThreadStart,System.TimeSpan)">
            <summary>
            Syncronously executes a function, but bounds it's total execution time, 
            aborting the function if the timeout is exceeded
            </summary>
            <param name="func">The delegate to the function</param>
            <param name="timeout">The timeout value to use</param>
        </member>
        <member name="T:EQTG.General.Process.ThreadUtils.TimeoutValue">
            <summary>
            The set of timeout values that can be specified throughout the application
            Use of an enum is to avoid hardcoded time values in the code
            </summary>
        </member>
        <member name="T:EQTG.General.Reflection.Accessor">
            <summary>
            Summary description for Accessor.
            </summary>
        </member>
        <member name="M:EQTG.General.Reflection.Accessor.GettersHashFromAccessorsHash(System.Collections.Hashtable)">
            <summary>
            This method converts a hash of accessors (keyed by tibField) to a hash of getters
            The resultant hash may have fewer key/value pairs than the input since not all accessors
            support getting (e.g. when the underlying member is a write-only property)
            </summary>
            <param name="accessorsHash"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Reflection.Accessor.SettersHashFromAccessorsHash(System.Collections.Hashtable)">
            <summary>
            This method converts a hash of accessors (keyed by tibField) to a hash of setters
            The resultant hash may have fewer key/value pairs than the input since not all accessors
            support setting (e.g. when the underlying member is a read-only property)
            </summary>
            <param name="accessorsHash"></param>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.Reflection.FieldToAccessorAdapter">
            <summary>
            This class wraps a FieldInfo object (available on a class field from the standard reflection API)
            to provide a general Accessor interface
            </summary>
        </member>
        <member name="T:EQTG.General.Reflection.PropertyToAccessorAdapter">
            <summary>
            This class wraps a PropertyInfo object (available on a class field from the standard reflection API)
            to provide a general Accessor interface
            </summary>
        </member>
        <member name="T:EQTG.General.Reflection.ReflectionUtilities">
            <summary>
            Object activation across multiple assemblies
            </summary>
        </member>
        <member name="M:EQTG.General.Reflection.ReflectionUtilities.ActivateObjectFromAcrossAssemblies(System.String)">
            <summary>
            Create an object of the given class name from all loaded assemblies
            </summary>
            <param name="className">Name of the class to create</param>
            <returns>New instance of the object</returns>
        </member>
        <member name="M:EQTG.General.Reflection.ReflectionUtilities.GetContainingLoadedAssemblyName(System.String)">
            <summary>
            Find a loaded assemblies 
            </summary>
            <param name="className">Name of the class</param>
            <returns>Name of the assembly</returns>
        </member>
        <member name="M:EQTG.General.Reflection.ReflectionUtilities.AssemblyContainsClassName(System.Reflection.Assembly,System.String)">
            <summary>
            Simple check to see whether 
            </summary>
            <param name="assembly"></param>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Reflection.ReflectionUtilities.ForceLoadOfLocalAssemblies">
            <summary>
            Force load all assemblies in the same directory as the entry point.
            This is crude!
            </summary>
        </member>
        <member name="M:EQTG.General.Reflection.ReflectionUtilities.GetDerivedTypes(System.Type,System.Type)">
            <summary>
            Creates an ArrayList of every type in the class hierachy between startType (exlcuded) and endType.
            </summary>
            <remarks>
            <para>For instance, if:</para>
            
            <code>
            	System.Object
            		|
                  TypeA
            		|
            	  TypeB
            		|
            	  TypeC
            	    |
            	  TypeD
            </code>
            	  
            <para>then GetDerivedTypes(typeof(TypeB), typeof(TypeD)) will return an array list
            containing typeof(TypeC), typeof(TypeD).</para>
            
            <para>If endType == startType returns an empty list.</para>
            </remarks>
            <param name="startType">Type to begin serachnig from - not returned in result</param>
            <param name="endType">Type to stop searching at - included in result</param>
        </member>
        <member name="M:EQTG.General.Reflection.ReflectionUtilities.GetInheritedTypes(System.Type,System.Type)">
            <summary>
            Creates an ArrayList of every type in the class hierachy between endType (exlcuded) and startType.
            </summary>
            <remarks>
            <para>For instance, if:</para>
            
            <code>
            	System.Object
            		|
                  TypeA
            		|
            	  TypeB
            		|
            	  TypeC
            	    |
            	  TypeD
            </code>
            
            <para>then GetInheritedTypes(typeof(TypeB), typeof(TypeD)) will return an array list
            containing typeof(TypeB), typeof(TypeC).</para>
            
            <para>If endType == startType returns a list containing endType.</para>
            </remarks>
            <param name="startType">Type to begin serachnig from - not returned in result</param>
            <param name="endType">Type to stop searching at - included in result</param>
        </member>
        <member name="F:EQTG.General.Reflection.ReflectionUtilities.OurDiagnostics">
            <summary>
            Standard class diagnostics instance
            </summary>
        </member>
        <member name="M:EQTG.General.Security.TripleDes.BuildKey(System.String)">
            <summary>
            Hashes the key word provided with a default key to produce a random-looking 24-byte
            key
            </summary>
            <param name="word">Key word</param>
            <returns>Random-looking key</returns>
        </member>
        <member name="M:EQTG.General.Security.TripleDes.Decrypt(System.String,System.String)">
            <summary>
            Encrypts a hex string using the ASCII key word provided
            </summary>
            <param name="word">Hex string to encrypt</param>
            <param name="key">Word used to generate a key</param>
            <returns>Decrypted string</returns>
        </member>
        <member name="M:EQTG.General.Security.TripleDes.Encrypt(System.String,System.String)">
            <summary>
            Encrypts a string using the ASCII key word provided
            </summary>
            <param name="word">String to encrypt</param>
            <param name="key">Word used to generate a key</param>
            <returns>Encrypted hex string</returns>
        </member>
        <member name="M:EQTG.General.Security.TripleDes.Decrypt(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Decrypts data using the key provided
            </summary>
            <param name="data">Data to decrypt</param>
            <param name="offset">Location within data at which to start decryption</param>
            <param name="length">Number of bytes to decrypt</param>
            <param name="key">24-byte key</param>
            <returns>Decrypted data</returns>
        </member>
        <member name="M:EQTG.General.Security.TripleDes.Encrypt(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Encrypts data using the key provided
            </summary>
            <param name="data">Data to encrypt</param>
            <param name="offset">Location within data at which to start encryption</param>
            <param name="length">Number of bytes to encrypt</param>
            <param name="key">24-byte key</param>
            <returns>Encrypted data</returns>
        </member>
        <member name="T:EQTG.General.Statistics">
            <summary>
            Take observations (doubles) and produce:
            . count
            . min
            . max
            . average
            . variance
            . stddev
            
            All statistics created are stored in the static OurStatistics so that you can get a
            single string (AllToString) which contains all the statistics for the process sorted
            in alphabetic order (useful for logging purposes)
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.OurMaxNameLength">
            <summary>
            Used to ensure we can output statistics with readable format
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.OurStatistics">
            <summary>
            List of all the statistics the application has created
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.OurDiagnostics">
            <summary>
            Class Diagnostics
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.myTotal">
            <summary>
            Total of all observations we have seen
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.mySquaredTotal">
            <summary>
            Total squared of all observations we have seen
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.myMax">
            <summary>
            Max of all observations we have seen
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.myMin">
            <summary>
            Minimun of all observations we have seen
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.myName">
            <summary>
            This is used to output a name with information from this class
            </summary>
        </member>
        <member name="F:EQTG.General.Statistics.myUnits">
            <summary>
            Stores the unit of the numbers we generate
            </summary>
        </member>
        <member name="M:EQTG.General.Statistics.#ctor(System.String,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="name"></param>
            <param name="units"></param>
        </member>
        <member name="M:EQTG.General.Statistics.CompareTo(System.Object)">
            <summary>
            Used to compare this object to other objects
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Statistics.AddObservation(System.Double)">
            <summary>
            Add an observation for our calculations
            </summary>
            <param name="observation"></param>
        </member>
        <member name="M:EQTG.General.Statistics.AddNObservations(System.Int32,System.Double)">
            <summary>
            Lets you add a number that represents the total for N observations
            </summary>
            <param name="n"></param>
            <param name="observation"></param>
        </member>
        <member name="M:EQTG.General.Statistics.ToString">
            <summary>
            Converts this Statistic to a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Statistics.ToString(System.String)">
            <summary>
            Converts this Statistic to a string conforming to the given format
            We output a string in excel csv format
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Statistics.AllToString(System.String)">
            <summary>
            Returns a string that contains all our statistics one on each line
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.General.Statistics.FindOrCreate(System.String,System.String)">
            <summary>
            Used to give a weak singleton pattern for Statistics objects.
            </summary>
            <param name="name"></param>
            <param name="units"></param>
            <returns></returns>
        </member>
        <member name="P:EQTG.General.Statistics.Average">
            <summary>
            Calculates the average when we need it
            </summary>
        </member>
        <member name="P:EQTG.General.Statistics.Min">
            <summary>
            Returns the Minimum observation we have seen
            </summary>
        </member>
        <member name="P:EQTG.General.Statistics.Max">
            <summary>
            Returns the Maximun observation we have seen
            </summary>
        </member>
        <member name="P:EQTG.General.Statistics.Total">
            <summary>
            Retruns the Total of all observations we have seen
            </summary>
        </member>
        <member name="P:EQTG.General.Statistics.Variance">
            <summary>
            Computes the variance of our observations
            </summary>
        </member>
        <member name="T:EQTG.General.SystemInfo">
            <summary>This class is a wrapper around GetSystemInfo</summary>
        </member>
        <member name="F:EQTG.General.SystemInfo.mySystemInfo">
            <summary>The 1 and only 1 system info</summary>
        </member>
        <member name="M:EQTG.General.SystemInfo.reset">
            <summary>Re-read the values stored in the class</summary>
        </member>
        <member name="M:EQTG.General.SystemInfo.#cctor">
            <summary>Class constr</summary>
        </member>
        <member name="M:EQTG.General.SystemInfo.is3GbEnabled">
            <summary>Returns true if the application can address more than 2 Gb of memory</summary>
        </member>
        <member name="T:EQTG.General.UserPreferences">
            <summary>
            Base class for reading in user preferences
            Derived for each application
            </summary>
        </member>
        <member name="M:EQTG.General.UserPreferences.AddPreference(System.String,System.String,System.Int32)">
            <summary>
            Set the given attribute to the given value 
            </summary>
            <param name="attribute">Attribute to be set</param>
            <param name="attVal">Value to set it to</param>
            <param name="dbIdx">Index of this row in the database</param>
        </member>
        <member name="T:EQTG.General.UserPreferenceFactory">
            <summary>
            Loads up user preferences
            </summary>
        </member>
        <member name="M:EQTG.General.UserPreferenceFactory.#ctor(System.String,System.String,System.Type)">
            <summary>
            Create and populate the factory
            </summary>
            <param name="connectionString">DB connection string to get preferences from</param>
            <param name="application">The application we want preferences for (e.g. EQTicket)</param>
        </member>
        <member name="M:EQTG.General.UserPreferenceFactory.GetPreferences(System.Int32)">
            <summary>
            Get the preferences for a single user
            </summary>
        </member>
        <member name="M:EQTG.General.UserPreferenceFactory.DoCreatePreference(System.Int32,System.String)">
            <summary>
            Factory method to create a preferences object of the appropriate derived type
            </summary>
            <param name="userId">User id</param>
            <returns></returns>
        </member>
        <member name="T:EQTG.General.WebFormUtils">
            <summary>
            Useful functions related to web forms
            </summary>
        </member>
        <member name="T:EQTG.Logging.Log4Net">
            <summary>
            Logging Class
            </summary>
        </member>
        <member name="P:EQTG.Logging.Log4Net.OutputDirectory">
            <summary>
            Where to write the logs (by default the current directory)
            </summary>
        </member>
        <member name="T:EQTG.Logging.Log4Net.Log4NetOutputDir">
            <summary>
            Interacts with Log4Net framework to set output directory for logs.
            </summary>
        </member>
        <member name="M:EQTG.Logging.Log4Net.Log4NetOutputDir.Convert(System.IO.TextWriter,System.Object)">
            <summary>
            Convert
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.DatabaseSpaceMonitor">
            <summary>
            Checks the free space on the database
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.IDaemonMonitor">
            <summary>
            Implemented by components which can monitor production daemons or processess
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.IMonitor">
            <summary>
            Summary description for IMonitor.
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.ICommandParameterClient">
            <summary>
            Interface for something that wants to get supplied with a CommandParameterList instance
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.IMonitorDetail">
            <summary>
            Summary description for IMonitor.
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.DatabaseSpaceMonitor.myDetailPageName">
            <summary>
            Detail page storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.DatabaseSpaceMonitor.myCommandParameters">
            <summary>
            Storage for command parameters
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.DatabaseSpaceMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Override to receive command params
            </summary>
            <param name="commandParameterList">Command params</param>
        </member>
        <member name="M:EQTG.Monitoring.DatabaseSpaceMonitor.SetDetailPageName(System.String)">
            <summary>
            Set detail page nmae
            </summary>
            <param name="detailPageName">Name of detail page to create</param>
        </member>
        <member name="M:EQTG.Monitoring.DatabaseSpaceMonitor.GetDatabaseLimits">
            <summary>
            Create a hash table of database name + database segmap to store specific
            database error and warning limits to override the default values
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.DatabaseSpaceMonitor.GetDatabaseSpace(System.Collections.Hashtable)">
            <summary>
            Calls sp_dbfree to get a table of databases, space and free space
            </summary>
            <returns>An ArrayList of the databases and their spaces</returns>
        </member>
        <member name="M:EQTG.Monitoring.DatabaseSpaceMonitor.CheckDatabase(EQTG.Monitoring.DatabaseSpaceMonitor.DatabaseUsage,System.String@)">
            <summary>
            Checks database free space usage
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.DatabaseSpaceMonitor.DaemonName">
            <summary>
            The name of this monitor
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.DatabaseSpaceMonitor.DatabaseUsage">
            <summary>
            Class to store Database name and disk space usage		
            and warning and error limit percentages
            /// </summary>
        </member>
        <member name="T:EQTG.Monitoring.DatabaseSpaceMonitor.DatabaseLimitInfo">
            <summary>
            Small class to store individual database limits
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.DiskSpaceMonitor">
            <summary>
            Ensures we have enough free disk space on our servers
            
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.DiskSpaceMonitor.SetDetailPageName(System.String)">
            <summary>
            Set detail page nmae
            </summary>
            <param name="detailPageName">Name of detail page to create</param>
        </member>
        <member name="M:EQTG.Monitoring.DiskSpaceMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Override to receive command parameters
            </summary>
            <param name="cpl">Command parameters</param>
        </member>
        <member name="F:EQTG.Monitoring.DiskSpaceMonitor.myCommandParameters">
            <summary>
            Command parameter storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.DiskSpaceMonitor.myDaemonName">
            <summary>
            Daemon name storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.DiskSpaceMonitor.myDetailPageName">
            <summary>
            Detail page storage
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.ErrorInfo">
            <summary>
            Summary description for ErrorInfo.
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.FlexibleSystemsHealthMonitor">
            <summary>
            Executes a series of database queries for systems health checking
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myConnectionStr">
            <summary>
            String representing the database connection parameters -U -P etc
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myDaemonName">
            <summary>
            Unique identifier for this instance
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myDetailPageName">
            <summary>
            Detail page storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myCommandParameters">
            <summary>
            Storage for command parameters
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myQueries">
            <summary>
            Hashtable of records from table systemsHealthMonitorQueries
            with monitorId = id of this monitor
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.isInitialised">
            <summary>
            Set to true after Initialise() successfully called
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myMonitorName">
            <summary>
            The short name of the monitor instance
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myNextTest">
            <summary>
            The earliest time of the next invocation of the IsWorking method
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myPeriod">
            <summary>
            The time in minutes between invocations of the IsWorking method
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myLastMonitorCode">
            <summary>
            Cache the last code so it isn't lost if IsWorking is skipped
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myLastMessage">
            <summary>
            Cache the last message so it isn't lost if IsWorking is skipped
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.FlexibleSystemsHealthMonitor.myMonitorTimeout">
            <summary>
            Maximum time in seconds that the monitor should attempt the query 
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.QueryEnumerator">
            <summary>
            Return an enumerator for the query hashtable
            </summary>
            <returns></returns>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Override to receive command params
            </summary>
            <param name="commandParameterList">Command params</param>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.SetDetailPageName(System.String)">
            <summary>
            Set detail page nmae
            </summary>
            <param name="detailPageName">Name of detail page to create</param>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.Initialise(System.Data.IDbConnection)">
            <summary>
            Set up the hashtable of SystemsHealthQueries from the command line parameter
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.CreateResultsTempTable(EQTG.Monitoring.FlexibleSystemsHealthMonitor,System.Data.IDbConnection)">
            <summary>
            Set up the results temporary table
            </summary>
            <param name="monitor">Monitor to set up the table for</param>
            <param name="db">Database connection to use</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Monitoring.FlexibleSystemsHealthMonitor.IsWorking(System.String@)">
            <summary>
            Override of synchronous monitor method IsWorking
            </summary>
            <param name="message">Status message to fill in</param>
            <returns>Status OK/Warning/Error</returns>
        </member>
        <member name="P:EQTG.Monitoring.FlexibleSystemsHealthMonitor.Timeout">
            <summary>
            Maximum time (seconds) that the monitor should spend querying
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.FlexibleSystemsHealthMonitor.MonitorName">
            <summary>
            The short name of the monitor instance 
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.FlexibleSystemsHealthMonitor.DaemonName">
            <summary>
            The name of this monitor
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.IAsyncCallback">
            <summary>
            Callback interface for async monitors
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.IAsyncCallback.SetErrorInfo(EQTG.Monitoring.ErrorInfo)">
            <summary>
            </summary>
            <param name="daemonName"></param>
            <param name="errorInfo"></param>
        </member>
        <member name="T:EQTG.Monitoring.IAsyncMonitor">
            <summary>
            Implemented by components which can monitor production daemons or processess
            where the component wishes to behave asyncronously
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.IErrorRegister">
            <summary>
            Summary description for IErrorRegister.
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.IErrorSink">
            <summary>
            Summary description for IErrorSink.
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.InEventsMonitor">
            <summary>
            Summary description for InEventsMonitor.
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.InEventsMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Override for setting command parameters
            </summary>
            <param name="commandParameterList">Command param list</param>
        </member>
        <member name="F:EQTG.Monitoring.InEventsMonitor.myCommandParameters">
            <summary>
            Command parameters storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.InEventsMonitor.myDaemonName">
            <summary>
            Daemon name storage
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.SampleAsyncMonitor">
            <summary>
            An example of an async monitor
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.SampleAsyncMonitor.myDaemonName">
            <summary>
            Daemon name storage
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.ServerMonitor">
            <summary>
            Goes and "pings" various servers.  If it gets no response 
            then assumes they are dead
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.ServerMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Override to receive command parameters
            </summary>
            <param name="cpl">Command parameters</param>
        </member>
        <member name="F:EQTG.Monitoring.ServerMonitor.myCommandParameters">
            <summary>
            Command parameter storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.ServerMonitor.myDaemonName">
            <summary>
            Daemon name storage
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.StatusQueryResultTempTable">
            <summary>
            Summary description for StatusQueryResultsTempTable.
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.StatusQueryResultTempTable.myUpdateTableCommand">
            <summary>
            SQL to update the temp table
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.StatusQueryResultTempTable.myIndexCreated">
            <summary>
            Signals whether an index has been created on the temporary table
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.StatusQueryResultTempTable.myQueryIdIndex">
            <summary>
            db table index of query id column
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.StatusQueryResultTempTable.myQueryDescriptionIndex">
            <summary>
            db table index of query description index
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.StatusQueryResultTempTable.myStatusResultIndex">
            <summary>
            db table index of status reuslt index
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.StatusQueryResultTempTable.myDetailResultIndex">
            <summary>
            db table index of detail result index
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.StatusQueryResultTempTable.#ctor(EQTG.Monitoring.FlexibleSystemsHealthMonitor,System.Data.IDbConnection,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="monitor">The monitor with which this temp table is associated</param>
            <param name="db">The database connection to use</param>
            <param name="tableName">The name of the temporary table</param>
        </member>
        <member name="M:EQTG.Monitoring.StatusQueryResultTempTable.CreateIndex">
            <summary>
            Overridden function to create an index on the temporary table
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.StatusQueryResultTempTable.TableUpdateCommandFromQuery(EQTG.Monitoring.SystemsHealthQuery)">
            <summary>
            Constructs a command to update the temporary table with the result of
            the systems health query
            </summary>
            <param name="query">The query to execute</param>
            <returns>SQL to update the temp table</returns>
        </member>
        <member name="M:EQTG.Monitoring.StatusQueryResultTempTable.TableUpdateCommandFromMonitor(EQTG.Monitoring.FlexibleSystemsHealthMonitor)">
            <summary>
            Constructs a sequence of update commands from the queries associated with
            the monitor
            </summary>
            <param name="monitor">The monitor from which to get the queries</param>
            <returns>The SQL to update the temp table</returns>
        </member>
        <member name="M:EQTG.Monitoring.StatusQueryResultTempTable.ReadTable">
            <summary>
            Reads the entries in the temp table into a data reader
            </summary>
            <returns>IDataReader filled with data from the table</returns>
        </member>
        <member name="M:EQTG.Monitoring.StatusQueryResultTempTable.UpdateTable(EQTG.Monitoring.FlexibleSystemsHealthMonitor)">
            <summary>
            Update the temp table using the commands from the monitor
            </summary>
            <param name="monitor"></param>
        </member>
        <member name="P:EQTG.Monitoring.StatusQueryResultTempTable.ColumnDefinitions">
             <summary>
            Overridden functiom to define the columns in the new table. Must include the round brackets
             </summary>
        </member>
        <member name="P:EQTG.Monitoring.StatusQueryResultTempTable.QueryIdIndex">
            <summary>
            return the query result index
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.StatusQueryResultTempTable.QueryDescriptionIndex">
            <summary>
            return the query description index
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.StatusQueryResultTempTable.StatusResultIndex">
            <summary>
            return the status result index
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.StatusQueryResultTempTable.DetailResultIndex">
            <summary>
            return the detail result index
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.STPDaemonMonitor">
            <summary>
            Ensures the STPDaemon is working correctly
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.STPDaemonMonitor.myDaemonName">
            <summary>
            Daemon name storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.STPDaemonMonitor.myCommandParameters">
            <summary>
            Command parameter storage
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.STPDaemonMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Set command parameters for later use.
            </summary>
            <param name="commandParameterList">Command parameters</param>
        </member>
        <member name="T:EQTG.Monitoring.SystemsHealthQuery">
            <summary>
            Summary description for SystemsHealthQuery.
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.SystemsHealthQuery.#ctor(System.Int32,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="queryId">unique id for the query</param>
            <param name="queryDesc">a short description of the query</param>
            <param name="statusQuery">the main query to execute</param>
            <param name="detailQuery">a query which gets more detail</param>
            <param name="warningThreshold">threshold at which monitor should report a warning</param>
            <param name="errorThreshold">threshold at which monitor should report an error</param>
            <param name="queryTimeout">timeout (ms) after which query should abort</param>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.QueryId">
            <summary>
            Return the query Id
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.QueryDescription">
            <summary>
            Return the query description
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.StatusQuery">
            <summary>
            Return the status query
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.DetailQuery">
            <summary>
            Return the detail query
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.WarningThreshold">
            <summary>
            Return the warning threshold
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.ErrorThreshold">
            <summary>
            Return the error threshold
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.SystemsHealthQuery.QueryTimeout">
            <summary>
            Return the query timeout
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.TAPConsumerMonitor">
            <summary>
            Simple monitor for TAP clients. 
            Uses telnet to connect to the standard TAP monitor server and use its interface
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.#ctor">
            <summary>
            C'tor
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.SetCallback(EQTG.Monitoring.IAsyncCallback)">
            <summary>
            Store off the callback for later usage
            </summary>
            <param name="asyncCallback">Callback routine</param>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.StartMonitoring">
            <summary>
            IAsyncMonitor start monitoring implementation
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.MonitoringThreadProcessing">
            <summary>
            Background processing thread for this monitor
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.SiftTapConsumerResults(System.String,System.String,System.String@)">
            <summary>
            Check through the results to see if there's any errors.
            </summary>
            <param name="results">TAP Consumer results to check</param>
            <param name="patternMatch">Only look at lines with this embedded</param>
            <param name="errorMessage">Message to fill in</param>
            <returns>OK or error code</returns>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.WriteDetailPage(System.String)">
            <summary>
            Echo out the result to the detail page 
            </summary>
            <param name="consumerStatus">Status of the consumers</param>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Implementation for getting command parameters
            </summary>
            <param name="cpl">Command parameter list</param>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.SetDetailPageName(System.String)">
            <summary>
            Set and store the detail page reference
            </summary>
            <param name="detailPageName">Name of the detail page</param>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.RequestStopMonitoring">
            <summary>
            Time to kill the background thread
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TAPConsumerMonitor.Join">
            <summary>
            Join against the killed thread
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.OurDiagnostics">
            <summary>
            Class diagnostics
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.myCallback">
            <summary>
            Callback storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.myInstanceName">
            <summary>
            Instance name storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.myCommandParameters">
            <summary>
            Command parameters
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.myDetailPage">
            <summary>
            Name of detail page to create
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.myProcessingThread">
            <summary>
            Thread storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TAPConsumerMonitor.myShutdownController">
            <summary>
            Controller storage
            </summary>
        </member>
        <member name="P:EQTG.Monitoring.TAPConsumerMonitor.DaemonName">
            <summary>
            Name of the thing being monitored
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.TicketingMonitor">
            <summary>
            Ensures the EQRmsTicketing system is working correctly
            
            Reuses the existing "Load Ticket" UI test
            
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TicketingMonitor.SetCommandParameters(EQTG.General.Application.CommandParameterList)">
            <summary>
            Override to receive command parameters
            </summary>
            <param name="cpl">Command parameters</param>
        </member>
        <member name="F:EQTG.Monitoring.TicketingMonitor.myCommandParameters">
            <summary>
            Command parameter storage
            </summary>
        </member>
        <member name="F:EQTG.Monitoring.TicketingMonitor.myDaemonName">
            <summary>
            Daemon name storage
            </summary>
        </member>
        <member name="T:EQTG.Monitoring.TicketingMonitorHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:EQTG.Monitoring.TicketingMonitorHelper.isWorking(System.String,System.String,System.String@)">
            <summary>
            Test loading a sample ticket
            </summary>
            <param name="rootURL">Website we're aiming at</param>
            <param name="requestParams">defining the posId,sequence and version of the ticket in HTTP request format</param>
            <param name="reason">Returned reason for error (if any)</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Monitoring.TicketingMonitorHelper.anyTransientErrors(System.String,System.String@)">
            <summary>
            Returns any internal errors which have occurred in the last 10 mins
            </summary>
            <param name="rootURL"></param>
            <param name="reason"></param>
            <returns>true indicates errors</returns>
        </member>
        <member name="T:EQTG.Monitoring.TicketingMonitorHelper.TicketIDHelper">
            <summary>
            This is actually a bit of cut and paste from the ticketing project, but it vastly reduces project dependencies
            </summary>
        </member>
        <member name="T:EQTG.Network.DnsMXMailSender">
            <summary>
            Sends mail messages based on a DNS lookup.
            </summary>
            <example><code>
            Console.WriteLine("Running main method to send mail. {0}.", "");
            
            DnsMXMailSender mailSender = new DnsMxMailSender();
            string hostList = mailSender.PrintMXEntries();
            Console.WriteLine("MX entries:\n" + hostList);
            MailMessage mail = new MailMessage();
            // Will send mail to whoever runs this..
            mail.To = Environment.GetEnvironmentVariable("NOTIFY_ADDRESS");
            mail.From = Environment.GetEnvironmentVariable("NOTIFY_ADDRESS");
            mail.Body = "Test email for DNS lookup";
            mail.Subject = "Test email for DNS lookup";
            mailSender.Send(mail);
            </code></example>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Network.DnsMXMailSender"/> class.
            </summary>
            <remarks>
            The user's DNS domain is found from the USERDNSDOMAIN environment variable, 
            and "soe-mx." is pre-pended to find the MX entries for the user's domain.
            </remarks>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.Network.DnsMXMailSender"/> class.
            </summary>
            <param name="domain">Name of the domain to query for MX records</param>
            <remarks>The specified domain name is used to find MX entries.</remarks>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.Send(System.Web.Mail.MailMessage)">
            <summary>
            Send mailMessage using appropriate MX depending on location.
            </summary>
            <remarks>
            Iterates through sorted list of MXRecordEntries until it
            successfully sends a mail. Returns false if it fails to send mail
            </remarks>
            <param name="message"><see cref="T:System.Web.Mail.MailMessage"/> to send.</param>
            <exception cref="T:System.ApplicationException">If none of the mail hosts could send the message.</exception>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.Send(System.Net.Mail.MailMessage)">
            <summary>
            dotNet 2.0 compatible Send message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.PrintMXEntries">
            <summary>
            Return string listing mail hosts for the user's domain.
            </summary>
            <returns>String listing mail hosts for the user's domain.</returns>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.AddDefaultMailHosts(System.Collections.ArrayList)">
            <summary>
            Only need this in case all else fails. i.e if the MX
            entries in DNS don't work. Preferences are put at high values so that 
            they are only used as a last resort.
            This logic is also implemented in EQTelnetMail in cpp and is 
            implemented here for consistency. Hopefully should never resort
            MX enries listed here. 
            </summary>
            <param name="hostList"></param>
            <returns></returns>
        </member>
        <member name="M:EQTG.Network.DnsMXMailSender.GetMXRecords(System.String)">
            <summary>
            Return list of MX records by doing a DNS query for
            the given domain. Returns list of MXRecordEntries sorted 
            by preference.
            </summary>
            <param name="domain"></param>
            <returns>List of MXRecordEntries for given domain</returns>
        </member>
        <member name="F:EQTG.Network.DnsMXMailSender.OurDiagnostics">
            <summary>
            Class diagnostics instance
            </summary>
        </member>
        <member name="T:EQTG.Network.MXRecordEntry">
            <summary>
            Simple class that represents a MX entry in DNS. 
            We are only interested in MX name and preference. 
            Implements IComarable to sort a list of MXRecordEntry objects
            </summary>
        </member>
        <member name="T:EQTG.Network.PingRequest">
            <summary>
            Sends ICMP echo requests (pings) and waits for either a reply or for a timeout to elapse.
            </summary>
        </member>
        <member name="M:EQTG.Network.PingRequest.Send(System.String)">
            <summary>
            Pings the specified host
            </summary>
            <param name="host">Remote host name</param>
            <returns>An array of PingResponse structures, with one element for each response received,
            or an empty array if no responses were received within the timeout.</returns>
        </member>
        <member name="P:EQTG.Network.PingRequest.DataSize">
            <summary>
            Gets or sets the number of bytes of data sent in a request
            </summary>
        </member>
        <member name="P:EQTG.Network.PingRequest.Timeout">
            <summary>
            Gets or sets the timeout, in milliseconds, to wait for a reply
            </summary>
        </member>
        <member name="T:EQTG.Network.PingStatus">
            <summary>
            Status in a PingResponse structure
            </summary>
        </member>
        <member name="F:EQTG.Network.PingStatus.Fine">
            <summary>
            Remote host returned a reply within the timeout period
            </summary>
        </member>
        <member name="F:EQTG.Network.PingStatus.DataCorrupted">
            <summary>
            Remote host returned a reply but the data within was corrupted
            </summary>
        </member>
        <member name="T:EQTG.Network.PingResponse">
            <summary>
            Contains the round-trip time and the number of bytes for a ping reply
            </summary>
        </member>
        <member name="F:EQTG.Network.PingResponse.Status">
            <summary>
            Indicates whether the response was returned intact
            </summary>
        </member>
        <member name="F:EQTG.Network.PingResponse.RoundTripTime">
            <summary>Response time in milliseconds</summary>
        </member>
        <member name="F:EQTG.Network.PingResponse.BytesReceived">
            <summary>Amount of data received - bytes</summary>			
        </member>
        <member name="T:EQTG.RetryUtils.CustomRetryEvaluator">
            <summary>
            
            </summary>
        </member>
        <member name="T:EQTG.RetryUtils.IRetryEvaluator">
            <summary>
            Defines an interface to allow <see cref="T:EQTG.RetryUtils.RetryableAction"/> to determine if the <see cref="T:System.Exception"/>
            that caused an <see cref="T:EQTG.RetryUtils.Action"/> to fail should be retried.
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.IRetryEvaluator.Retry(System.Int32,System.Exception)">
            <summary>
            Retruns a value that indicates if the thrown <see cref="T:System.Exception"/> should be retried or not.
            </summary>
            <param name="retryCount">The number of times the action has been retried.</param>
            <param name="exception">The exception that caused the action to fail.</param>
            <returns>
            <c>true</c> if <paramref name="exception"/> should be retried, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:EQTG.RetryUtils.CustomRetryEvaluator.#ctor(EQTG.RetryUtils.Func{System.Int32,System.Exception,System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.RetryUtils.CustomSleepEvaluator"/> class.
            </summary>
            <param name="function">The function.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="function"/> is null.
            </exception>
        </member>
        <member name="M:EQTG.RetryUtils.CustomRetryEvaluator.Retry(System.Int32,System.Exception)">
            <summary>
            Retruns a value that indicates if on the thrown <see cref="T:System.Exception"/>, action should be retried or not.
            </summary>
            <param name="retryCount">The number of times the action has been retried.</param>
            <param name="exception">The exception that caused the action to fail.</param>
            <returns>
            <c>true</c> if on <paramref name="exception"/>, action should be retried, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="T:EQTG.RetryUtils.CustomSleepEvaluator">
            <summary>
            
            </summary>
        </member>
        <member name="T:EQTG.RetryUtils.ISleepEvaluator">
            <summary>
            
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.ISleepEvaluator.SleepMilliseconds(System.Int32,System.Exception)">
            <summary>
            Calculates the number of milliseconds to sleep after an action fails.
            </summary>
            <param name="retryCount">The number of times the action has been retried.</param>
            <param name="exception">The exception that caused the action to fail.</param>
            <returns>The number of milliseconds to sleep.</returns>
        </member>
        <member name="F:EQTG.RetryUtils.CustomSleepEvaluator._function">
            <summary>
            
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.CustomSleepEvaluator.#ctor(EQTG.RetryUtils.Func{System.Int32,System.Exception,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.RetryUtils.CustomSleepEvaluator"/> class.
            </summary>
            <param name="function">The function.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="function"/> is null.
            </exception>
        </member>
        <member name="M:EQTG.RetryUtils.CustomSleepEvaluator.SleepMilliseconds(System.Int32,System.Exception)">
            <summary>
            Calculates the number of milliseconds to sleep after an action fails.
            </summary>
            <param name="retryCount">The number of times the action has been retried.</param>
            <param name="exception">The exception that caused the action to fail.</param>
            <returns>The number of milliseconds to sleep.</returns>
        </member>
        <member name="T:EQTG.RetryUtils.RandomExponentialSleepEvaluator">
            <summary>
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.RandomExponentialSleepEvaluator.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:EQTG.RetryUtils.RandomExponentialSleepEvaluator"/> class.
            </summary>
            <param name="minimumDelay">The minimum delay.</param>
            <param name="multiply">Number to multiply retry count.</param>
            <param name="add">Number to add to retry count.</param>
            <param name="power">The power for exponential backoff.</param>
        </member>
        <member name="M:EQTG.RetryUtils.RandomExponentialSleepEvaluator.SleepMilliseconds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sleeps the milliseconds.  The random range is obtained by (retryCount*multiply+add)**power
            </summary>
            <param name="retryCount">The retry count.</param>
            <param name="minimumDelay">The minimum delay.</param>
            <param name="multiply">Number to multiply retry count.</param>
            <param name="add">Number to add to retry count.</param>
            <param name="power">The power for exponential backoff.</param>
            <returns>Number of ms to sleep.</returns>
        </member>
        <member name="T:EQTG.RetryUtils.Action">
            <summary>
            
            </summary>
        </member>
        <member name="T:EQTG.RetryUtils.RetryableAction">
            <summary>
            
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.#cctor">
            <summary>
            Initializes the <see cref="T:EQTG.RetryUtils.RetryableAction"/> class.
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute(EQTG.RetryUtils.Action)">
            <summary>
            Retries the specified action.
            </summary>
            <param name="action">The action.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/> is null.
            </exception>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute(EQTG.RetryUtils.Action,EQTG.RetryUtils.IRetryEvaluator)">
            <summary>
            Retries the specified action.
            </summary>
            <param name="action">The action.</param>
            <param name="retryEvaluator">
            A function that determines if the <paramref name="action"/> should be retried.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/> or <paramref name="retryEvaluator"/> is null.
            </exception>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute(EQTG.RetryUtils.Action,EQTG.RetryUtils.IRetryEvaluator,EQTG.RetryUtils.ISleepEvaluator)">
            <summary>
            Retries the specified action.
            </summary>
            <param name="action">The action.</param>
            <param name="retryEvaluator">The should retry func.</param>
            <param name="sleepEvaluator">The sleep evaluator.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/>, <paramref name="retryEvaluator"/> or <paramref name="sleepEvaluator"/> is null.
            </exception>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute``1(EQTG.RetryUtils.Func{``0},EQTG.RetryUtils.IRetryEvaluator,EQTG.RetryUtils.ISleepEvaluator)">
            <summary>
            Executes the specified function.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="retryEvaluator">The retry evaluator.</param>
            <param name="sleepEvaluator">The sleep evaluator.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute``2(EQTG.RetryUtils.Func{``0,``1},``0,EQTG.RetryUtils.IRetryEvaluator,EQTG.RetryUtils.ISleepEvaluator)">
            <summary>
            Executes the specified function.
            </summary>
            <typeparam name="T1">The type of the 1.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="argument1">The argument1.</param>
            <param name="retryEvaluator">The retry evaluator.</param>
            <param name="sleepEvaluator">The sleep evaluator.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute``3(EQTG.RetryUtils.Func{``0,``1,``2},``0,``1,EQTG.RetryUtils.IRetryEvaluator,EQTG.RetryUtils.ISleepEvaluator)">
            <summary>
            Executes the specified function.
            </summary>
            <typeparam name="T1">The type of the 1.</typeparam>
            <typeparam name="T2">The type of the 2.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="argument1">The argument1.</param>
            <param name="argument2">The argument2.</param>
            <param name="retryEvaluator">The retry evaluator.</param>
            <param name="sleepEvaluator">The sleep evaluator.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute``4(EQTG.RetryUtils.Func{``0,``1,``2,``3},``0,``1,``2,EQTG.RetryUtils.IRetryEvaluator,EQTG.RetryUtils.ISleepEvaluator)">
            <summary>
            Executes the specified function.
            </summary>
            <typeparam name="T1">The type of the 1.</typeparam>
            <typeparam name="T2">The type of the 2.</typeparam>
            <typeparam name="T3">The type of the 3.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="argument1">The argument1.</param>
            <param name="argument2">The argument2.</param>
            <param name="argument3">The argument3.</param>
            <param name="retryEvaluator">The retry evaluator.</param>
            <param name="sleepEvaluator">The sleep evaluator.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.RetryableAction.Execute``6(EQTG.RetryUtils.Func{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4,EQTG.RetryUtils.IRetryEvaluator,EQTG.RetryUtils.ISleepEvaluator)">
            <summary>
            Executes the specified function.
            </summary>
            <typeparam name="T1">The type of the 1.</typeparam>
            <typeparam name="T2">The type of the 2.</typeparam>
            <typeparam name="T3">The type of the 3.</typeparam>
            <typeparam name="T4">The type of the 4.</typeparam>
            <typeparam name="T5">The type of the 5.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="argument1">The argument1.</param>
            <param name="argument2">The argument2.</param>
            <param name="argument3">The argument3.</param>
            <param name="argument4">The argument4.</param>
            <param name="argument5">The argument5.</param>
            <param name="retryEvaluator">The retry evaluator.</param>
            <param name="sleepEvaluator">The sleep evaluator.</param>
            <returns></returns>
        </member>
        <member name="P:EQTG.RetryUtils.RetryableAction.DefaultRetryEvaluator">
            <summary>
            Gets the default <see cref="T:EQTG.RetryUtils.IRetryEvaluator"/> if one is not supplied.
            </summary>
            <value>The default <see cref="T:EQTG.RetryUtils.IRetryEvaluator"/>.</value>
        </member>
        <member name="P:EQTG.RetryUtils.RetryableAction.DefaultSleepEvaluator">
            <summary>
            Gets the default <see cref="T:EQTG.RetryUtils.ISleepEvaluator"/> if one is not supplied.
            </summary>
            <value>The default sleep evaluator.</value>
        </member>
        <member name="T:EQTG.RetryUtils.SleepFor">
            <summary>
            
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.SleepFor.RandomExponential(System.Int32)">
            <summary>
            Randoms the exponential.
            </summary>
            <param name="minimumDelay">The minimum delay.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.SleepFor.Milliseconds(System.Int32)">
            <summary>
            Millisecondses the specified milliseconds.
            </summary>
            <param name="milliseconds">The milliseconds.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.SleepFor.Custom(EQTG.RetryUtils.Func{System.Int32,System.Exception,System.Int32})">
            <summary>
            Customs the specified function.
            </summary>
            <param name="function">The function.</param>
            <returns></returns>
        </member>
        <member name="T:EQTG.RetryUtils.RetryIf">
            <summary>
            </summary>
        </member>
        <member name="M:EQTG.RetryUtils.RetryIf.Custom(EQTG.RetryUtils.Func{System.Int32,System.Exception,System.Boolean})">
            <summary>
            Retry on exception if the <paramref name="function"/> evaluates to true.
            </summary>
            <param name="function">The function.</param>
            <returns></returns>
        </member>
        <member name="M:EQTG.RetryUtils.RetryIf.RetryCountIsLessThan(System.Int32)">
            <summary>
            Retry on exception if the count is less than <paramref name="retryCount"/>.
            </summary>
            <param name="retryCount">The retry count.</param>
            <returns></returns>
        </member>
        <member name="P:EQTG.RetryUtils.RetryIf.Never">
            <summary>
            Never retry on exception.
            </summary>
            <returns></returns>
        </member>
        <member name="T:EQTG.Web.FormDataMessage">
            <summary>
            A class to help building a multi-part mime message containing form data.
            </summary>
            This is intended as a "one-shot" class - do not add more message parts after calling either GetData or GetBoundary
            Can be used in conjunction with FormDataPoster to post data to a web site.
            See the CBMarkItUpload application for an example.
        </member>
        <member name="M:EQTG.Web.FormDataMessage.#ctor">
            <summary>
            Default constructor 
            </summary>
        </member>
        <member name="M:EQTG.Web.FormDataMessage.AddNameValue(System.String,System.String)">
            <summary>
            Add a (name,value) pair to the message, e.g. the name of an edit box and the data from the edit box
            </summary>
            <param name="name">The form element name</param>
            <param name="value">The value associated with the form element</param>
        </member>
        <member name="M:EQTG.Web.FormDataMessage.AddBlock(System.String)">
            <summary>
            Add an entire message part as a single string. Used for complex items such as file uploads.
            </summary>
            <param name="messagePart">The message string</param>
        </member>
        <member name="M:EQTG.Web.FormDataMessage.GetBoundary">
            <summary>
            Get the string that should be used as the boundary string
            </summary>
            Multi-part message use a string to delimit message parts and to terminate the message, 
            this must not form part of the message text.
            <returns>The boundary string</returns>
        </member>
        <member name="M:EQTG.Web.FormDataMessage.GetData">
            <summary>
            Get the raw data that should be sent as the message
            </summary>
            <returns>The raw data to post</returns>
        </member>
        <member name="F:EQTG.Web.FormDataMessage.myBoundary">
            <summary>
            The boundary string used to separate the parts
            </summary>
        </member>
        <member name="F:EQTG.Web.FormDataMessage.myMessageParts">
            <summary>
            The message parts
            </summary>
        </member>
        <member name="T:EQTG.Web.FormDataPoster">
            <summary>
            Simple class to encapsulate posting form data to a web site FormDataPoster.
            </summary>
            See CBMarkItUpload for a sample application.
        </member>
        <member name="M:EQTG.Web.FormDataPoster.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:EQTG.Web.FormDataPoster.BuildRequest(System.String,System.String)">
            <summary>
            Create a HttpWebRequest object to use for posting the data and fill in the basics.
            This allows the caller to modify the request before actually posting the data
            </summary>
            <param name="uploadURL">URL to post to</param>
            <param name="proxy">Proxy to use (empty for no proxy)</param>
            <returns>The web request object</returns>
        </member>
        <member name="M:EQTG.Web.FormDataPoster.PostMessage(System.Net.HttpWebRequest,EQTG.Web.FormDataMessage)">
            <summary>
            Actually post a message
            </summary>
            <param name="request">The request object to use to post the message, can be built with BuildRequest</param>
            <param name="message">The message object containing the data to post</param>
        </member>
        <member name="T:EQTG.XML.IXmlProducer">
             <summary>
            Interface for any class that can render itself as an XML element
             </summary>
        </member>
        <member name="M:EQTG.XML.IXmlProducer.AppendElement(System.Xml.XmlElement,System.String)">
            <summary>
            Return an XML element with the given name as a child of the given parent
            </summary>
        </member>
        <member name="T:EQTG.XML.XmlBuildUtils">
            <summary>
            Utility builder functions
            </summary>
        </member>
        <member name="M:EQTG.XML.XmlBuildUtils.FindOrCreateElement(System.Xml.XmlElement,System.String)">
            <summary>
            Utility XML function to find or create an element of the supplied name under a parent element
            </summary>
            <param name="parentElement">Element under which named element is to be found or created</param>
            <param name="elementName">Name of the element to find or create</param>
            <returns>Existing or new element under parent element</returns>
        </member>
        <member name="M:EQTG.XML.XmlBuildUtils.AddElement(System.Xml.XmlElement,System.String)">
            <summary>
            Creates an element of the given name and appends it to the parent
            </summary>
            <param name="parent">Parent node</param>
            <param name="name">New element name</param>
            <returns>New element</returns>
        </member>
        <member name="M:EQTG.XML.XmlBuildUtils.AddLeafElement(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            Creates an element of the given name, appends it to the parent and sets its content
            </summary>
            <param name="parent">Parent node</param>
            <param name="name">New element name</param>
            <param name="content">Content</param>
            <returns>New element</returns>
        </member>
        <member name="M:EQTG.XML.XmlBuildUtils.AddAttribute(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            Creates an attribute with the given name and value and apprends it to the owner
            </summary>
            <param name="owner">Element to get attribute</param>
            <param name="name">Attribute name</param>
            <param name="val">Attribute value</param>
            <returns>New attribute</returns>
        </member>
        <member name="T:EQTG.XML.XmlDataRowAdapter">
            <summary>
            Summary description for XmlDataRowAdapter.
            </summary>
        </member>
        <member name="T:EQTG.XML.XMLResultSetReader">
            <summary>
            Reader implementing the IDataReader interface for EQTG XML Results sets. (i.e. conforming
            to a given pattern, as produced by the XML Broadcast server)
            </summary>
        </member>
        <member name="T:EQTG.XML.XmlSearchUtils">
            <summary>
            Various helpful search tools, which cope with namespaces in XML
            </summary>
        </member>
        <member name="M:EQTG.XML.XmlSearchUtils.GetDouble(System.String)">
            <summary>
            Gets a double from the XML Document
            </summary>
            <param name="path">The XPath to the element.</param>
            <returns>A double</returns>
        </member>
        <member name="M:EQTG.XML.XmlSearchUtils.GetDouble(System.String,System.Boolean)">
            <summary>
            Gets a double from the XML Document
            </summary>
            <param name="path">The XPath to the element.</param>
            <param name="noThrow">A boolean to throw errors or not.</param>
            <returns>A double</returns>
        </member>
        <member name="M:EQTG.XML.XmlSearchUtils.FindElementByName(System.Xml.XmlElement,System.String)">
            <summary>
            Find a given element directly under another element by name
            Only for where single item exists matching by name
            </summary>
            <param name="parentElement">Parent element</param>
            <param name="name">Name of element to find</param>
            <returns>Single element with matching name</returns>
        </member>
        <member name="M:EQTG.XML.XmlSearchUtils.ExtractDoubleFromElement(System.Xml.XmlElement)">
            <summary>
            Parse a number from an element where the number is the only child node of the supplied element
            Will throw if cannot parse number
            </summary>
            <param name="el">Element to extract from</param>
            <returns>Parsed number</returns>
        </member>
        <member name="M:EQTG.XML.XmlSearchUtils.ExtractStringFromElement(System.Xml.XmlElement)">
            <summary>
            Parse a string from an element where the string is the only child node of the supplied element
            </summary>
            <param name="el"></param>
            <returns></returns>
        </member>
        <member name="T:EQTG.XML.XPathUtils">
            <summary>
            XPath Utility class, built thinly on Microsoft .NET XPath stuff
            </summary>
        </member>
        <member name="M:EQTG.XML.XPathUtils.NodeIteratorFromXPath(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:EQTG.XML.XPathUtils.SingleStringFromXPath(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Simple string from XPath
            </summary>
            <param name="navigator">Navigator</param>
            <param name="xPath">XPath string</param>
            <returns>Single value</returns>
        </member>
    </members>
</doc>
